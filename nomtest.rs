   Compiling nom v1.1.0 (file:///Users/joel.self/Projects/nom)
#![feature(prelude_import)]
#![no_std]
//! nom, eating data byte by byte
//!
//! nom is a parser combinator library with a focus on safe parsing,
//! streaming patterns, and as much as possible zero copy.
//!
//! The code is available on [Github](https://github.com/Geal/nom)
//!
//! # Example
//!
//! ```
//! #[macro_use]
//! extern crate nom;
//!
//! use nom::{IResult,digit};
//! use nom::IResult::*;
//!
//! // Parser definition
//!
//! use std::str;
//! use std::str::FromStr;
//!
//! named!(parens<i64>, delimited!(
//!     char!('('),
//!     expr,
//!     char!(')')
//!   )
//! );
//!
//! named!(i64_digit<i64>,
//!   map_res!(
//!     map_res!(
//!       digit,
//!       str::from_utf8
//!     ),
//!     FromStr::from_str
//!   )
//! );
//!
//! // We transform an integer string into a i64
//! // we look for a digit suite, and try to convert it.
//! // if either str::from_utf8 or FromStr::from_str fail,
//! // the parser will fail
//! named!(factor<i64>,
//!   alt!(
//!     i64_digit
//!   | parens
//!   )
//! );
//!
//! // we define acc as mutable to update its value whenever a new term is found
//! named!(term <i64>,
//!   chain!(
//!     mut acc: factor  ~
//!              many0!(
//!                alt!(
//!                  tap!(mul: preceded!(tag!("*"), factor) => acc = acc * mul) |
//!                  tap!(div: preceded!(tag!("/"), factor) => acc = acc / div)
//!                )
//!              ),
//!     || { return acc }
//!   )
//! );
//!
//! named!(expr <i64>,
//!   chain!(
//!     mut acc: term  ~
//!              many0!(
//!                alt!(
//!                  tap!(add: preceded!(tag!("+"), term) => acc = acc + add) |
//!                  tap!(sub: preceded!(tag!("-"), term) => acc = acc - sub)
//!                )
//!              ),
//!     || { return acc }
//!   )
//! );
//!
//! fn main() {
//!   assert_eq!(expr(b"1+2"),         IResult::Done(&b""[..], 3));
//!   assert_eq!(expr(b"12+6-4+3"),    IResult::Done(&b""[..], 17));
//!   assert_eq!(expr(b"1+2*3+4"),     IResult::Done(&b""[..], 11));
//!
//!   assert_eq!(expr(b"(2)"),         IResult::Done(&b""[..], 2));
//!   assert_eq!(expr(b"2*(3+4)"),     IResult::Done(&b""[..], 14));
//!   assert_eq!(expr(b"2*2/(5-1)+3"), IResult::Done(&b""[..], 4));
//! }
//! ```
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;



pub use self::util::*;
pub use self::internal::*;
pub use self::macros::*;
pub use self::methods::*;
pub use self::bytes::*;
pub use self::bits::*;

pub use self::nom::*;
pub use self::character::*;


#[cfg(not(feature = "core"))]
#[cfg(feature = "stream")]
pub use self::stream::*;

#[cfg(not(feature = "core"))]
pub use self::str::*;

#[macro_use]
mod util {
    #[prelude_import]
    use std::prelude::v1::*;




    use internal::{IResult, Err};
    #[cfg(not(feature = "core"))]
    use std::collections::HashMap;
    use std::vec::Vec;
    use std::string::ToString;
    /// useful functions to calculate the offset between slices and show a hexdump of a slice
    #[cfg(not(feature = "core"))]
    pub trait HexDisplay {
        /// offset between the first byte of self and the first byte of the argument
        fn offset(&self, second: &[u8])
        -> usize;
        /// Converts the value of `self` to a hex dump, returning the owned
        /// string.
        fn to_hex(&self, chunk_size: usize)
        -> String;
        /// Converts the value of `self` to a hex dump beginning at `from` address, returning the owned
        /// string.
        fn to_hex_from(&self, chunk_size: usize, from: usize)
        -> String;
    }
    pub trait InputLength {
        #[inline]
        fn input_len(&self)
        -> usize;
    }
    impl <'a, T> InputLength for &'a [T] {
        #[inline]
        fn input_len(&self) -> usize { self.len() }
    }
    impl <'a> InputLength for &'a str {
        #[inline]
        fn input_len(&self) -> usize { self.len() }
    }
    impl <'a> InputLength for (&'a [u8], usize) {
        #[inline]
        fn input_len(&self) -> usize {
            let res = self.0.len() * 8 - self.1;
            res
        }
    }
    use std::iter::Enumerate;
    use std::str::CharIndices;
    pub trait AsChar {
        #[inline]
        fn as_char(self)
        -> char;
        #[inline]
        fn is_alpha(self)
        -> bool;
        #[inline]
        fn is_alphanum(self)
        -> bool;
        #[inline]
        fn is_0_to_9(self)
        -> bool;
        #[inline]
        fn is_hex_digit(self)
        -> bool;
    }
    impl <'a> AsChar for &'a u8 {
        #[inline]
        fn as_char(self) -> char { *self as char }
        #[inline]
        fn is_alpha(self) -> bool {
            (*self >= 65 && *self <= 90) || (*self >= 97 && *self <= 122)
        }
        #[inline]
        fn is_alphanum(self) -> bool { self.is_alpha() || self.is_0_to_9() }
        #[inline]
        fn is_0_to_9(self) -> bool { *self >= 48 && *self <= 57 }
        #[inline]
        fn is_hex_digit(self) -> bool {
            (*self >= 48 && *self <= 57) || (*self >= 65 && *self <= 70) ||
                (*self >= 97 && *self <= 102)
        }
    }
    impl AsChar for char {
        #[inline]
        fn as_char(self) -> char { self }
        #[inline]
        fn is_alpha(self) -> bool { self.is_alphabetic() }
        #[inline]
        fn is_alphanum(self) -> bool { self.is_alpha() || self.is_0_to_9() }
        #[inline]
        fn is_0_to_9(self) -> bool { self.is_digit(10) }
        #[inline]
        fn is_hex_digit(self) -> bool { self.is_digit(16) }
    }
    pub trait IterIndices {
        type
        Item: AsChar;
        type
        Iter: Iterator<Item
        =
        (usize, Self::Item)>;
        fn iter_indices(self)
        -> Self::Iter;
    }
    impl <'a> IterIndices for &'a [u8] {
        type
        Item
        =
        &'a u8;
        type
        Iter
        =
        Enumerate<::std::slice::Iter<'a, u8>>;
        #[inline]
        fn iter_indices(self) -> Enumerate<::std::slice::Iter<'a, u8>> {
            self.iter().enumerate()
        }
    }
    impl <'a> IterIndices for &'a str {
        type
        Item
        =
        char;
        type
        Iter
        =
        CharIndices<'a>;
        #[inline]
        fn iter_indices(self) -> CharIndices<'a> { self.char_indices() }
    }
    static CHARS: &'static [u8] = b"0123456789abcdef";
    #[cfg(not(feature = "core"))]
    impl HexDisplay for [u8] {
        fn offset(&self, second: &[u8]) -> usize {
            let fst = self.as_ptr();
            let snd = second.as_ptr();
            (snd as usize) - (fst as usize)
        }
        #[allow(unused_variables)]
        fn to_hex(&self, chunk_size: usize) -> String {
            self.to_hex_from(chunk_size, 0)
        }
        #[allow(unused_variables)]
        fn to_hex_from(&self, chunk_size: usize, from: usize) -> String {
            let mut v = Vec::with_capacity(self.len() * 3);
            let mut i = from;
            for chunk in self.chunks(chunk_size) {
                let s =
                    ::std::fmt::format(::std::fmt::Arguments::new_v1_formatted({
                                                                                   static __STATIC_FMTSTR:
                                                                                          &'static [&'static str]
                                                                                          =
                                                                                       &[""];
                                                                                   __STATIC_FMTSTR
                                                                               },
                                                                               &match (&i,)
                                                                                    {
                                                                                    (__arg0,)
                                                                                    =>
                                                                                    [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                 ::std::fmt::LowerHex::fmt)],
                                                                                },
                                                                               {
                                                                                   static __STATIC_FMTARGS:
                                                                                          &'static [::std::fmt::rt::v1::Argument]
                                                                                          =
                                                                                       &[::std::fmt::rt::v1::Argument{position:
                                                                                                                          ::std::fmt::rt::v1::Position::Next,
                                                                                                                      format:
                                                                                                                          ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                             ' ',
                                                                                                                                                         align:
                                                                                                                                                             ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                         flags:
                                                                                                                                                             8u32,
                                                                                                                                                         precision:
                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                         width:
                                                                                                                                                             ::std::fmt::rt::v1::Count::Is(8usize),},}];
                                                                                   __STATIC_FMTARGS
                                                                               }));
                for &ch in s.as_bytes().iter() { v.push(ch); }
                v.push('\t' as u8);
                i = i + chunk_size;
                for &byte in chunk {
                    v.push(CHARS[(byte >> 4) as usize]);
                    v.push(CHARS[(byte & 15) as usize]);
                    v.push(' ' as u8);
                }
                if chunk_size > chunk.len() {
                    for j in 0..(chunk_size - chunk.len()) {
                        v.push(' ' as u8);
                        v.push(' ' as u8);
                        v.push(' ' as u8);
                    }
                }
                v.push('\t' as u8);
                for &byte in chunk {
                    if (byte >= 32 && byte <= 126) || byte >= 128 {
                        v.push(byte);
                    } else { v.push('.' as u8); }
                }
                v.push('\n' as u8);
            }
            String::from_utf8_lossy(&v[..]).into_owned()
        }
    }
    pub fn error_to_list<P, E: Clone>(e: &Err<P, E>) -> Vec<ErrorKind<E>> {
        let mut v: Vec<ErrorKind<E>> = Vec::new();
        let mut err = e;
        loop  {
            match *err {
                Err::Code(ref i) | Err::Position(ref i, _) => {
                    v.push(i.clone());
                    return v;
                }
                Err::Node(ref i, ref next) |
                Err::NodePosition(ref i, _, ref next) => {
                    v.push(i.clone());
                    err = &*next;
                }
            }
        }
    }
    pub fn compare_error_paths<P, E: Clone +
                               PartialEq>(e1: &Err<P, E>, e2: &Err<P, E>)
     -> bool {
        error_to_list(e1) == error_to_list(e2)
    }
    use std::hash::Hash;
    #[cfg(not(feature = "core"))]
    pub fn add_error_pattern<'a, I, O, E: Clone + Hash +
                             Eq>(h: &mut HashMap<Vec<ErrorKind<E>>, &'a str>,
                                 res: IResult<I, O, E>, message: &'a str)
     -> bool {
        if let IResult::Error(e) = res {
            h.insert(error_to_list(&e), message);
            true
        } else { false }
    }
    pub fn slice_to_offsets(input: &[u8], s: &[u8]) -> (usize, usize) {
        let start = input.as_ptr();
        let off1 = (s.as_ptr() as usize) - (start as usize);
        let off2 = off1 + s.len();
        (off1, off2)
    }
    #[cfg(not(feature = "core"))]
    pub fn prepare_errors<O,
                          E: Clone>(input: &[u8], res: IResult<&[u8], O, E>)
     -> Option<Vec<(ErrorKind<E>, usize, usize)>> {
        if let IResult::Error(e) = res {
            let mut v: Vec<(ErrorKind<E>, usize, usize)> = Vec::new();
            let mut err = e.clone();
            loop  {
                match err {
                    Err::Position(i, s) => {
                        let (o1, o2) = slice_to_offsets(input, s);
                        v.push((i, o1, o2));
                        break ;
                    }
                    Err::NodePosition(i, s, next) => {
                        let (o1, o2) = slice_to_offsets(input, s);
                        v.push((i, o1, o2));
                        err = *next;
                    }
                    Err::Node(_, next) => { err = *next; }
                    Err::Code(_) => { break ; }
                }
            }
            v.sort_by(|a, b| a.1.cmp(&b.1));
            Some(v)
        } else { None }
    }
    #[cfg(not(feature = "core"))]
    pub fn print_error<O, E: Clone>(input: &[u8], res: IResult<&[u8], O, E>) {
        if let Some(v) = prepare_errors(input, res) {
            let colors = generate_colors(&v);
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["parser codes: ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&print_codes(colors,
                                                                                 HashMap::new()),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Display::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&print_offsets(input,
                                                                                   0,
                                                                                   &v),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Display::fmt)],
                                                             }));
        } else {
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["not an error\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match () {
                                                                 () => [],
                                                             }));
        }
    }
    #[cfg(not(feature = "core"))]
    pub fn generate_colors<E>(v: &[(ErrorKind<E>, usize, usize)])
     -> HashMap<u32, u8> {
        let mut h: HashMap<u32, u8> = HashMap::new();
        let mut color = 0;
        for &(ref c, _, _) in v.iter() {
            h.insert(error_to_u32(c), color + 31);
            color = color + 1 % 7;
        }
        h
    }
    pub fn code_from_offset<E>(v: &[(ErrorKind<E>, usize, usize)],
                               offset: usize) -> Option<u32> {
        let mut acc: Option<(u32, usize, usize)> = None;
        for &(ref ek, s, e) in v.iter() {
            let c = error_to_u32(ek);
            if s <= offset && offset <= e {
                if let Some((_, start, end)) = acc {
                    if start <= s && e <= end { acc = Some((c, s, e)); }
                } else { acc = Some((c, s, e)); }
            }
        }
        if let Some((code, _, _)) = acc {
            return Some(code);
        } else { return None; }
    }
    pub fn reset_color(v: &mut Vec<u8>) {
        v.push(27);
        v.push('[' as u8);
        v.push(0);
        v.push('m' as u8);
    }
    pub fn write_color(v: &mut Vec<u8>, color: u8) {
        v.push(27);
        v.push('[' as u8);
        v.push(1);
        v.push(';' as u8);
        let s = color.to_string();
        let bytes = s.as_bytes();
        v.extend(bytes.iter().cloned());
        v.push('m' as u8);
    }
    #[cfg(not(feature = "core"))]
    pub fn print_codes(colors: HashMap<u32, u8>, names: HashMap<u32, &str>)
     -> String {
        let mut v = Vec::new();
        for (code, &color) in &colors {
            if let Some(&s) = names.get(&code) {
                let bytes = s.as_bytes();
                write_color(&mut v, color);
                v.extend(bytes.iter().cloned());
            } else {
                let s = code.to_string();
                let bytes = s.as_bytes();
                write_color(&mut v, color);
                v.extend(bytes.iter().cloned());
            }
            reset_color(&mut v);
            v.push(' ' as u8);
        }
        reset_color(&mut v);
        String::from_utf8_lossy(&v[..]).into_owned()
    }
    #[cfg(not(feature = "core"))]
    pub fn print_offsets<E>(input: &[u8], from: usize,
                            offsets: &[(ErrorKind<E>, usize, usize)])
     -> String {
        let mut v = Vec::with_capacity(input.len() * 3);
        let mut i = from;
        let chunk_size = 8;
        let mut current_code: Option<u32> = None;
        let mut current_code2: Option<u32> = None;
        let colors = generate_colors(&offsets);
        for chunk in input.chunks(chunk_size) {
            let s =
                ::std::fmt::format(::std::fmt::Arguments::new_v1_formatted({
                                                                               static __STATIC_FMTSTR:
                                                                                      &'static [&'static str]
                                                                                      =
                                                                                   &[""];
                                                                               __STATIC_FMTSTR
                                                                           },
                                                                           &match (&i,)
                                                                                {
                                                                                (__arg0,)
                                                                                =>
                                                                                [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                             ::std::fmt::LowerHex::fmt)],
                                                                            },
                                                                           {
                                                                               static __STATIC_FMTARGS:
                                                                                      &'static [::std::fmt::rt::v1::Argument]
                                                                                      =
                                                                                   &[::std::fmt::rt::v1::Argument{position:
                                                                                                                      ::std::fmt::rt::v1::Position::Next,
                                                                                                                  format:
                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                         ' ',
                                                                                                                                                     align:
                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                     flags:
                                                                                                                                                         8u32,
                                                                                                                                                     precision:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                     width:
                                                                                                                                                         ::std::fmt::rt::v1::Count::Is(8usize),},}];
                                                                               __STATIC_FMTARGS
                                                                           }));
            for &ch in s.as_bytes().iter() { v.push(ch); }
            v.push('\t' as u8);
            let mut k = i;
            let mut l = i;
            for &byte in chunk {
                if let Some(code) = code_from_offset(&offsets, k) {
                    if let Some(current) = current_code {
                        if current != code {
                            reset_color(&mut v);
                            current_code = Some(code);
                            if let Some(&color) = colors.get(&code) {
                                write_color(&mut v, color);
                            }
                        }
                    } else {
                        current_code = Some(code);
                        if let Some(&color) = colors.get(&code) {
                            write_color(&mut v, color);
                        }
                    }
                }
                v.push(CHARS[(byte >> 4) as usize]);
                v.push(CHARS[(byte & 15) as usize]);
                v.push(' ' as u8);
                k = k + 1;
            }
            reset_color(&mut v);
            if chunk_size > chunk.len() {
                for _ in 0..(chunk_size - chunk.len()) {
                    v.push(' ' as u8);
                    v.push(' ' as u8);
                    v.push(' ' as u8);
                }
            }
            v.push('\t' as u8);
            for &byte in chunk {
                if let Some(code) = code_from_offset(&offsets, l) {
                    if let Some(current) = current_code2 {
                        if current != code {
                            reset_color(&mut v);
                            current_code2 = Some(code);
                            if let Some(&color) = colors.get(&code) {
                                write_color(&mut v, color);
                            }
                        }
                    } else {
                        current_code2 = Some(code);
                        if let Some(&color) = colors.get(&code) {
                            write_color(&mut v, color);
                        }
                    }
                }
                if (byte >= 32 && byte <= 126) || byte >= 128 {
                    v.push(byte);
                } else { v.push('.' as u8); }
                l = l + 1;
            }
            reset_color(&mut v);
            v.push('\n' as u8);
            i = i + chunk_size;
        }
        String::from_utf8_lossy(&v[..]).into_owned()
    }
    pub trait AsBytes {
        fn as_bytes(&self)
        -> &[u8];
    }
    impl <'a> AsBytes for &'a str {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { str::as_bytes(self) }
    }
    impl AsBytes for str {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { str::as_bytes(self) }
    }
    impl <'a> AsBytes for &'a [u8] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 0] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 0] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 1] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 1] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 2] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 2] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 3] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 3] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 4] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 4] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 5] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 5] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 6] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 6] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 7] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 7] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 8] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 8] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 9] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 9] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 10] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 10] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 11] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 11] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 12] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 12] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 13] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 13] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 14] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 14] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 15] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 15] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 16] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 16] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 17] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 17] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 18] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 18] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 19] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 19] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 20] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 20] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 21] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 21] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 22] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 22] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 23] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 23] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 24] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 24] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 25] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 25] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 26] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 26] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 27] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 27] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 28] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 28] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 29] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 29] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 30] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 30] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 31] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 31] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    impl <'a> AsBytes for &'a [u8; 32] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { *self }
    }
    impl AsBytes for [u8; 32] {
        #[inline(always)]
        fn as_bytes(&self) -> &[u8] { self }
    }
    /// indicates which parser returned an error
    pub enum ErrorKind<E = u32> {
        Custom(E),
        Tag,
        MapRes,
        MapOpt,
        Alt,
        IsNot,
        IsA,
        SeparatedList,
        SeparatedNonEmptyList,
        Many1,
        Count,
        TakeUntilAndConsume,
        TakeUntil,
        TakeUntilEitherAndConsume,
        TakeUntilEither,
        LengthValue,
        TagClosure,
        Alpha,
        Digit,
        HexDigit,
        AlphaNumeric,
        Space,
        MultiSpace,
        LengthValueFn,
        Eof,
        ExprOpt,
        ExprRes,
        CondReduce,
        Switch,
        TagBits,
        OneOf,
        NoneOf,
        Char,
        CrLf,
        RegexpMatch,
        RegexpMatches,
        RegexpFind,
        RegexpCapture,
        RegexpCaptures,
        TakeWhile1,
        Complete,
        Fix,
        Escaped,
        EscapedTransform,
        TagStr,
        IsNotStr,
        IsAStr,
        TakeWhile1Str,
        NonEmpty,
        ManyMN,
        TakeUntilAndConsumeStr,
        TakeUntilStr,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <E: ::std::clone::Clone> ::std::clone::Clone for ErrorKind<E> {
        #[inline]
        fn clone(&self) -> ErrorKind<E> {
            match (&*self,) {
                (&ErrorKind::Custom(ref __self_0),) =>
                ErrorKind::Custom(::std::clone::Clone::clone(&(*__self_0))),
                (&ErrorKind::Tag,) => ErrorKind::Tag,
                (&ErrorKind::MapRes,) => ErrorKind::MapRes,
                (&ErrorKind::MapOpt,) => ErrorKind::MapOpt,
                (&ErrorKind::Alt,) => ErrorKind::Alt,
                (&ErrorKind::IsNot,) => ErrorKind::IsNot,
                (&ErrorKind::IsA,) => ErrorKind::IsA,
                (&ErrorKind::SeparatedList,) => ErrorKind::SeparatedList,
                (&ErrorKind::SeparatedNonEmptyList,) =>
                ErrorKind::SeparatedNonEmptyList,
                (&ErrorKind::Many1,) => ErrorKind::Many1,
                (&ErrorKind::Count,) => ErrorKind::Count,
                (&ErrorKind::TakeUntilAndConsume,) =>
                ErrorKind::TakeUntilAndConsume,
                (&ErrorKind::TakeUntil,) => ErrorKind::TakeUntil,
                (&ErrorKind::TakeUntilEitherAndConsume,) =>
                ErrorKind::TakeUntilEitherAndConsume,
                (&ErrorKind::TakeUntilEither,) => ErrorKind::TakeUntilEither,
                (&ErrorKind::LengthValue,) => ErrorKind::LengthValue,
                (&ErrorKind::TagClosure,) => ErrorKind::TagClosure,
                (&ErrorKind::Alpha,) => ErrorKind::Alpha,
                (&ErrorKind::Digit,) => ErrorKind::Digit,
                (&ErrorKind::HexDigit,) => ErrorKind::HexDigit,
                (&ErrorKind::AlphaNumeric,) => ErrorKind::AlphaNumeric,
                (&ErrorKind::Space,) => ErrorKind::Space,
                (&ErrorKind::MultiSpace,) => ErrorKind::MultiSpace,
                (&ErrorKind::LengthValueFn,) => ErrorKind::LengthValueFn,
                (&ErrorKind::Eof,) => ErrorKind::Eof,
                (&ErrorKind::ExprOpt,) => ErrorKind::ExprOpt,
                (&ErrorKind::ExprRes,) => ErrorKind::ExprRes,
                (&ErrorKind::CondReduce,) => ErrorKind::CondReduce,
                (&ErrorKind::Switch,) => ErrorKind::Switch,
                (&ErrorKind::TagBits,) => ErrorKind::TagBits,
                (&ErrorKind::OneOf,) => ErrorKind::OneOf,
                (&ErrorKind::NoneOf,) => ErrorKind::NoneOf,
                (&ErrorKind::Char,) => ErrorKind::Char,
                (&ErrorKind::CrLf,) => ErrorKind::CrLf,
                (&ErrorKind::RegexpMatch,) => ErrorKind::RegexpMatch,
                (&ErrorKind::RegexpMatches,) => ErrorKind::RegexpMatches,
                (&ErrorKind::RegexpFind,) => ErrorKind::RegexpFind,
                (&ErrorKind::RegexpCapture,) => ErrorKind::RegexpCapture,
                (&ErrorKind::RegexpCaptures,) => ErrorKind::RegexpCaptures,
                (&ErrorKind::TakeWhile1,) => ErrorKind::TakeWhile1,
                (&ErrorKind::Complete,) => ErrorKind::Complete,
                (&ErrorKind::Fix,) => ErrorKind::Fix,
                (&ErrorKind::Escaped,) => ErrorKind::Escaped,
                (&ErrorKind::EscapedTransform,) =>
                ErrorKind::EscapedTransform,
                (&ErrorKind::TagStr,) => ErrorKind::TagStr,
                (&ErrorKind::IsNotStr,) => ErrorKind::IsNotStr,
                (&ErrorKind::IsAStr,) => ErrorKind::IsAStr,
                (&ErrorKind::TakeWhile1Str,) => ErrorKind::TakeWhile1Str,
                (&ErrorKind::NonEmpty,) => ErrorKind::NonEmpty,
                (&ErrorKind::ManyMN,) => ErrorKind::ManyMN,
                (&ErrorKind::TakeUntilAndConsumeStr,) =>
                ErrorKind::TakeUntilAndConsumeStr,
                (&ErrorKind::TakeUntilStr,) => ErrorKind::TakeUntilStr,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <E: ::std::hash::Hash> ::std::hash::Hash for ErrorKind<E> {
        fn hash<__H: ::std::hash::Hasher>(&self, __arg_0: &mut __H) -> () {
            match (&*self,) {
                (&ErrorKind::Custom(ref __self_0),) => {
                    ::std::hash::Hash::hash(&0usize, __arg_0);
                    ::std::hash::Hash::hash(&(*__self_0), __arg_0);
                }
                (&ErrorKind::Tag,) => {
                    ::std::hash::Hash::hash(&1usize, __arg_0);
                }
                (&ErrorKind::MapRes,) => {
                    ::std::hash::Hash::hash(&2usize, __arg_0);
                }
                (&ErrorKind::MapOpt,) => {
                    ::std::hash::Hash::hash(&3usize, __arg_0);
                }
                (&ErrorKind::Alt,) => {
                    ::std::hash::Hash::hash(&4usize, __arg_0);
                }
                (&ErrorKind::IsNot,) => {
                    ::std::hash::Hash::hash(&5usize, __arg_0);
                }
                (&ErrorKind::IsA,) => {
                    ::std::hash::Hash::hash(&6usize, __arg_0);
                }
                (&ErrorKind::SeparatedList,) => {
                    ::std::hash::Hash::hash(&7usize, __arg_0);
                }
                (&ErrorKind::SeparatedNonEmptyList,) => {
                    ::std::hash::Hash::hash(&8usize, __arg_0);
                }
                (&ErrorKind::Many1,) => {
                    ::std::hash::Hash::hash(&9usize, __arg_0);
                }
                (&ErrorKind::Count,) => {
                    ::std::hash::Hash::hash(&10usize, __arg_0);
                }
                (&ErrorKind::TakeUntilAndConsume,) => {
                    ::std::hash::Hash::hash(&11usize, __arg_0);
                }
                (&ErrorKind::TakeUntil,) => {
                    ::std::hash::Hash::hash(&12usize, __arg_0);
                }
                (&ErrorKind::TakeUntilEitherAndConsume,) => {
                    ::std::hash::Hash::hash(&13usize, __arg_0);
                }
                (&ErrorKind::TakeUntilEither,) => {
                    ::std::hash::Hash::hash(&14usize, __arg_0);
                }
                (&ErrorKind::LengthValue,) => {
                    ::std::hash::Hash::hash(&15usize, __arg_0);
                }
                (&ErrorKind::TagClosure,) => {
                    ::std::hash::Hash::hash(&16usize, __arg_0);
                }
                (&ErrorKind::Alpha,) => {
                    ::std::hash::Hash::hash(&17usize, __arg_0);
                }
                (&ErrorKind::Digit,) => {
                    ::std::hash::Hash::hash(&18usize, __arg_0);
                }
                (&ErrorKind::HexDigit,) => {
                    ::std::hash::Hash::hash(&19usize, __arg_0);
                }
                (&ErrorKind::AlphaNumeric,) => {
                    ::std::hash::Hash::hash(&20usize, __arg_0);
                }
                (&ErrorKind::Space,) => {
                    ::std::hash::Hash::hash(&21usize, __arg_0);
                }
                (&ErrorKind::MultiSpace,) => {
                    ::std::hash::Hash::hash(&22usize, __arg_0);
                }
                (&ErrorKind::LengthValueFn,) => {
                    ::std::hash::Hash::hash(&23usize, __arg_0);
                }
                (&ErrorKind::Eof,) => {
                    ::std::hash::Hash::hash(&24usize, __arg_0);
                }
                (&ErrorKind::ExprOpt,) => {
                    ::std::hash::Hash::hash(&25usize, __arg_0);
                }
                (&ErrorKind::ExprRes,) => {
                    ::std::hash::Hash::hash(&26usize, __arg_0);
                }
                (&ErrorKind::CondReduce,) => {
                    ::std::hash::Hash::hash(&27usize, __arg_0);
                }
                (&ErrorKind::Switch,) => {
                    ::std::hash::Hash::hash(&28usize, __arg_0);
                }
                (&ErrorKind::TagBits,) => {
                    ::std::hash::Hash::hash(&29usize, __arg_0);
                }
                (&ErrorKind::OneOf,) => {
                    ::std::hash::Hash::hash(&30usize, __arg_0);
                }
                (&ErrorKind::NoneOf,) => {
                    ::std::hash::Hash::hash(&31usize, __arg_0);
                }
                (&ErrorKind::Char,) => {
                    ::std::hash::Hash::hash(&32usize, __arg_0);
                }
                (&ErrorKind::CrLf,) => {
                    ::std::hash::Hash::hash(&33usize, __arg_0);
                }
                (&ErrorKind::RegexpMatch,) => {
                    ::std::hash::Hash::hash(&34usize, __arg_0);
                }
                (&ErrorKind::RegexpMatches,) => {
                    ::std::hash::Hash::hash(&35usize, __arg_0);
                }
                (&ErrorKind::RegexpFind,) => {
                    ::std::hash::Hash::hash(&36usize, __arg_0);
                }
                (&ErrorKind::RegexpCapture,) => {
                    ::std::hash::Hash::hash(&37usize, __arg_0);
                }
                (&ErrorKind::RegexpCaptures,) => {
                    ::std::hash::Hash::hash(&38usize, __arg_0);
                }
                (&ErrorKind::TakeWhile1,) => {
                    ::std::hash::Hash::hash(&39usize, __arg_0);
                }
                (&ErrorKind::Complete,) => {
                    ::std::hash::Hash::hash(&40usize, __arg_0);
                }
                (&ErrorKind::Fix,) => {
                    ::std::hash::Hash::hash(&41usize, __arg_0);
                }
                (&ErrorKind::Escaped,) => {
                    ::std::hash::Hash::hash(&42usize, __arg_0);
                }
                (&ErrorKind::EscapedTransform,) => {
                    ::std::hash::Hash::hash(&43usize, __arg_0);
                }
                (&ErrorKind::TagStr,) => {
                    ::std::hash::Hash::hash(&44usize, __arg_0);
                }
                (&ErrorKind::IsNotStr,) => {
                    ::std::hash::Hash::hash(&45usize, __arg_0);
                }
                (&ErrorKind::IsAStr,) => {
                    ::std::hash::Hash::hash(&46usize, __arg_0);
                }
                (&ErrorKind::TakeWhile1Str,) => {
                    ::std::hash::Hash::hash(&47usize, __arg_0);
                }
                (&ErrorKind::NonEmpty,) => {
                    ::std::hash::Hash::hash(&48usize, __arg_0);
                }
                (&ErrorKind::ManyMN,) => {
                    ::std::hash::Hash::hash(&49usize, __arg_0);
                }
                (&ErrorKind::TakeUntilAndConsumeStr,) => {
                    ::std::hash::Hash::hash(&50usize, __arg_0);
                }
                (&ErrorKind::TakeUntilStr,) => {
                    ::std::hash::Hash::hash(&51usize, __arg_0);
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <E: ::std::cmp::Eq> ::std::cmp::Eq for ErrorKind<E> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&ErrorKind::Custom(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
                (&ErrorKind::Tag,) => { }
                (&ErrorKind::MapRes,) => { }
                (&ErrorKind::MapOpt,) => { }
                (&ErrorKind::Alt,) => { }
                (&ErrorKind::IsNot,) => { }
                (&ErrorKind::IsA,) => { }
                (&ErrorKind::SeparatedList,) => { }
                (&ErrorKind::SeparatedNonEmptyList,) => { }
                (&ErrorKind::Many1,) => { }
                (&ErrorKind::Count,) => { }
                (&ErrorKind::TakeUntilAndConsume,) => { }
                (&ErrorKind::TakeUntil,) => { }
                (&ErrorKind::TakeUntilEitherAndConsume,) => { }
                (&ErrorKind::TakeUntilEither,) => { }
                (&ErrorKind::LengthValue,) => { }
                (&ErrorKind::TagClosure,) => { }
                (&ErrorKind::Alpha,) => { }
                (&ErrorKind::Digit,) => { }
                (&ErrorKind::HexDigit,) => { }
                (&ErrorKind::AlphaNumeric,) => { }
                (&ErrorKind::Space,) => { }
                (&ErrorKind::MultiSpace,) => { }
                (&ErrorKind::LengthValueFn,) => { }
                (&ErrorKind::Eof,) => { }
                (&ErrorKind::ExprOpt,) => { }
                (&ErrorKind::ExprRes,) => { }
                (&ErrorKind::CondReduce,) => { }
                (&ErrorKind::Switch,) => { }
                (&ErrorKind::TagBits,) => { }
                (&ErrorKind::OneOf,) => { }
                (&ErrorKind::NoneOf,) => { }
                (&ErrorKind::Char,) => { }
                (&ErrorKind::CrLf,) => { }
                (&ErrorKind::RegexpMatch,) => { }
                (&ErrorKind::RegexpMatches,) => { }
                (&ErrorKind::RegexpFind,) => { }
                (&ErrorKind::RegexpCapture,) => { }
                (&ErrorKind::RegexpCaptures,) => { }
                (&ErrorKind::TakeWhile1,) => { }
                (&ErrorKind::Complete,) => { }
                (&ErrorKind::Fix,) => { }
                (&ErrorKind::Escaped,) => { }
                (&ErrorKind::EscapedTransform,) => { }
                (&ErrorKind::TagStr,) => { }
                (&ErrorKind::IsNotStr,) => { }
                (&ErrorKind::IsAStr,) => { }
                (&ErrorKind::TakeWhile1Str,) => { }
                (&ErrorKind::NonEmpty,) => { }
                (&ErrorKind::ManyMN,) => { }
                (&ErrorKind::TakeUntilAndConsumeStr,) => { }
                (&ErrorKind::TakeUntilStr,) => { }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <E: ::std::cmp::PartialEq> ::std::cmp::PartialEq for ErrorKind<E> {
        #[inline]
        fn eq(&self, __arg_0: &ErrorKind<E>) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&ErrorKind::Custom(ref __self_0),
                         &ErrorKind::Custom(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        (&ErrorKind::Tag, &ErrorKind::Tag) => true,
                        (&ErrorKind::MapRes, &ErrorKind::MapRes) => true,
                        (&ErrorKind::MapOpt, &ErrorKind::MapOpt) => true,
                        (&ErrorKind::Alt, &ErrorKind::Alt) => true,
                        (&ErrorKind::IsNot, &ErrorKind::IsNot) => true,
                        (&ErrorKind::IsA, &ErrorKind::IsA) => true,
                        (&ErrorKind::SeparatedList, &ErrorKind::SeparatedList)
                        => true,
                        (&ErrorKind::SeparatedNonEmptyList,
                         &ErrorKind::SeparatedNonEmptyList) => true,
                        (&ErrorKind::Many1, &ErrorKind::Many1) => true,
                        (&ErrorKind::Count, &ErrorKind::Count) => true,
                        (&ErrorKind::TakeUntilAndConsume,
                         &ErrorKind::TakeUntilAndConsume) => true,
                        (&ErrorKind::TakeUntil, &ErrorKind::TakeUntil) =>
                        true,
                        (&ErrorKind::TakeUntilEitherAndConsume,
                         &ErrorKind::TakeUntilEitherAndConsume) => true,
                        (&ErrorKind::TakeUntilEither,
                         &ErrorKind::TakeUntilEither) => true,
                        (&ErrorKind::LengthValue, &ErrorKind::LengthValue) =>
                        true,
                        (&ErrorKind::TagClosure, &ErrorKind::TagClosure) =>
                        true,
                        (&ErrorKind::Alpha, &ErrorKind::Alpha) => true,
                        (&ErrorKind::Digit, &ErrorKind::Digit) => true,
                        (&ErrorKind::HexDigit, &ErrorKind::HexDigit) => true,
                        (&ErrorKind::AlphaNumeric, &ErrorKind::AlphaNumeric)
                        => true,
                        (&ErrorKind::Space, &ErrorKind::Space) => true,
                        (&ErrorKind::MultiSpace, &ErrorKind::MultiSpace) =>
                        true,
                        (&ErrorKind::LengthValueFn, &ErrorKind::LengthValueFn)
                        => true,
                        (&ErrorKind::Eof, &ErrorKind::Eof) => true,
                        (&ErrorKind::ExprOpt, &ErrorKind::ExprOpt) => true,
                        (&ErrorKind::ExprRes, &ErrorKind::ExprRes) => true,
                        (&ErrorKind::CondReduce, &ErrorKind::CondReduce) =>
                        true,
                        (&ErrorKind::Switch, &ErrorKind::Switch) => true,
                        (&ErrorKind::TagBits, &ErrorKind::TagBits) => true,
                        (&ErrorKind::OneOf, &ErrorKind::OneOf) => true,
                        (&ErrorKind::NoneOf, &ErrorKind::NoneOf) => true,
                        (&ErrorKind::Char, &ErrorKind::Char) => true,
                        (&ErrorKind::CrLf, &ErrorKind::CrLf) => true,
                        (&ErrorKind::RegexpMatch, &ErrorKind::RegexpMatch) =>
                        true,
                        (&ErrorKind::RegexpMatches, &ErrorKind::RegexpMatches)
                        => true,
                        (&ErrorKind::RegexpFind, &ErrorKind::RegexpFind) =>
                        true,
                        (&ErrorKind::RegexpCapture, &ErrorKind::RegexpCapture)
                        => true,
                        (&ErrorKind::RegexpCaptures,
                         &ErrorKind::RegexpCaptures) => true,
                        (&ErrorKind::TakeWhile1, &ErrorKind::TakeWhile1) =>
                        true,
                        (&ErrorKind::Complete, &ErrorKind::Complete) => true,
                        (&ErrorKind::Fix, &ErrorKind::Fix) => true,
                        (&ErrorKind::Escaped, &ErrorKind::Escaped) => true,
                        (&ErrorKind::EscapedTransform,
                         &ErrorKind::EscapedTransform) => true,
                        (&ErrorKind::TagStr, &ErrorKind::TagStr) => true,
                        (&ErrorKind::IsNotStr, &ErrorKind::IsNotStr) => true,
                        (&ErrorKind::IsAStr, &ErrorKind::IsAStr) => true,
                        (&ErrorKind::TakeWhile1Str, &ErrorKind::TakeWhile1Str)
                        => true,
                        (&ErrorKind::NonEmpty, &ErrorKind::NonEmpty) => true,
                        (&ErrorKind::ManyMN, &ErrorKind::ManyMN) => true,
                        (&ErrorKind::TakeUntilAndConsumeStr,
                         &ErrorKind::TakeUntilAndConsumeStr) => true,
                        (&ErrorKind::TakeUntilStr, &ErrorKind::TakeUntilStr)
                        => true,
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &ErrorKind<E>) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&ErrorKind::Custom(ref __self_0),
                         &ErrorKind::Custom(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        (&ErrorKind::Tag, &ErrorKind::Tag) => false,
                        (&ErrorKind::MapRes, &ErrorKind::MapRes) => false,
                        (&ErrorKind::MapOpt, &ErrorKind::MapOpt) => false,
                        (&ErrorKind::Alt, &ErrorKind::Alt) => false,
                        (&ErrorKind::IsNot, &ErrorKind::IsNot) => false,
                        (&ErrorKind::IsA, &ErrorKind::IsA) => false,
                        (&ErrorKind::SeparatedList, &ErrorKind::SeparatedList)
                        => false,
                        (&ErrorKind::SeparatedNonEmptyList,
                         &ErrorKind::SeparatedNonEmptyList) => false,
                        (&ErrorKind::Many1, &ErrorKind::Many1) => false,
                        (&ErrorKind::Count, &ErrorKind::Count) => false,
                        (&ErrorKind::TakeUntilAndConsume,
                         &ErrorKind::TakeUntilAndConsume) => false,
                        (&ErrorKind::TakeUntil, &ErrorKind::TakeUntil) =>
                        false,
                        (&ErrorKind::TakeUntilEitherAndConsume,
                         &ErrorKind::TakeUntilEitherAndConsume) => false,
                        (&ErrorKind::TakeUntilEither,
                         &ErrorKind::TakeUntilEither) => false,
                        (&ErrorKind::LengthValue, &ErrorKind::LengthValue) =>
                        false,
                        (&ErrorKind::TagClosure, &ErrorKind::TagClosure) =>
                        false,
                        (&ErrorKind::Alpha, &ErrorKind::Alpha) => false,
                        (&ErrorKind::Digit, &ErrorKind::Digit) => false,
                        (&ErrorKind::HexDigit, &ErrorKind::HexDigit) => false,
                        (&ErrorKind::AlphaNumeric, &ErrorKind::AlphaNumeric)
                        => false,
                        (&ErrorKind::Space, &ErrorKind::Space) => false,
                        (&ErrorKind::MultiSpace, &ErrorKind::MultiSpace) =>
                        false,
                        (&ErrorKind::LengthValueFn, &ErrorKind::LengthValueFn)
                        => false,
                        (&ErrorKind::Eof, &ErrorKind::Eof) => false,
                        (&ErrorKind::ExprOpt, &ErrorKind::ExprOpt) => false,
                        (&ErrorKind::ExprRes, &ErrorKind::ExprRes) => false,
                        (&ErrorKind::CondReduce, &ErrorKind::CondReduce) =>
                        false,
                        (&ErrorKind::Switch, &ErrorKind::Switch) => false,
                        (&ErrorKind::TagBits, &ErrorKind::TagBits) => false,
                        (&ErrorKind::OneOf, &ErrorKind::OneOf) => false,
                        (&ErrorKind::NoneOf, &ErrorKind::NoneOf) => false,
                        (&ErrorKind::Char, &ErrorKind::Char) => false,
                        (&ErrorKind::CrLf, &ErrorKind::CrLf) => false,
                        (&ErrorKind::RegexpMatch, &ErrorKind::RegexpMatch) =>
                        false,
                        (&ErrorKind::RegexpMatches, &ErrorKind::RegexpMatches)
                        => false,
                        (&ErrorKind::RegexpFind, &ErrorKind::RegexpFind) =>
                        false,
                        (&ErrorKind::RegexpCapture, &ErrorKind::RegexpCapture)
                        => false,
                        (&ErrorKind::RegexpCaptures,
                         &ErrorKind::RegexpCaptures) => false,
                        (&ErrorKind::TakeWhile1, &ErrorKind::TakeWhile1) =>
                        false,
                        (&ErrorKind::Complete, &ErrorKind::Complete) => false,
                        (&ErrorKind::Fix, &ErrorKind::Fix) => false,
                        (&ErrorKind::Escaped, &ErrorKind::Escaped) => false,
                        (&ErrorKind::EscapedTransform,
                         &ErrorKind::EscapedTransform) => false,
                        (&ErrorKind::TagStr, &ErrorKind::TagStr) => false,
                        (&ErrorKind::IsNotStr, &ErrorKind::IsNotStr) => false,
                        (&ErrorKind::IsAStr, &ErrorKind::IsAStr) => false,
                        (&ErrorKind::TakeWhile1Str, &ErrorKind::TakeWhile1Str)
                        => false,
                        (&ErrorKind::NonEmpty, &ErrorKind::NonEmpty) => false,
                        (&ErrorKind::ManyMN, &ErrorKind::ManyMN) => false,
                        (&ErrorKind::TakeUntilAndConsumeStr,
                         &ErrorKind::TakeUntilAndConsumeStr) => false,
                        (&ErrorKind::TakeUntilStr, &ErrorKind::TakeUntilStr)
                        => false,
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <E: ::std::fmt::Debug> ::std::fmt::Debug for ErrorKind<E> {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ErrorKind::Custom(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Custom");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ErrorKind::Tag,) => {
                    let mut builder = __arg_0.debug_tuple("Tag");
                    builder.finish()
                }
                (&ErrorKind::MapRes,) => {
                    let mut builder = __arg_0.debug_tuple("MapRes");
                    builder.finish()
                }
                (&ErrorKind::MapOpt,) => {
                    let mut builder = __arg_0.debug_tuple("MapOpt");
                    builder.finish()
                }
                (&ErrorKind::Alt,) => {
                    let mut builder = __arg_0.debug_tuple("Alt");
                    builder.finish()
                }
                (&ErrorKind::IsNot,) => {
                    let mut builder = __arg_0.debug_tuple("IsNot");
                    builder.finish()
                }
                (&ErrorKind::IsA,) => {
                    let mut builder = __arg_0.debug_tuple("IsA");
                    builder.finish()
                }
                (&ErrorKind::SeparatedList,) => {
                    let mut builder = __arg_0.debug_tuple("SeparatedList");
                    builder.finish()
                }
                (&ErrorKind::SeparatedNonEmptyList,) => {
                    let mut builder =
                        __arg_0.debug_tuple("SeparatedNonEmptyList");
                    builder.finish()
                }
                (&ErrorKind::Many1,) => {
                    let mut builder = __arg_0.debug_tuple("Many1");
                    builder.finish()
                }
                (&ErrorKind::Count,) => {
                    let mut builder = __arg_0.debug_tuple("Count");
                    builder.finish()
                }
                (&ErrorKind::TakeUntilAndConsume,) => {
                    let mut builder =
                        __arg_0.debug_tuple("TakeUntilAndConsume");
                    builder.finish()
                }
                (&ErrorKind::TakeUntil,) => {
                    let mut builder = __arg_0.debug_tuple("TakeUntil");
                    builder.finish()
                }
                (&ErrorKind::TakeUntilEitherAndConsume,) => {
                    let mut builder =
                        __arg_0.debug_tuple("TakeUntilEitherAndConsume");
                    builder.finish()
                }
                (&ErrorKind::TakeUntilEither,) => {
                    let mut builder = __arg_0.debug_tuple("TakeUntilEither");
                    builder.finish()
                }
                (&ErrorKind::LengthValue,) => {
                    let mut builder = __arg_0.debug_tuple("LengthValue");
                    builder.finish()
                }
                (&ErrorKind::TagClosure,) => {
                    let mut builder = __arg_0.debug_tuple("TagClosure");
                    builder.finish()
                }
                (&ErrorKind::Alpha,) => {
                    let mut builder = __arg_0.debug_tuple("Alpha");
                    builder.finish()
                }
                (&ErrorKind::Digit,) => {
                    let mut builder = __arg_0.debug_tuple("Digit");
                    builder.finish()
                }
                (&ErrorKind::HexDigit,) => {
                    let mut builder = __arg_0.debug_tuple("HexDigit");
                    builder.finish()
                }
                (&ErrorKind::AlphaNumeric,) => {
                    let mut builder = __arg_0.debug_tuple("AlphaNumeric");
                    builder.finish()
                }
                (&ErrorKind::Space,) => {
                    let mut builder = __arg_0.debug_tuple("Space");
                    builder.finish()
                }
                (&ErrorKind::MultiSpace,) => {
                    let mut builder = __arg_0.debug_tuple("MultiSpace");
                    builder.finish()
                }
                (&ErrorKind::LengthValueFn,) => {
                    let mut builder = __arg_0.debug_tuple("LengthValueFn");
                    builder.finish()
                }
                (&ErrorKind::Eof,) => {
                    let mut builder = __arg_0.debug_tuple("Eof");
                    builder.finish()
                }
                (&ErrorKind::ExprOpt,) => {
                    let mut builder = __arg_0.debug_tuple("ExprOpt");
                    builder.finish()
                }
                (&ErrorKind::ExprRes,) => {
                    let mut builder = __arg_0.debug_tuple("ExprRes");
                    builder.finish()
                }
                (&ErrorKind::CondReduce,) => {
                    let mut builder = __arg_0.debug_tuple("CondReduce");
                    builder.finish()
                }
                (&ErrorKind::Switch,) => {
                    let mut builder = __arg_0.debug_tuple("Switch");
                    builder.finish()
                }
                (&ErrorKind::TagBits,) => {
                    let mut builder = __arg_0.debug_tuple("TagBits");
                    builder.finish()
                }
                (&ErrorKind::OneOf,) => {
                    let mut builder = __arg_0.debug_tuple("OneOf");
                    builder.finish()
                }
                (&ErrorKind::NoneOf,) => {
                    let mut builder = __arg_0.debug_tuple("NoneOf");
                    builder.finish()
                }
                (&ErrorKind::Char,) => {
                    let mut builder = __arg_0.debug_tuple("Char");
                    builder.finish()
                }
                (&ErrorKind::CrLf,) => {
                    let mut builder = __arg_0.debug_tuple("CrLf");
                    builder.finish()
                }
                (&ErrorKind::RegexpMatch,) => {
                    let mut builder = __arg_0.debug_tuple("RegexpMatch");
                    builder.finish()
                }
                (&ErrorKind::RegexpMatches,) => {
                    let mut builder = __arg_0.debug_tuple("RegexpMatches");
                    builder.finish()
                }
                (&ErrorKind::RegexpFind,) => {
                    let mut builder = __arg_0.debug_tuple("RegexpFind");
                    builder.finish()
                }
                (&ErrorKind::RegexpCapture,) => {
                    let mut builder = __arg_0.debug_tuple("RegexpCapture");
                    builder.finish()
                }
                (&ErrorKind::RegexpCaptures,) => {
                    let mut builder = __arg_0.debug_tuple("RegexpCaptures");
                    builder.finish()
                }
                (&ErrorKind::TakeWhile1,) => {
                    let mut builder = __arg_0.debug_tuple("TakeWhile1");
                    builder.finish()
                }
                (&ErrorKind::Complete,) => {
                    let mut builder = __arg_0.debug_tuple("Complete");
                    builder.finish()
                }
                (&ErrorKind::Fix,) => {
                    let mut builder = __arg_0.debug_tuple("Fix");
                    builder.finish()
                }
                (&ErrorKind::Escaped,) => {
                    let mut builder = __arg_0.debug_tuple("Escaped");
                    builder.finish()
                }
                (&ErrorKind::EscapedTransform,) => {
                    let mut builder = __arg_0.debug_tuple("EscapedTransform");
                    builder.finish()
                }
                (&ErrorKind::TagStr,) => {
                    let mut builder = __arg_0.debug_tuple("TagStr");
                    builder.finish()
                }
                (&ErrorKind::IsNotStr,) => {
                    let mut builder = __arg_0.debug_tuple("IsNotStr");
                    builder.finish()
                }
                (&ErrorKind::IsAStr,) => {
                    let mut builder = __arg_0.debug_tuple("IsAStr");
                    builder.finish()
                }
                (&ErrorKind::TakeWhile1Str,) => {
                    let mut builder = __arg_0.debug_tuple("TakeWhile1Str");
                    builder.finish()
                }
                (&ErrorKind::NonEmpty,) => {
                    let mut builder = __arg_0.debug_tuple("NonEmpty");
                    builder.finish()
                }
                (&ErrorKind::ManyMN,) => {
                    let mut builder = __arg_0.debug_tuple("ManyMN");
                    builder.finish()
                }
                (&ErrorKind::TakeUntilAndConsumeStr,) => {
                    let mut builder =
                        __arg_0.debug_tuple("TakeUntilAndConsumeStr");
                    builder.finish()
                }
                (&ErrorKind::TakeUntilStr,) => {
                    let mut builder = __arg_0.debug_tuple("TakeUntilStr");
                    builder.finish()
                }
            }
        }
    }
    pub fn error_to_u32<E>(e: &ErrorKind<E>) -> u32 {
        match *e {
            ErrorKind::Custom(_) => 0,
            ErrorKind::Tag => 1,
            ErrorKind::MapRes => 2,
            ErrorKind::MapOpt => 3,
            ErrorKind::Alt => 4,
            ErrorKind::IsNot => 5,
            ErrorKind::IsA => 6,
            ErrorKind::SeparatedList => 7,
            ErrorKind::SeparatedNonEmptyList => 8,
            ErrorKind::Many1 => 9,
            ErrorKind::Count => 10,
            ErrorKind::TakeUntilAndConsume => 11,
            ErrorKind::TakeUntil => 12,
            ErrorKind::TakeUntilEitherAndConsume => 13,
            ErrorKind::TakeUntilEither => 14,
            ErrorKind::LengthValue => 15,
            ErrorKind::TagClosure => 16,
            ErrorKind::Alpha => 17,
            ErrorKind::Digit => 18,
            ErrorKind::AlphaNumeric => 19,
            ErrorKind::Space => 20,
            ErrorKind::MultiSpace => 21,
            ErrorKind::LengthValueFn => 22,
            ErrorKind::Eof => 23,
            ErrorKind::ExprOpt => 24,
            ErrorKind::ExprRes => 25,
            ErrorKind::CondReduce => 26,
            ErrorKind::Switch => 27,
            ErrorKind::TagBits => 28,
            ErrorKind::OneOf => 29,
            ErrorKind::NoneOf => 30,
            ErrorKind::Char => 40,
            ErrorKind::CrLf => 41,
            ErrorKind::RegexpMatch => 42,
            ErrorKind::RegexpMatches => 43,
            ErrorKind::RegexpFind => 44,
            ErrorKind::RegexpCapture => 45,
            ErrorKind::RegexpCaptures => 46,
            ErrorKind::TakeWhile1 => 47,
            ErrorKind::Complete => 48,
            ErrorKind::Fix => 49,
            ErrorKind::Escaped => 50,
            ErrorKind::EscapedTransform => 51,
            ErrorKind::TagStr => 52,
            ErrorKind::IsNotStr => 53,
            ErrorKind::IsAStr => 54,
            ErrorKind::TakeWhile1Str => 55,
            ErrorKind::NonEmpty => 56,
            ErrorKind::ManyMN => 57,
            ErrorKind::TakeUntilAndConsumeStr => 58,
            ErrorKind::HexDigit => 59,
            ErrorKind::TakeUntilStr => 60,
        }
    }
}
mod internal {
    //! Basic types to build the parsers
    #[prelude_import]
    use std::prelude::v1::*;
    use self::IResult::*;
    use util::ErrorKind;
    use std::boxed::Box;
    /// Contains the error that a parser can return
    ///
    /// It can represent a linked list of errors, indicating the path taken in the parsing tree, with corresponding position in the input data.
    /// It depends on P, the input position (for a &[u8] parser, it would be a &[u8]), and E, the custom error type (by default, u32)
    pub enum Err<P, E = u32> {

        /// An error code, represented by an ErrorKind, which can contain a custom error code represented by E
        Code(ErrorKind<E>),

        /// An error code, and the next error
        Node(ErrorKind<E>, Box<Err<P, E>>),

        /// An error code, and the input position
        Position(ErrorKind<E>, P),

        /// An error code, the input position and the next error
        NodePosition(ErrorKind<E>, P, Box<Err<P, E>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <P: ::std::clone::Clone, E: ::std::clone::Clone> ::std::clone::Clone
     for Err<P, E> {
        #[inline]
        fn clone(&self) -> Err<P, E> {
            match (&*self,) {
                (&Err::Code(ref __self_0),) =>
                Err::Code(::std::clone::Clone::clone(&(*__self_0))),
                (&Err::Node(ref __self_0, ref __self_1),) =>
                Err::Node(::std::clone::Clone::clone(&(*__self_0)),
                          ::std::clone::Clone::clone(&(*__self_1))),
                (&Err::Position(ref __self_0, ref __self_1),) =>
                Err::Position(::std::clone::Clone::clone(&(*__self_0)),
                              ::std::clone::Clone::clone(&(*__self_1))),
                (&Err::NodePosition(ref __self_0, ref __self_1,
                                    ref __self_2),) =>
                Err::NodePosition(::std::clone::Clone::clone(&(*__self_0)),
                                  ::std::clone::Clone::clone(&(*__self_1)),
                                  ::std::clone::Clone::clone(&(*__self_2))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <P: ::std::cmp::Eq, E: ::std::cmp::Eq> ::std::cmp::Eq for Err<P, E> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&Err::Code(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
                (&Err::Node(ref __self_0, ref __self_1),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                    (*__self_1).assert_receiver_is_total_eq();
                }
                (&Err::Position(ref __self_0, ref __self_1),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                    (*__self_1).assert_receiver_is_total_eq();
                }
                (&Err::NodePosition(ref __self_0, ref __self_1,
                                    ref __self_2),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                    (*__self_1).assert_receiver_is_total_eq();
                    (*__self_2).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <P: ::std::cmp::PartialEq, E: ::std::cmp::PartialEq>
     ::std::cmp::PartialEq for Err<P, E> {
        #[inline]
        fn eq(&self, __arg_0: &Err<P, E>) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&Err::Code(ref __self_0), &Err::Code(ref __arg_1_0))
                        => true && (*__self_0) == (*__arg_1_0),
                        (&Err::Node(ref __self_0, ref __self_1),
                         &Err::Node(ref __arg_1_0, ref __arg_1_1)) =>
                        true && (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&Err::Position(ref __self_0, ref __self_1),
                         &Err::Position(ref __arg_1_0, ref __arg_1_1)) =>
                        true && (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&Err::NodePosition(ref __self_0, ref __self_1,
                                            ref __self_2),
                         &Err::NodePosition(ref __arg_1_0, ref __arg_1_1,
                                            ref __arg_1_2)) =>
                        true && (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1) &&
                            (*__self_2) == (*__arg_1_2),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &Err<P, E>) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&Err::Code(ref __self_0), &Err::Code(ref __arg_1_0))
                        => false || (*__self_0) != (*__arg_1_0),
                        (&Err::Node(ref __self_0, ref __self_1),
                         &Err::Node(ref __arg_1_0, ref __arg_1_1)) =>
                        false || (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&Err::Position(ref __self_0, ref __self_1),
                         &Err::Position(ref __arg_1_0, ref __arg_1_1)) =>
                        false || (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&Err::NodePosition(ref __self_0, ref __self_1,
                                            ref __self_2),
                         &Err::NodePosition(ref __arg_1_0, ref __arg_1_1,
                                            ref __arg_1_2)) =>
                        false || (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1) ||
                            (*__self_2) != (*__arg_1_2),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <P: ::std::fmt::Debug, E: ::std::fmt::Debug> ::std::fmt::Debug for
     Err<P, E> {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Err::Code(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Code");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Err::Node(ref __self_0, ref __self_1),) => {
                    let mut builder = __arg_0.debug_tuple("Node");
                    let _ = builder.field(&&(*__self_0));
                    let _ = builder.field(&&(*__self_1));
                    builder.finish()
                }
                (&Err::Position(ref __self_0, ref __self_1),) => {
                    let mut builder = __arg_0.debug_tuple("Position");
                    let _ = builder.field(&&(*__self_0));
                    let _ = builder.field(&&(*__self_1));
                    builder.finish()
                }
                (&Err::NodePosition(ref __self_0, ref __self_1,
                                    ref __self_2),) => {
                    let mut builder = __arg_0.debug_tuple("NodePosition");
                    let _ = builder.field(&&(*__self_0));
                    let _ = builder.field(&&(*__self_1));
                    let _ = builder.field(&&(*__self_2));
                    builder.finish()
                }
            }
        }
    }
    /// Contains information on needed data if a parser returned `Incomplete`
    pub enum Needed {

        /// needs more data, but we do not know how much
        Unknown,

        /// contains the required data size
        Size(usize),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Needed { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Needed {
        #[inline]
        fn clone(&self) -> Needed {
            match (&*self,) {
                (&Needed::Unknown,) => Needed::Unknown,
                (&Needed::Size(ref __self_0),) =>
                Needed::Size(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Needed {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&Needed::Unknown,) => { }
                (&Needed::Size(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Needed {
        #[inline]
        fn eq(&self, __arg_0: &Needed) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&Needed::Unknown, &Needed::Unknown) => true,
                        (&Needed::Size(ref __self_0),
                         &Needed::Size(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &Needed) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&Needed::Unknown, &Needed::Unknown) => false,
                        (&Needed::Size(ref __self_0),
                         &Needed::Size(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Needed {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Needed::Unknown,) => {
                    let mut builder = __arg_0.debug_tuple("Unknown");
                    builder.finish()
                }
                (&Needed::Size(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Size");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    /// Holds the result of parsing functions
    ///
    /// It depends on I, the input type, O, the output type, and E, the error type (by default u32)
    ///
    pub enum IResult<I, O, E = u32> {

        /// indicates a correct parsing, the first field containing the rest of the unparsed data, the second field contains the parsed data
        Done(I, O),

        /// contains a Err, an enum that can indicate an error code, a position in the input, and a pointer to another error, making a list of errors in the parsing tree
        Error(Err<I, E>),

        /// Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown
        Incomplete(Needed),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <I: ::std::clone::Clone, O: ::std::clone::Clone,
          E: ::std::clone::Clone> ::std::clone::Clone for IResult<I, O, E> {
        #[inline]
        fn clone(&self) -> IResult<I, O, E> {
            match (&*self,) {
                (&IResult::Done(ref __self_0, ref __self_1),) =>
                IResult::Done(::std::clone::Clone::clone(&(*__self_0)),
                              ::std::clone::Clone::clone(&(*__self_1))),
                (&IResult::Error(ref __self_0),) =>
                IResult::Error(::std::clone::Clone::clone(&(*__self_0))),
                (&IResult::Incomplete(ref __self_0),) =>
                IResult::Incomplete(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <I: ::std::cmp::Eq, O: ::std::cmp::Eq, E: ::std::cmp::Eq>
     ::std::cmp::Eq for IResult<I, O, E> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&IResult::Done(ref __self_0, ref __self_1),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                    (*__self_1).assert_receiver_is_total_eq();
                }
                (&IResult::Error(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
                (&IResult::Incomplete(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <I: ::std::cmp::PartialEq, O: ::std::cmp::PartialEq,
          E: ::std::cmp::PartialEq> ::std::cmp::PartialEq for IResult<I, O, E>
     {
        #[inline]
        fn eq(&self, __arg_0: &IResult<I, O, E>) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&IResult::Done(ref __self_0, ref __self_1),
                         &IResult::Done(ref __arg_1_0, ref __arg_1_1)) =>
                        true && (*__self_0) == (*__arg_1_0) &&
                            (*__self_1) == (*__arg_1_1),
                        (&IResult::Error(ref __self_0),
                         &IResult::Error(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        (&IResult::Incomplete(ref __self_0),
                         &IResult::Incomplete(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &IResult<I, O, E>) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&IResult::Done(ref __self_0, ref __self_1),
                         &IResult::Done(ref __arg_1_0, ref __arg_1_1)) =>
                        false || (*__self_0) != (*__arg_1_0) ||
                            (*__self_1) != (*__arg_1_1),
                        (&IResult::Error(ref __self_0),
                         &IResult::Error(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        (&IResult::Incomplete(ref __self_0),
                         &IResult::Incomplete(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <I: ::std::fmt::Debug, O: ::std::fmt::Debug, E: ::std::fmt::Debug>
     ::std::fmt::Debug for IResult<I, O, E> {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&IResult::Done(ref __self_0, ref __self_1),) => {
                    let mut builder = __arg_0.debug_tuple("Done");
                    let _ = builder.field(&&(*__self_0));
                    let _ = builder.field(&&(*__self_1));
                    builder.finish()
                }
                (&IResult::Error(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Error");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&IResult::Incomplete(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Incomplete");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    impl <I, O, E> IResult<I, O, E> {
        pub fn is_done(&self) -> bool {
            match *self { Done(_, _) => true, _ => false, }
        }
        pub fn is_err(&self) -> bool {
            match *self { Error(_) => true, _ => false, }
        }
        pub fn is_incomplete(&self) -> bool {
            match *self { Incomplete(_) => true, _ => false, }
        }
    }
    pub trait GetInput<I> {
        fn remaining_input(&self)
        -> Option<I>;
    }
    pub trait GetOutput<O> {
        fn output(&self)
        -> Option<O>;
    }
    impl <'a, I, O, E> GetInput<&'a [I]> for IResult<&'a [I], O, E> {
        fn remaining_input(&self) -> Option<&'a [I]> {
            match *self { Done(ref i, _) => Some(*i), _ => None, }
        }
    }
    impl <O, E> GetInput<()> for IResult<(), O, E> {
        fn remaining_input(&self) -> Option<()> {
            match *self { Done((), _) => Some(()), _ => None, }
        }
    }
    impl <'a, O, E> GetInput<&'a str> for IResult<&'a str, O, E> {
        fn remaining_input(&self) -> Option<&'a str> {
            match *self { Done(ref i, _) => Some(*i), _ => None, }
        }
    }
    impl <'a, I, O, E> GetOutput<&'a [O]> for IResult<I, &'a [O], E> {
        fn output(&self) -> Option<&'a [O]> {
            match *self { Done(_, ref o) => Some(*o), _ => None, }
        }
    }
    impl <I, E> GetOutput<()> for IResult<I, (), E> {
        fn output(&self) -> Option<()> {
            match *self { Done(_, ()) => Some(()), _ => None, }
        }
    }
    impl <'a, I, E> GetOutput<&'a str> for IResult<I, &'a str, E> {
        fn output(&self) -> Option<&'a str> {
            match *self { Done(_, ref o) => Some(*o), _ => None, }
        }
    }
}
#[macro_use]
mod macros {
    //! Macro combinators
    //!
    //! Macros are used to make combination easier,
    //! since they often do not depend on the type
    //! of the data they manipulate or return.
    //!
    //! There is a trick to make them easier to assemble,
    //! combinators are defined like this:
    //!
    //! ```ignore
    //! macro_rules! tag (
    //!   ($i:expr, $inp: expr) => (
    //!     {
    //!       ...
    //!     }
    //!   );
    //! );
    //! ```
    //!
    //! But when used in other combinators, are Used
    //! like this:
    //!
    //! ```ignore
    //! named!(my_function, tag!("abcd"));
    //! ```
    //!
    //! Internally, other combinators will rewrite
    //! that call to pass the input as first argument:
    //!
    //! ```ignore
    //! macro_rules! named (
    //!   ($name:ident, $submac:ident!( $($args:tt)* )) => (
    //!     fn $name<'a>( i: &'a [u8] ) -> $crate::IResult<'a,&[u8], &[u8]> {
    //!       $submac!(i, $($args)*)
    //!     }
    //!   );
    //! );
    //! ```
    //!
    //! If you want to call a combinator directly, you can
    //! do it like this:
    //!
    //! ```ignore
    //! let res = { tag!(input, "abcd"); }
    //! ```
    //!
    //! Combinators must have a specific variant for
    //! non-macro arguments. Example: passing a function
    //! to take_while! instead of another combinator.
    //!
    //! ```ignore
    //! macro_rules! take_while(
    //!   ($input:expr, $submac:ident!( $($args:tt)* )) => (
    //!     {
    //!       ...
    //!     }
    //!   );
    //!
    //!   // wrap the function in a macro to pass it to the main implementation
    //!   ($input:expr, $f:expr) => (
    //!     take_while!($input, call!($f));
    //!   );
    //! );
    //!
    #[prelude_import]
    use std::prelude::v1::*;
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use internal::{Needed, IResult, Err};
        use internal::IResult::*;
        use internal::Err::*;
        use util::ErrorKind;
        mod pub_named_mod {
            #[prelude_import]
            use std::prelude::v1::*;
            pub fn tst<'a>(i: &'a [u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "abcd";
                    let bytes = as_bytes(&expected);
                    let res: ::IResult<&[u8], &[u8]> =
                        if bytes.len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size(bytes.len()))
                        } else if &i[0..bytes.len()] == bytes {
                            ::IResult::Done(&i[bytes.len()..],
                                            &i[0..bytes.len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                             i))
                        };
                    res
                }
            }
        }
        #[test]
        pub fn pub_named_test() {
            let a = &b"abcd"[..];
            let res = pub_named_mod::tst(a);
            {
                match (&(res), &(Done(&b""[..], a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2462u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn apply_test() {
            fn sum2(a: u8, b: u8) -> u8 { a + b }
            fn sum3(a: u8, b: u8, c: u8) -> u8 { a + b + c }
            let a = sum2(1, 2);
            let b = sum3(1, 2, 3);
            {
                match (&(a), &(3)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2472u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(b), &(6)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2473u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        struct B {
            a: u8,
            b: u8,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for B {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    B { a: ref __self_0_0, b: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("B");
                        let _ = builder.field("a", &&(*__self_0_0));
                        let _ = builder.field("b", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for B {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                match *self {
                    B { a: ref __self_0_0, b: ref __self_0_1 } => {
                        (*__self_0_0).assert_receiver_is_total_eq();
                        (*__self_0_1).assert_receiver_is_total_eq();
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for B {
            #[inline]
            fn eq(&self, __arg_0: &B) -> bool {
                match *__arg_0 {
                    B { a: ref __self_1_0, b: ref __self_1_1 } =>
                    match *self {
                        B { a: ref __self_0_0, b: ref __self_0_1 } =>
                        true && (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, __arg_0: &B) -> bool {
                match *__arg_0 {
                    B { a: ref __self_1_0, b: ref __self_1_1 } =>
                    match *self {
                        B { a: ref __self_0_0, b: ref __self_0_1 } =>
                        false || (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[test]
        pub fn chain2() {
            fn ret_int1(i: &[u8]) -> IResult<&[u8], u8> { Done(i, 1) }
            fn ret_int2(i: &[u8]) -> IResult<&[u8], u8> { Done(i, 2) }
            fn f(i: &[u8]) -> ::IResult<&[u8], B, u32> {
                {
                    {
                        use InputLength;
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "abcd";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, _) => {
                                {
                                    {
                                        use InputLength;
                                        let res =
                                            {
                                                #[inline(always)]
                                                fn as_bytes<T: ::AsBytes>(b:
                                                                              &T)
                                                 -> &[u8] {
                                                    b.as_bytes()
                                                }
                                                let expected = "abcd";
                                                let bytes =
                                                    as_bytes(&expected);
                                                let res:
                                                        ::IResult<&[u8],
                                                                  &[u8]> =
                                                    if bytes.len() > i.len() {
                                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                    } else if &i[0..bytes.len()]
                                                                  == bytes {
                                                        ::IResult::Done(&i[bytes.len()..],
                                                                        &i[0..bytes.len()])
                                                    } else {
                                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                         i))
                                                    };
                                                res
                                            };
                                        if let ::IResult::Incomplete(inc) =
                                               res {
                                            match inc {
                                                ::Needed::Unknown =>
                                                ::IResult::Incomplete(::Needed::Unknown),
                                                ::Needed::Size(i) =>
                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                         +
                                                                                         ((i).input_len()
                                                                                              -
                                                                                              i.input_len())
                                                                                         +
                                                                                         i)),
                                            }
                                        } else {
                                            let input =
                                                if let ::IResult::Done(i, _) =
                                                       res {
                                                    i
                                                } else { i };
                                            {
                                                use InputLength;
                                                let res = ret_int1(input);
                                                match res {
                                                    ::IResult::Error(e) =>
                                                    ::IResult::Error(e),
                                                    ::IResult::Incomplete(::Needed::Unknown)
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Unknown),
                                                    ::IResult::Incomplete(::Needed::Size(i))
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  i.input_len())
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  input.input_len())
                                                                                             +
                                                                                             i)),
                                                    ::IResult::Done(i, o) => {
                                                        let aa = o;
                                                        {
                                                            use InputLength;
                                                            let res =
                                                                {
                                                                    #[inline(always)]
                                                                    fn as_bytes<T: ::AsBytes>(b:
                                                                                                  &T)
                                                                     ->
                                                                         &[u8] {
                                                                        b.as_bytes()
                                                                    }
                                                                    let expected =
                                                                        "efgh";
                                                                    let bytes =
                                                                        as_bytes(&expected);
                                                                    let res:
                                                                            ::IResult<&[u8],
                                                                                      &[u8]> =
                                                                        if bytes.len()
                                                                               >
                                                                               i.len()
                                                                           {
                                                                            ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                        } else if &i[0..bytes.len()]
                                                                                      ==
                                                                                      bytes
                                                                         {
                                                                            ::IResult::Done(&i[bytes.len()..],
                                                                                            &i[0..bytes.len()])
                                                                        } else {
                                                                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                             i))
                                                                        };
                                                                    res
                                                                };
                                                            match res {
                                                                ::IResult::Error(e)
                                                                =>
                                                                ::IResult::Error(e),
                                                                ::IResult::Incomplete(::Needed::Unknown)
                                                                =>
                                                                ::IResult::Incomplete(::Needed::Unknown),
                                                                ::IResult::Incomplete(::Needed::Size(i))
                                                                =>
                                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              input.input_len())
                                                                                                         +
                                                                                                         ((input).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                                ::IResult::Done(i,
                                                                                _)
                                                                => {
                                                                    {
                                                                        use InputLength;
                                                                        let res =
                                                                            ret_int2(i);
                                                                        match res
                                                                            {
                                                                            ::IResult::Error(e)
                                                                            =>
                                                                            ::IResult::Error(e),
                                                                            ::IResult::Incomplete(::Needed::Unknown)
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Unknown),
                                                                            ::IResult::Incomplete(::Needed::Size(i))
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          input.input_len())
                                                                                                                     +
                                                                                                                     ((input).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     i)),
                                                                            ::IResult::Done(i,
                                                                                            o)
                                                                            =>
                                                                            {
                                                                                let bb =
                                                                                    o;
                                                                                {
                                                                                    let res =
                                                                                        {
                                                                                            #[inline(always)]
                                                                                            fn as_bytes<T: ::AsBytes>(b:
                                                                                                                          &T)
                                                                                             ->
                                                                                                 &[u8] {
                                                                                                b.as_bytes()
                                                                                            }
                                                                                            let expected =
                                                                                                "efgh";
                                                                                            let bytes =
                                                                                                as_bytes(&expected);
                                                                                            let res:
                                                                                                    ::IResult<&[u8],
                                                                                                              &[u8]> =
                                                                                                if bytes.len()
                                                                                                       >
                                                                                                       i.len()
                                                                                                   {
                                                                                                    ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                                                } else if &i[0..bytes.len()]
                                                                                                              ==
                                                                                                              bytes
                                                                                                 {
                                                                                                    ::IResult::Done(&i[bytes.len()..],
                                                                                                                    &i[0..bytes.len()])
                                                                                                } else {
                                                                                                    ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                                     i))
                                                                                                };
                                                                                            res
                                                                                        };
                                                                                    match res
                                                                                        {
                                                                                        ::IResult::Error(e)
                                                                                        =>
                                                                                        ::IResult::Error(e),
                                                                                        ::IResult::Incomplete(::Needed::Unknown)
                                                                                        =>
                                                                                        ::IResult::Incomplete(::Needed::Unknown),
                                                                                        ::IResult::Incomplete(::Needed::Size(i))
                                                                                        =>
                                                                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                                                 +
                                                                                                                                 ((i).input_len()
                                                                                                                                      -
                                                                                                                                      i.input_len())
                                                                                                                                 +
                                                                                                                                 ((i).input_len()
                                                                                                                                      -
                                                                                                                                      input.input_len())
                                                                                                                                 +
                                                                                                                                 ((input).input_len()
                                                                                                                                      -
                                                                                                                                      i.input_len())
                                                                                                                                 +
                                                                                                                                 ((i).input_len()
                                                                                                                                      -
                                                                                                                                      i.input_len())
                                                                                                                                 +
                                                                                                                                 ((i).input_len()
                                                                                                                                      -
                                                                                                                                      i.input_len())
                                                                                                                                 +
                                                                                                                                 i)),
                                                                                        ::IResult::Done(i,
                                                                                                        _)
                                                                                        =>
                                                                                        {
                                                                                            ::IResult::Done(i,
                                                                                                            (||
                                                                                                                 {
                                                                                                                B{a:
                                                                                                                      aa,
                                                                                                                  b:
                                                                                                                      bb,}
                                                                                                            })())
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let r = f(&b"abcdabcdefghefghX"[..]);
            {
                match (&(r), &(Done(&b"X"[..], B{a: 1, b: 2,}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2499u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r2 = f(&b"abcdefghefghX"[..]);
            {
                match (&(r2), &(Done(&b"X"[..], B{a: 1, b: 2,}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2502u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn nested_chain() {
            fn ret_int1(i: &[u8]) -> IResult<&[u8], u8> { Done(i, 1) }
            fn ret_int2(i: &[u8]) -> IResult<&[u8], u8> { Done(i, 2) }
            fn f(i: &[u8]) -> ::IResult<&[u8], B, u32> {
                {
                    {
                        use InputLength;
                        let res =
                            {
                                {
                                    use InputLength;
                                    let res =
                                        {
                                            #[inline(always)]
                                            fn as_bytes<T: ::AsBytes>(b: &T)
                                             -> &[u8] {
                                                b.as_bytes()
                                            }
                                            let expected = "abcd";
                                            let bytes = as_bytes(&expected);
                                            let res: ::IResult<&[u8], &[u8]> =
                                                if bytes.len() > i.len() {
                                                    ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                } else if &i[0..bytes.len()]
                                                              == bytes {
                                                    ::IResult::Done(&i[bytes.len()..],
                                                                    &i[0..bytes.len()])
                                                } else {
                                                    ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                     i))
                                                };
                                            res
                                        };
                                    match res {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, _) => {
                                            {
                                                let res =
                                                    {
                                                        #[inline(always)]
                                                        fn as_bytes<T: ::AsBytes>(b:
                                                                                      &T)
                                                         -> &[u8] {
                                                            b.as_bytes()
                                                        }
                                                        let expected = "abcd";
                                                        let bytes =
                                                            as_bytes(&expected);
                                                        let res:
                                                                ::IResult<&[u8],
                                                                          &[u8]> =
                                                            if bytes.len() >
                                                                   i.len() {
                                                                ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                            } else if &i[0..bytes.len()]
                                                                          ==
                                                                          bytes
                                                             {
                                                                ::IResult::Done(&i[bytes.len()..],
                                                                                &i[0..bytes.len()])
                                                            } else {
                                                                ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                 i))
                                                            };
                                                        res
                                                    };
                                                if let ::IResult::Incomplete(inc)
                                                       = res {
                                                    match inc {
                                                        ::Needed::Unknown =>
                                                        ::IResult::Incomplete(::Needed::Unknown),
                                                        ::Needed::Size(i) =>
                                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                 +
                                                                                                 ((i).input_len()
                                                                                                      -
                                                                                                      i.input_len())
                                                                                                 +
                                                                                                 i)),
                                                    }
                                                } else {
                                                    let input =
                                                        if let ::IResult::Done(i,
                                                                               _)
                                                               = res {
                                                            i
                                                        } else { i };
                                                    ::IResult::Done(input,
                                                                    (|| {
                                                                    })())
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, _) => {
                                {
                                    use InputLength;
                                    let res = ret_int1(i);
                                    match res {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 ((i).input_len()
                                                                                      -
                                                                                      i.input_len())
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, o) => {
                                            let aa = o;
                                            {
                                                use InputLength;
                                                let res =
                                                    {
                                                        #[inline(always)]
                                                        fn as_bytes<T: ::AsBytes>(b:
                                                                                      &T)
                                                         -> &[u8] {
                                                            b.as_bytes()
                                                        }
                                                        let expected = "efgh";
                                                        let bytes =
                                                            as_bytes(&expected);
                                                        let res:
                                                                ::IResult<&[u8],
                                                                          &[u8]> =
                                                            if bytes.len() >
                                                                   i.len() {
                                                                ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                            } else if &i[0..bytes.len()]
                                                                          ==
                                                                          bytes
                                                             {
                                                                ::IResult::Done(&i[bytes.len()..],
                                                                                &i[0..bytes.len()])
                                                            } else {
                                                                ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                 i))
                                                            };
                                                        res
                                                    };
                                                match res {
                                                    ::IResult::Error(e) =>
                                                    ::IResult::Error(e),
                                                    ::IResult::Incomplete(::Needed::Unknown)
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Unknown),
                                                    ::IResult::Incomplete(::Needed::Size(i))
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  i.input_len())
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  i.input_len())
                                                                                             +
                                                                                             i)),
                                                    ::IResult::Done(i, _) => {
                                                        {
                                                            use InputLength;
                                                            let res =
                                                                ret_int2(i);
                                                            match res {
                                                                ::IResult::Error(e)
                                                                =>
                                                                ::IResult::Error(e),
                                                                ::IResult::Incomplete(::Needed::Unknown)
                                                                =>
                                                                ::IResult::Incomplete(::Needed::Unknown),
                                                                ::IResult::Incomplete(::Needed::Size(i))
                                                                =>
                                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                                ::IResult::Done(i,
                                                                                o)
                                                                => {
                                                                    let bb =
                                                                        o;
                                                                    {
                                                                        let res =
                                                                            {
                                                                                #[inline(always)]
                                                                                fn as_bytes<T: ::AsBytes>(b:
                                                                                                              &T)
                                                                                 ->
                                                                                     &[u8] {
                                                                                    b.as_bytes()
                                                                                }
                                                                                let expected =
                                                                                    "efgh";
                                                                                let bytes =
                                                                                    as_bytes(&expected);
                                                                                let res:
                                                                                        ::IResult<&[u8],
                                                                                                  &[u8]> =
                                                                                    if bytes.len()
                                                                                           >
                                                                                           i.len()
                                                                                       {
                                                                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                                    } else if &i[0..bytes.len()]
                                                                                                  ==
                                                                                                  bytes
                                                                                     {
                                                                                        ::IResult::Done(&i[bytes.len()..],
                                                                                                        &i[0..bytes.len()])
                                                                                    } else {
                                                                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                         i))
                                                                                    };
                                                                                res
                                                                            };
                                                                        match res
                                                                            {
                                                                            ::IResult::Error(e)
                                                                            =>
                                                                            ::IResult::Error(e),
                                                                            ::IResult::Incomplete(::Needed::Unknown)
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Unknown),
                                                                            ::IResult::Incomplete(::Needed::Size(i))
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     i)),
                                                                            ::IResult::Done(i,
                                                                                            _)
                                                                            =>
                                                                            {
                                                                                ::IResult::Done(i,
                                                                                                (||
                                                                                                     {
                                                                                                    B{a:
                                                                                                          aa,
                                                                                                      b:
                                                                                                          bb,}
                                                                                                })())
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let r = f(&b"abcdabcdefghefghX"[..]);
            {
                match (&(r), &(Done(&b"X"[..], B{a: 1, b: 2,}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2525u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r2 = f(&b"abcdefghefghX"[..]);
            {
                match (&(r2), &(Done(&b"X"[..], B{a: 1, b: 2,}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2528u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        struct C {
            a: u8,
            b: Option<u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for C {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    C { a: ref __self_0_0, b: ref __self_0_1 } => {
                        let mut builder = __arg_0.debug_struct("C");
                        let _ = builder.field("a", &&(*__self_0_0));
                        let _ = builder.field("b", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for C {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                match *self {
                    C { a: ref __self_0_0, b: ref __self_0_1 } => {
                        (*__self_0_0).assert_receiver_is_total_eq();
                        (*__self_0_1).assert_receiver_is_total_eq();
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for C {
            #[inline]
            fn eq(&self, __arg_0: &C) -> bool {
                match *__arg_0 {
                    C { a: ref __self_1_0, b: ref __self_1_1 } =>
                    match *self {
                        C { a: ref __self_0_0, b: ref __self_0_1 } =>
                        true && (*__self_0_0) == (*__self_1_0) &&
                            (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, __arg_0: &C) -> bool {
                match *__arg_0 {
                    C { a: ref __self_1_0, b: ref __self_1_1 } =>
                    match *self {
                        C { a: ref __self_0_0, b: ref __self_0_1 } =>
                        false || (*__self_0_0) != (*__self_1_0) ||
                            (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[test]
        pub fn chain_mut() {
            fn ret_b1_2(i: &[u8]) -> IResult<&[u8], B> {
                Done(i, B{a: 1, b: 2,})
            }
            fn f(i: &[u8]) -> ::IResult<&[u8], B, u32> {
                {
                    {
                        use InputLength;
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "abcd";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, _) => {
                                {
                                    {
                                        use InputLength;
                                        let res =
                                            {
                                                #[inline(always)]
                                                fn as_bytes<T: ::AsBytes>(b:
                                                                              &T)
                                                 -> &[u8] {
                                                    b.as_bytes()
                                                }
                                                let expected = "abcd";
                                                let bytes =
                                                    as_bytes(&expected);
                                                let res:
                                                        ::IResult<&[u8],
                                                                  &[u8]> =
                                                    if bytes.len() > i.len() {
                                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                    } else if &i[0..bytes.len()]
                                                                  == bytes {
                                                        ::IResult::Done(&i[bytes.len()..],
                                                                        &i[0..bytes.len()])
                                                    } else {
                                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                         i))
                                                    };
                                                res
                                            };
                                        if let ::IResult::Incomplete(inc) =
                                               res {
                                            match inc {
                                                ::Needed::Unknown =>
                                                ::IResult::Incomplete(::Needed::Unknown),
                                                ::Needed::Size(i) =>
                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                         +
                                                                                         ((i).input_len()
                                                                                              -
                                                                                              i.input_len())
                                                                                         +
                                                                                         i)),
                                            }
                                        } else {
                                            let input =
                                                if let ::IResult::Done(i, _) =
                                                       res {
                                                    i
                                                } else { i };
                                            {
                                                use InputLength;
                                                let res =
                                                    {
                                                        #[inline(always)]
                                                        fn as_bytes<T: ::AsBytes>(b:
                                                                                      &T)
                                                         -> &[u8] {
                                                            b.as_bytes()
                                                        }
                                                        let expected = "efgh";
                                                        let bytes =
                                                            as_bytes(&expected);
                                                        let res:
                                                                ::IResult<&[u8],
                                                                          &[u8]> =
                                                            if bytes.len() >
                                                                   input.len()
                                                               {
                                                                ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                            } else if &input[0..bytes.len()]
                                                                          ==
                                                                          bytes
                                                             {
                                                                ::IResult::Done(&input[bytes.len()..],
                                                                                &input[0..bytes.len()])
                                                            } else {
                                                                ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                 input))
                                                            };
                                                        res
                                                    };
                                                match res {
                                                    ::IResult::Error(e) =>
                                                    ::IResult::Error(e),
                                                    ::IResult::Incomplete(::Needed::Unknown)
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Unknown),
                                                    ::IResult::Incomplete(::Needed::Size(i))
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  i.input_len())
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  input.input_len())
                                                                                             +
                                                                                             i)),
                                                    ::IResult::Done(i, _) => {
                                                        {
                                                            use InputLength;
                                                            let res =
                                                                ret_b1_2(i);
                                                            match res {
                                                                ::IResult::Error(e)
                                                                =>
                                                                ::IResult::Error(e),
                                                                ::IResult::Incomplete(::Needed::Unknown)
                                                                =>
                                                                ::IResult::Incomplete(::Needed::Unknown),
                                                                ::IResult::Incomplete(::Needed::Size(i))
                                                                =>
                                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         ((i).input_len()
                                                                                                              -
                                                                                                              input.input_len())
                                                                                                         +
                                                                                                         ((input).input_len()
                                                                                                              -
                                                                                                              i.input_len())
                                                                                                         +
                                                                                                         i)),
                                                                ::IResult::Done(i,
                                                                                o)
                                                                => {
                                                                    let mut bb =
                                                                        o;
                                                                    {
                                                                        let res =
                                                                            {
                                                                                #[inline(always)]
                                                                                fn as_bytes<T: ::AsBytes>(b:
                                                                                                              &T)
                                                                                 ->
                                                                                     &[u8] {
                                                                                    b.as_bytes()
                                                                                }
                                                                                let expected =
                                                                                    "efgh";
                                                                                let bytes =
                                                                                    as_bytes(&expected);
                                                                                let res:
                                                                                        ::IResult<&[u8],
                                                                                                  &[u8]> =
                                                                                    if bytes.len()
                                                                                           >
                                                                                           i.len()
                                                                                       {
                                                                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                                    } else if &i[0..bytes.len()]
                                                                                                  ==
                                                                                                  bytes
                                                                                     {
                                                                                        ::IResult::Done(&i[bytes.len()..],
                                                                                                        &i[0..bytes.len()])
                                                                                    } else {
                                                                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                         i))
                                                                                    };
                                                                                res
                                                                            };
                                                                        match res
                                                                            {
                                                                            ::IResult::Error(e)
                                                                            =>
                                                                            ::IResult::Error(e),
                                                                            ::IResult::Incomplete(::Needed::Unknown)
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Unknown),
                                                                            ::IResult::Incomplete(::Needed::Size(i))
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     ((i).input_len()
                                                                                                                          -
                                                                                                                          input.input_len())
                                                                                                                     +
                                                                                                                     ((input).input_len()
                                                                                                                          -
                                                                                                                          i.input_len())
                                                                                                                     +
                                                                                                                     (i).input_len()
                                                                                                                     -
                                                                                                                     i.input_len()
                                                                                                                     +
                                                                                                                     i)),
                                                                            ::IResult::Done(i,
                                                                                            _)
                                                                            =>
                                                                            {
                                                                                ::IResult::Done(i,
                                                                                                (||
                                                                                                     {
                                                                                                    bb.b
                                                                                                        =
                                                                                                        3;
                                                                                                    bb
                                                                                                })())
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let r = f(&b"abcdabcdefghefghX"[..]);
            {
                match (&(r), &(Done(&b"X"[..], B{a: 1, b: 3,}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2555u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn chain_opt() {
            fn y(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "efgh";
                    let bytes = as_bytes(&expected);
                    let res: ::IResult<&[u8], &[u8]> =
                        if bytes.len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size(bytes.len()))
                        } else if &i[0..bytes.len()] == bytes {
                            ::IResult::Done(&i[bytes.len()..],
                                            &i[0..bytes.len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                             i))
                        };
                    res
                }
            }
            fn ret_int1(i: &[u8]) -> IResult<&[u8], u8> { Done(i, 1) }
            fn ret_y(i: &[u8]) -> ::IResult<&[u8], u8, u32> {
                {
                    match y(i) {
                        ::IResult::Error(e) => ::IResult::Error(e),
                        ::IResult::Incomplete(::Needed::Unknown) =>
                        ::IResult::Incomplete(::Needed::Unknown),
                        ::IResult::Incomplete(::Needed::Size(i)) =>
                        ::IResult::Incomplete(::Needed::Size(i)),
                        ::IResult::Done(i, o) =>
                        ::IResult::Done(i, (|_| 2)(o)),
                    }
                }
            }
            fn f(i: &[u8]) -> ::IResult<&[u8], C, u32> {
                {
                    {
                        use InputLength;
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "abcd";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, _) => {
                                {
                                    use InputLength;
                                    let res = ret_int1(i);
                                    match res {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 ((i).input_len()
                                                                                      -
                                                                                      i.input_len())
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, o) => {
                                            let aa = o;
                                            {
                                                let res = ret_y(i);
                                                if let ::IResult::Incomplete(inc)
                                                       = res {
                                                    match inc {
                                                        ::Needed::Unknown =>
                                                        ::IResult::Incomplete(::Needed::Unknown),
                                                        ::Needed::Size(i) =>
                                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                 +
                                                                                                 ((i).input_len()
                                                                                                      -
                                                                                                      i.input_len())
                                                                                                 +
                                                                                                 ((i).input_len()
                                                                                                      -
                                                                                                      i.input_len())
                                                                                                 +
                                                                                                 i)),
                                                    }
                                                } else {
                                                    let (bb, input) =
                                                        if let ::IResult::Done(i,
                                                                               o)
                                                               = res {
                                                            (::std::option::Option::Some(o),
                                                             i)
                                                        } else {
                                                            (::std::option::Option::None,
                                                             i)
                                                        };
                                                    ::IResult::Done(input,
                                                                    (|| {
                                                                        C{a:
                                                                              aa,
                                                                          b:
                                                                              bb,}
                                                                    })())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let r = f(&b"abcdefghX"[..]);
            {
                match (&(r), &(Done(&b"X"[..], C{a: 1, b: Some(2),}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2574u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r2 = f(&b"abcdWXYZ"[..]);
            {
                match (&(r2), &(Done(&b"WXYZ"[..], C{a: 1, b: None,}))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2577u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r3 = f(&b"abcdX"[..]);
            {
                match (&(r3), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2580u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        use util::{error_to_list, add_error_pattern, print_error};
        fn error_to_string<P>(e: &Err<P>) -> &'static str {
            let v: Vec<ErrorKind> = error_to_list(e);
            if &v[..] == [ErrorKind::Custom(42), ErrorKind::Tag] {
                "missing `ijkl` tag"
            } else if &v[..] ==
                          [ErrorKind::Custom(42), ErrorKind::Custom(128),
                           ErrorKind::Tag] {
                "missing `mnop` tag after `ijkl`"
            } else { "unrecognized error" }
        }
        use std::collections;
        #[test]
        pub fn err() {
            fn err_test(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    {
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "abcd";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Done(_, _) => res,
                            ::IResult::Incomplete(_) => res,
                            _ => {
                                match {
                                          match {
                                                    #[inline(always)]
                                                    fn as_bytes<T: ::AsBytes>(b:
                                                                                  &T)
                                                     -> &[u8] {
                                                        b.as_bytes()
                                                    }
                                                    let expected = "efgh";
                                                    let bytes =
                                                        as_bytes(&expected);
                                                    let res:
                                                            ::IResult<&[u8],
                                                                      &[u8]> =
                                                        if bytes.len() >
                                                               i.len() {
                                                            ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                        } else if &i[0..bytes.len()]
                                                                      == bytes
                                                         {
                                                            ::IResult::Done(&i[bytes.len()..],
                                                                            &i[0..bytes.len()])
                                                        } else {
                                                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                             i))
                                                        };
                                                    res
                                                } {
                                              ::IResult::Error(a) =>
                                              ::IResult::Error(a),
                                              ::IResult::Incomplete(i) =>
                                              ::IResult::Incomplete(i),
                                              ::IResult::Done(i1, _) => {
                                                  match {
                                                            let cl = || {
                                                                {
                                                                    {
                                                                        use InputLength;
                                                                        let res =
                                                                            {
                                                                                #[inline(always)]
                                                                                fn as_bytes<T: ::AsBytes>(b:
                                                                                                              &T)
                                                                                 ->
                                                                                     &[u8] {
                                                                                    b.as_bytes()
                                                                                }
                                                                                let expected =
                                                                                    "ijkl";
                                                                                let bytes =
                                                                                    as_bytes(&expected);
                                                                                let res:
                                                                                        ::IResult<&[u8],
                                                                                                  &[u8]> =
                                                                                    if bytes.len()
                                                                                           >
                                                                                           i1.len()
                                                                                       {
                                                                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                                    } else if &i1[0..bytes.len()]
                                                                                                  ==
                                                                                                  bytes
                                                                                     {
                                                                                        ::IResult::Done(&i1[bytes.len()..],
                                                                                                        &i1[0..bytes.len()])
                                                                                    } else {
                                                                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                         i1))
                                                                                    };
                                                                                res
                                                                            };
                                                                        match res
                                                                            {
                                                                            ::IResult::Error(e)
                                                                            =>
                                                                            ::IResult::Error(e),
                                                                            ::IResult::Incomplete(::Needed::Unknown)
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Unknown),
                                                                            ::IResult::Incomplete(::Needed::Size(i))
                                                                            =>
                                                                            ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                                     +
                                                                                                                     i)),
                                                                            ::IResult::Done(i,
                                                                                            _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let res =
                                                                                        {
                                                                                            let cl =
                                                                                                ||
                                                                                                    {
                                                                                                {
                                                                                                    #[inline(always)]
                                                                                                    fn as_bytes<T: ::AsBytes>(b:
                                                                                                                                  &T)
                                                                                                     ->
                                                                                                         &[u8] {
                                                                                                        b.as_bytes()
                                                                                                    }
                                                                                                    let expected =
                                                                                                        "mnop";
                                                                                                    let bytes =
                                                                                                        as_bytes(&expected);
                                                                                                    let res:
                                                                                                            ::IResult<&[u8],
                                                                                                                      &[u8]> =
                                                                                                        if bytes.len()
                                                                                                               >
                                                                                                               i.len()
                                                                                                           {
                                                                                                            ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                                                        } else if &i[0..bytes.len()]
                                                                                                                      ==
                                                                                                                      bytes
                                                                                                         {
                                                                                                            ::IResult::Done(&i[bytes.len()..],
                                                                                                                            &i[0..bytes.len()])
                                                                                                        } else {
                                                                                                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                                             i))
                                                                                                        };
                                                                                                    res
                                                                                                }
                                                                                            };
                                                                                            match cl()
                                                                                                {
                                                                                                ::IResult::Incomplete(x)
                                                                                                =>
                                                                                                ::IResult::Incomplete(x),
                                                                                                ::IResult::Done(i,
                                                                                                                o)
                                                                                                =>
                                                                                                ::IResult::Done(i,
                                                                                                                o),
                                                                                                ::IResult::Error(e)
                                                                                                =>
                                                                                                {
                                                                                                    return ::IResult::Error(::Err::NodePosition(ErrorKind::Custom(128),
                                                                                                                                                i,
                                                                                                                                                Box::new(e)))
                                                                                                }
                                                                                            }
                                                                                        };
                                                                                    match res
                                                                                        {
                                                                                        ::IResult::Error(e)
                                                                                        =>
                                                                                        ::IResult::Error(e),
                                                                                        ::IResult::Incomplete(::Needed::Unknown)
                                                                                        =>
                                                                                        ::IResult::Incomplete(::Needed::Unknown),
                                                                                        ::IResult::Incomplete(::Needed::Size(i))
                                                                                        =>
                                                                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                                                 +
                                                                                                                                 ((i1).input_len()
                                                                                                                                      -
                                                                                                                                      i.input_len())
                                                                                                                                 +
                                                                                                                                 i)),
                                                                                        ::IResult::Done(i,
                                                                                                        o)
                                                                                        =>
                                                                                        {
                                                                                            let res =
                                                                                                o;
                                                                                            ::IResult::Done(i,
                                                                                                            (||
                                                                                                                 {
                                                                                                                res
                                                                                                            })())
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                } };
                                                            match cl() {
                                                                ::IResult::Incomplete(x)
                                                                =>
                                                                ::IResult::Incomplete(x),
                                                                ::IResult::Done(i,
                                                                                o)
                                                                =>
                                                                ::IResult::Done(i,
                                                                                o),
                                                                ::IResult::Error(e)
                                                                => {
                                                                    return ::IResult::Error(::Err::NodePosition(ErrorKind::Custom(42),
                                                                                                                i1,
                                                                                                                Box::new(e)))
                                                                }
                                                            }
                                                        } {
                                                      ::IResult::Error(a) =>
                                                      ::IResult::Error(a),
                                                      ::IResult::Incomplete(i)
                                                      =>
                                                      ::IResult::Incomplete(i),
                                                      ::IResult::Done(i2, o2)
                                                      => {
                                                          ::IResult::Done(i2,
                                                                          o2)
                                                      }
                                                  }
                                              }
                                          }
                                      } {
                                    ::IResult::Done(i, o) =>
                                    ::IResult::Done(i, o),
                                    ::IResult::Incomplete(x) =>
                                    ::IResult::Incomplete(x),
                                    ::IResult::Error(_) => {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                         i))
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"efghblah"[..];
            let b = &b"efghijklblah"[..];
            let c = &b"efghijklmnop"[..];
            let blah = &b"blah"[..];
            let res_a = err_test(a);
            let res_b = err_test(b);
            let res_c = err_test(c);
            {
                match (&(res_a),
                       &(Error(NodePosition(ErrorKind::Custom(42), blah,
                                            Box::new(Position(ErrorKind::Tag,
                                                              blah)))))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2640u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(res_b),
                       &(Error(NodePosition(ErrorKind::Custom(42),
                                            &b"ijklblah"[..],
                                            Box::new(NodePosition(ErrorKind::Custom(128),
                                                                  blah,
                                                                  Box::new(Position(ErrorKind::Tag,
                                                                                    blah))))))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2641u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(res_c), &(Done(&b""[..], &b"mnop"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2642u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let mut err_map = collections::HashMap::new();
            if !add_error_pattern(&mut err_map, err_test(&b"efghpouet"[..]),
                                  "missing `ijkl` tag") {
                {
                    ::std::rt::begin_unwind("assertion failed: add_error_pattern(&mut err_map, err_test(&b\"efghpouet\"[..]),\n                  \"missing `ijkl` tag\")",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/macros.rs",
                                                     2646u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !add_error_pattern(&mut err_map,
                                  err_test(&b"efghijklpouet"[..]),
                                  "missing `mnop` tag after `ijkl`") {
                {
                    ::std::rt::begin_unwind("assertion failed: add_error_pattern(&mut err_map, err_test(&b\"efghijklpouet\"[..]),\n                  \"missing `mnop` tag after `ijkl`\")",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/macros.rs",
                                                     2647u32);
                                                &_FILE_LINE
                                            })
                }
            };
            let res_a2 = res_a.clone();
            match res_a {
                Error(e) => {
                    {
                        match (&(error_to_list(&e)),
                               &([ErrorKind::Custom(42), ErrorKind::Tag])) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/macros.rs",
                                                                             2652u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                    {
                        match (&(error_to_string(&e)),
                               &("missing `ijkl` tag")) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/macros.rs",
                                                                             2653u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                    {
                        match (&(err_map.get(&error_to_list(&e))),
                               &(Some(&"missing `ijkl` tag"))) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/macros.rs",
                                                                             2654u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("explicit panic",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/macros.rs",
                                                         2656u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            };
            let res_b2 = res_b.clone();
            match res_b {
                Error(e) => {
                    {
                        match (&(error_to_list(&e)),
                               &([ErrorKind::Custom(42),
                                  ErrorKind::Custom(128), ErrorKind::Tag])) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/macros.rs",
                                                                             2662u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                    {
                        match (&(error_to_string(&e)),
                               &("missing `mnop` tag after `ijkl`")) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/macros.rs",
                                                                             2663u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                    {
                        match (&(err_map.get(&error_to_list(&e))),
                               &(Some(&"missing `mnop` tag after `ijkl`"))) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/macros.rs",
                                                                             2664u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("explicit panic",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/macros.rs",
                                                         2666u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            };
            print_error(a, res_a2);
            print_error(b, res_b2);
        }
        #[test]
        pub fn add_err() {
            fn err_test(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "efgh";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, _) => {
                            match {
                                      match {
                                                {
                                                    use InputLength;
                                                    let res =
                                                        {
                                                            #[inline(always)]
                                                            fn as_bytes<T: ::AsBytes>(b:
                                                                                          &T)
                                                             -> &[u8] {
                                                                b.as_bytes()
                                                            }
                                                            let expected =
                                                                "ijkl";
                                                            let bytes =
                                                                as_bytes(&expected);
                                                            let res:
                                                                    ::IResult<&[u8],
                                                                              &[u8]> =
                                                                if bytes.len()
                                                                       >
                                                                       i1.len()
                                                                   {
                                                                    ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                } else if &i1[0..bytes.len()]
                                                                              ==
                                                                              bytes
                                                                 {
                                                                    ::IResult::Done(&i1[bytes.len()..],
                                                                                    &i1[0..bytes.len()])
                                                                } else {
                                                                    ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                     i1))
                                                                };
                                                            res
                                                        };
                                                    match res {
                                                        ::IResult::Error(e) =>
                                                        ::IResult::Error(e),
                                                        ::IResult::Incomplete(::Needed::Unknown)
                                                        =>
                                                        ::IResult::Incomplete(::Needed::Unknown),
                                                        ::IResult::Incomplete(::Needed::Size(i))
                                                        =>
                                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                 +
                                                                                                 i)),
                                                        ::IResult::Done(i, _)
                                                        => {
                                                            {
                                                                let res =
                                                                    {
                                                                        match {
                                                                                  #[inline(always)]
                                                                                  fn as_bytes<T: ::AsBytes>(b:
                                                                                                                &T)
                                                                                   ->
                                                                                       &[u8] {
                                                                                      b.as_bytes()
                                                                                  }
                                                                                  let expected =
                                                                                      "mnop";
                                                                                  let bytes =
                                                                                      as_bytes(&expected);
                                                                                  let res:
                                                                                          ::IResult<&[u8],
                                                                                                    &[u8]> =
                                                                                      if bytes.len()
                                                                                             >
                                                                                             i.len()
                                                                                         {
                                                                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                                                      } else if &i[0..bytes.len()]
                                                                                                    ==
                                                                                                    bytes
                                                                                       {
                                                                                          ::IResult::Done(&i[bytes.len()..],
                                                                                                          &i[0..bytes.len()])
                                                                                      } else {
                                                                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                           i))
                                                                                      };
                                                                                  res
                                                                              }
                                                                            {
                                                                            ::IResult::Incomplete(x)
                                                                            =>
                                                                            ::IResult::Incomplete(x),
                                                                            ::IResult::Done(i,
                                                                                            o)
                                                                            =>
                                                                            ::IResult::Done(i,
                                                                                            o),
                                                                            ::IResult::Error(e)
                                                                            =>
                                                                            {
                                                                                ::IResult::Error(::Err::NodePosition(ErrorKind::Custom(128),
                                                                                                                     i,
                                                                                                                     Box::new(e)))
                                                                            }
                                                                        }
                                                                    };
                                                                match res {
                                                                    ::IResult::Error(e)
                                                                    =>
                                                                    ::IResult::Error(e),
                                                                    ::IResult::Incomplete(::Needed::Unknown)
                                                                    =>
                                                                    ::IResult::Incomplete(::Needed::Unknown),
                                                                    ::IResult::Incomplete(::Needed::Size(i))
                                                                    =>
                                                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                                                             +
                                                                                                             ((i1).input_len()
                                                                                                                  -
                                                                                                                  i.input_len())
                                                                                                             +
                                                                                                             i)),
                                                                    ::IResult::Done(i,
                                                                                    o)
                                                                    => {
                                                                        let res =
                                                                            o;
                                                                        ::IResult::Done(i,
                                                                                        (||
                                                                                             {
                                                                                            res
                                                                                        })())
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } {
                                          ::IResult::Incomplete(x) =>
                                          ::IResult::Incomplete(x),
                                          ::IResult::Done(i, o) =>
                                          ::IResult::Done(i, o),
                                          ::IResult::Error(e) => {
                                              ::IResult::Error(::Err::NodePosition(ErrorKind::Custom(42),
                                                                                   i1,
                                                                                   Box::new(e)))
                                          }
                                      }
                                  } {
                                ::IResult::Error(a) => ::IResult::Error(a),
                                ::IResult::Incomplete(i) =>
                                ::IResult::Incomplete(i),
                                ::IResult::Done(i2, o2) => {
                                    ::IResult::Done(i2, o2)
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"efghblah"[..];
            let b = &b"efghijklblah"[..];
            let c = &b"efghijklmnop"[..];
            let blah = &b"blah"[..];
            let res_a = err_test(a);
            let res_b = err_test(b);
            let res_c = err_test(c);
            {
                match (&(res_a),
                       &(Error(NodePosition(ErrorKind::Custom(42), blah,
                                            Box::new(Position(ErrorKind::Tag,
                                                              blah)))))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2693u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(res_b),
                       &(Error(NodePosition(ErrorKind::Custom(42),
                                            &b"ijklblah"[..],
                                            Box::new(NodePosition(ErrorKind::Custom(128),
                                                                  blah,
                                                                  Box::new(Position(ErrorKind::Tag,
                                                                                    blah))))))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2694u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(res_c), &(Done(&b""[..], &b"mnop"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2695u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn complete() {
            fn err_test(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    {
                        use InputLength;
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "ijkl";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, _) => {
                                {
                                    let res =
                                        {
                                            match {
                                                      #[inline(always)]
                                                      fn as_bytes<T: ::AsBytes>(b:
                                                                                    &T)
                                                       -> &[u8] {
                                                          b.as_bytes()
                                                      }
                                                      let expected = "mnop";
                                                      let bytes =
                                                          as_bytes(&expected);
                                                      let res:
                                                              ::IResult<&[u8],
                                                                        &[u8]> =
                                                          if bytes.len() >
                                                                 i.len() {
                                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                          } else if &i[0..bytes.len()]
                                                                        ==
                                                                        bytes
                                                           {
                                                              ::IResult::Done(&i[bytes.len()..],
                                                                              &i[0..bytes.len()])
                                                          } else {
                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                               i))
                                                          };
                                                      res
                                                  } {
                                                ::IResult::Done(i, o) =>
                                                ::IResult::Done(i, o),
                                                ::IResult::Error(e) =>
                                                ::IResult::Error(e),
                                                ::IResult::Incomplete(_) => {
                                                    ::IResult::Error(::Err::Position(::ErrorKind::Complete,
                                                                                     i))
                                                }
                                            }
                                        };
                                    match res {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 ((i).input_len()
                                                                                      -
                                                                                      i.input_len())
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, o) => {
                                            let res = o;
                                            ::IResult::Done(i, (|| { res })())
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"ijklmn"[..];
            let res_a = err_test(a);
            {
                match (&(res_a),
                       &(Error(Position(ErrorKind::Complete, &b"mn"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2710u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn alt() {
            fn work(input: &[u8]) -> IResult<&[u8], &[u8], &'static str> {
                Done(&b""[..], input)
            }
            #[allow(unused_variables)]
            fn dont_work(input: &[u8])
             -> IResult<&[u8], &[u8], &'static str> {
                Error(Code(ErrorKind::Custom("abcd")))
            }
            fn work2(input: &[u8]) -> IResult<&[u8], &[u8], &'static str> {
                Done(input, &b""[..])
            }
            fn alt1(i: &[u8]) -> IResult<&[u8], &[u8], &'static str> {
                {
                    {
                        let res = dont_work(i);
                        match res {
                            ::IResult::Done(_, _) => res,
                            ::IResult::Incomplete(_) => res,
                            _ => {
                                match dont_work(i) {
                                    ::IResult::Done(i, o) =>
                                    ::IResult::Done(i, o),
                                    ::IResult::Incomplete(x) =>
                                    ::IResult::Incomplete(x),
                                    ::IResult::Error(_) => {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                         i))
                                    }
                                }
                            }
                        }
                    }
                }
            }
            fn alt2(i: &[u8]) -> IResult<&[u8], &[u8], &'static str> {
                {
                    {
                        let res = dont_work(i);
                        match res {
                            ::IResult::Done(_, _) => res,
                            ::IResult::Incomplete(_) => res,
                            _ => {
                                match work(i) {
                                    ::IResult::Done(i, o) =>
                                    ::IResult::Done(i, o),
                                    ::IResult::Incomplete(x) =>
                                    ::IResult::Incomplete(x),
                                    ::IResult::Error(_) => {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                         i))
                                    }
                                }
                            }
                        }
                    }
                }
            }
            fn alt3(i: &[u8]) -> IResult<&[u8], &[u8], &'static str> {
                {
                    {
                        let res = dont_work(i);
                        match res {
                            ::IResult::Done(_, _) => res,
                            ::IResult::Incomplete(_) => res,
                            _ => {
                                let res = dont_work(i);
                                match res {
                                    ::IResult::Done(_, _) => res,
                                    ::IResult::Incomplete(_) => res,
                                    _ => {
                                        let res = work2(i);
                                        match res {
                                            ::IResult::Done(_, _) => res,
                                            ::IResult::Incomplete(_) => res,
                                            _ => {
                                                match dont_work(i) {
                                                    ::IResult::Done(i, o) =>
                                                    ::IResult::Done(i, o),
                                                    ::IResult::Incomplete(x)
                                                    =>
                                                    ::IResult::Incomplete(x),
                                                    ::IResult::Error(_) => {
                                                        ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                                         i))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcd"[..];
            {
                match (&(alt1(a)), &(Error(Position(ErrorKind::Alt, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2741u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alt2(a)), &(Done(&b""[..], a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2742u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alt3(a)), &(Done(a, &b""[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2743u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn alt4(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    {
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "abcd";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Done(_, _) => res,
                            ::IResult::Incomplete(_) => res,
                            _ => {
                                match {
                                          #[inline(always)]
                                          fn as_bytes<T: ::AsBytes>(b: &T)
                                           -> &[u8] {
                                              b.as_bytes()
                                          }
                                          let expected = "efgh";
                                          let bytes = as_bytes(&expected);
                                          let res: ::IResult<&[u8], &[u8]> =
                                              if bytes.len() > i.len() {
                                                  ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                              } else if &i[0..bytes.len()] ==
                                                            bytes {
                                                  ::IResult::Done(&i[bytes.len()..],
                                                                  &i[0..bytes.len()])
                                              } else {
                                                  ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                   i))
                                              };
                                          res
                                      } {
                                    ::IResult::Done(i, o) =>
                                    ::IResult::Done(i, o),
                                    ::IResult::Incomplete(x) =>
                                    ::IResult::Incomplete(x),
                                    ::IResult::Error(_) => {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                         i))
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let b = &b"efgh"[..];
            {
                match (&(alt4(a)), &(Done(&b""[..], a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2747u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alt4(b)), &(Done(&b""[..], b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2748u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn alt5<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], bool, u32> {
                {
                    {
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > i.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &i[0..bytes.len()] == bytes {
                                          ::IResult::Done(&i[bytes.len()..],
                                                          &i[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           i))
                                      };
                                  res
                              } {
                            ::IResult::Done(i, o) =>
                            ::IResult::Done(i, (|_| false)(o)),
                            ::IResult::Incomplete(x) =>
                            ::IResult::Incomplete(x),
                            ::IResult::Error(_) => {
                                {
                                    match {
                                              #[inline(always)]
                                              fn as_bytes<T: ::AsBytes>(b: &T)
                                               -> &[u8] {
                                                  b.as_bytes()
                                              }
                                              let expected = "efgh";
                                              let bytes = as_bytes(&expected);
                                              let res:
                                                      ::IResult<&[u8],
                                                                &[u8]> =
                                                  if bytes.len() > i.len() {
                                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                  } else if &i[0..bytes.len()]
                                                                == bytes {
                                                      ::IResult::Done(&i[bytes.len()..],
                                                                      &i[0..bytes.len()])
                                                  } else {
                                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                       i))
                                                  };
                                              res
                                          } {
                                        ::IResult::Done(i, o) =>
                                        ::IResult::Done(i, (|_| true)(o)),
                                        ::IResult::Incomplete(x) =>
                                        ::IResult::Incomplete(x),
                                        ::IResult::Error(_) => {
                                            ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                             i))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                match (&(alt5(a)), &(Done(&b""[..], false))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2752u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alt5(b)), &(Done(&b""[..], true))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2753u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn alt_incomplete() {
            fn alt1(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    {
                        let res =
                            {
                                #[inline(always)]
                                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                    b.as_bytes()
                                }
                                let expected = "a";
                                let bytes = as_bytes(&expected);
                                let res: ::IResult<&[u8], &[u8]> =
                                    if bytes.len() > i.len() {
                                        ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                    } else if &i[0..bytes.len()] == bytes {
                                        ::IResult::Done(&i[bytes.len()..],
                                                        &i[0..bytes.len()])
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                         i))
                                    };
                                res
                            };
                        match res {
                            ::IResult::Done(_, _) => res,
                            ::IResult::Incomplete(_) => res,
                            _ => {
                                let res =
                                    {
                                        #[inline(always)]
                                        fn as_bytes<T: ::AsBytes>(b: &T)
                                         -> &[u8] {
                                            b.as_bytes()
                                        }
                                        let expected = "bc";
                                        let bytes = as_bytes(&expected);
                                        let res: ::IResult<&[u8], &[u8]> =
                                            if bytes.len() > i.len() {
                                                ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                            } else if &i[0..bytes.len()] ==
                                                          bytes {
                                                ::IResult::Done(&i[bytes.len()..],
                                                                &i[0..bytes.len()])
                                            } else {
                                                ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                 i))
                                            };
                                        res
                                    };
                                match res {
                                    ::IResult::Done(_, _) => res,
                                    ::IResult::Incomplete(_) => res,
                                    _ => {
                                        match {
                                                  #[inline(always)]
                                                  fn as_bytes<T: ::AsBytes>(b:
                                                                                &T)
                                                   -> &[u8] {
                                                      b.as_bytes()
                                                  }
                                                  let expected = "def";
                                                  let bytes =
                                                      as_bytes(&expected);
                                                  let res:
                                                          ::IResult<&[u8],
                                                                    &[u8]> =
                                                      if bytes.len() > i.len()
                                                         {
                                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                      } else if &i[0..bytes.len()]
                                                                    == bytes {
                                                          ::IResult::Done(&i[bytes.len()..],
                                                                          &i[0..bytes.len()])
                                                      } else {
                                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                           i))
                                                      };
                                                  res
                                              } {
                                            ::IResult::Done(i, o) =>
                                            ::IResult::Done(i, o),
                                            ::IResult::Incomplete(x) =>
                                            ::IResult::Incomplete(x),
                                            ::IResult::Error(_) => {
                                                ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                                 i))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b""[..];
            {
                match (&(alt1(a)), &(Incomplete(Needed::Size(1)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2762u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"b"[..];
            {
                match (&(alt1(a)), &(Incomplete(Needed::Size(2)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2764u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"bcd"[..];
            {
                match (&(alt1(a)), &(Done(&b"d"[..], &b"bc"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2766u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"cde"[..];
            {
                match (&(alt1(a)), &(Error(Position(ErrorKind::Alt, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2768u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"de"[..];
            {
                match (&(alt1(a)), &(Incomplete(Needed::Size(3)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2770u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"defg"[..];
            {
                match (&(alt1(a)), &(Done(&b"g"[..], &b"def"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2772u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn alt_complete() {
            fn ac(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    let res =
                        {
                            match {
                                      #[inline(always)]
                                      fn as_bytes<T: ::AsBytes>(b: &T)
                                       -> &[u8] {
                                          b.as_bytes()
                                      }
                                      let expected = "abcd";
                                      let bytes = as_bytes(&expected);
                                      let res: ::IResult<&[u8], &[u8]> =
                                          if bytes.len() > i.len() {
                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                          } else if &i[0..bytes.len()] ==
                                                        bytes {
                                              ::IResult::Done(&i[bytes.len()..],
                                                              &i[0..bytes.len()])
                                          } else {
                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                               i))
                                          };
                                      res
                                  } {
                                ::IResult::Done(i, o) =>
                                ::IResult::Done(i, o),
                                ::IResult::Error(e) => ::IResult::Error(e),
                                ::IResult::Incomplete(_) => {
                                    ::IResult::Error(::Err::Position(::ErrorKind::Complete,
                                                                     i))
                                }
                            }
                        };
                    match res {
                        ::IResult::Done(_, _) => res,
                        _ => {
                            let res =
                                {
                                    match {
                                              #[inline(always)]
                                              fn as_bytes<T: ::AsBytes>(b: &T)
                                               -> &[u8] {
                                                  b.as_bytes()
                                              }
                                              let expected = "ef";
                                              let bytes = as_bytes(&expected);
                                              let res:
                                                      ::IResult<&[u8],
                                                                &[u8]> =
                                                  if bytes.len() > i.len() {
                                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                  } else if &i[0..bytes.len()]
                                                                == bytes {
                                                      ::IResult::Done(&i[bytes.len()..],
                                                                      &i[0..bytes.len()])
                                                  } else {
                                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                       i))
                                                  };
                                              res
                                          } {
                                        ::IResult::Done(i, o) =>
                                        ::IResult::Done(i, o),
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(_) => {
                                            ::IResult::Error(::Err::Position(::ErrorKind::Complete,
                                                                             i))
                                        }
                                    }
                                };
                            match res {
                                ::IResult::Done(_, _) => res,
                                _ => {
                                    let res =
                                        {
                                            match {
                                                      #[inline(always)]
                                                      fn as_bytes<T: ::AsBytes>(b:
                                                                                    &T)
                                                       -> &[u8] {
                                                          b.as_bytes()
                                                      }
                                                      let expected = "ghi";
                                                      let bytes =
                                                          as_bytes(&expected);
                                                      let res:
                                                              ::IResult<&[u8],
                                                                        &[u8]> =
                                                          if bytes.len() >
                                                                 i.len() {
                                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                          } else if &i[0..bytes.len()]
                                                                        ==
                                                                        bytes
                                                           {
                                                              ::IResult::Done(&i[bytes.len()..],
                                                                              &i[0..bytes.len()])
                                                          } else {
                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                               i))
                                                          };
                                                      res
                                                  } {
                                                ::IResult::Done(i, o) =>
                                                ::IResult::Done(i, o),
                                                ::IResult::Error(e) =>
                                                ::IResult::Error(e),
                                                ::IResult::Incomplete(_) => {
                                                    ::IResult::Error(::Err::Position(::ErrorKind::Complete,
                                                                                     i))
                                                }
                                            }
                                        };
                                    match res {
                                        ::IResult::Done(_, _) => res,
                                        _ => {
                                            match {
                                                      #[inline(always)]
                                                      fn as_bytes<T: ::AsBytes>(b:
                                                                                    &T)
                                                       -> &[u8] {
                                                          b.as_bytes()
                                                      }
                                                      let expected = "kl";
                                                      let bytes =
                                                          as_bytes(&expected);
                                                      let res:
                                                              ::IResult<&[u8],
                                                                        &[u8]> =
                                                          if bytes.len() >
                                                                 i.len() {
                                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                          } else if &i[0..bytes.len()]
                                                                        ==
                                                                        bytes
                                                           {
                                                              ::IResult::Done(&i[bytes.len()..],
                                                                              &i[0..bytes.len()])
                                                          } else {
                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                               i))
                                                          };
                                                      res
                                                  } {
                                                ::IResult::Done(i, o) =>
                                                ::IResult::Done(i, o),
                                                ::IResult::Incomplete(x) =>
                                                ::IResult::Incomplete(x),
                                                ::IResult::Error(_) => {
                                                    ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                                     i))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b""[..];
            {
                match (&(ac(a)), &(Incomplete(Needed::Size(2)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2782u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"ef"[..];
            {
                match (&(ac(a)), &(Done(&b""[..], &b"ef"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2784u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let a = &b"cde"[..];
            {
                match (&(ac(a)), &(Error(Position(ErrorKind::Alt, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2786u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn switch() {
            fn sw(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    {
                        match {
                                  let cnt = 4 as usize;
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if i.len() < cnt {
                                          ::IResult::Incomplete(::Needed::Size(cnt))
                                      } else {
                                          ::IResult::Done(&i[cnt..],
                                                          &i[0..cnt])
                                      };
                                  res
                              } {
                            ::IResult::Error(e) =>
                            ::IResult::Error(::Err::NodePosition(::ErrorKind::Switch,
                                                                 i,
                                                                 ::std::boxed::Box::new(e))),
                            ::IResult::Incomplete(i) =>
                            ::IResult::Incomplete(i),
                            ::IResult::Done(i, o) => {
                                match o {
                                    b"abcd" =>
                                    match {
                                              let cnt = 2 as usize;
                                              let res:
                                                      ::IResult<&[u8],
                                                                &[u8]> =
                                                  if i.len() < cnt {
                                                      ::IResult::Incomplete(::Needed::Size(cnt))
                                                  } else {
                                                      ::IResult::Done(&i[cnt..],
                                                                      &i[0..cnt])
                                                  };
                                              res
                                          } {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(::Err::NodePosition(::ErrorKind::Switch,
                                                                             i,
                                                                             ::std::boxed::Box::new(e))),
                                        a => a,
                                    },
                                    b"efgh" =>
                                    match {
                                              let cnt = 4 as usize;
                                              let res:
                                                      ::IResult<&[u8],
                                                                &[u8]> =
                                                  if i.len() < cnt {
                                                      ::IResult::Incomplete(::Needed::Size(cnt))
                                                  } else {
                                                      ::IResult::Done(&i[cnt..],
                                                                      &i[0..cnt])
                                                  };
                                              res
                                          } {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(::Err::NodePosition(::ErrorKind::Switch,
                                                                             i,
                                                                             ::std::boxed::Box::new(e))),
                                        a => a,
                                    },
                                    _ =>
                                    ::IResult::Error(::Err::Position(::ErrorKind::Switch,
                                                                     i)),
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcdefgh"[..];
            {
                match (&(sw(a)), &(Done(&b"gh"[..], &b"ef"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2799u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b = &b"efghijkl"[..];
            {
                match (&(sw(b)), &(Done(&b""[..], &b"ijkl"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2802u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let c = &b"afghijkl"[..];
            {
                match (&(sw(c)),
                       &(Error(Position(ErrorKind::Switch,
                                        &b"afghijkl"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2804u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn opt() {
            fn o(i: &[u8]) -> ::IResult<&[u8], Option<&[u8]>, u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Done(i, o) =>
                        ::IResult::Done(i, ::std::option::Option::Some(o)),
                        ::IResult::Error(_) =>
                        ::IResult::Done(i, ::std::option::Option::None),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                    }
                }
            }
            let a = &b"abcdef"[..];
            let b = &b"bcdefg"[..];
            {
                match (&(o(a)), &(Done(&b"ef"[..], Some(&b"abcd"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2813u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(o(b)), &(Done(&b"bcdefg"[..], None))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2814u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn opt_res() {
            fn o(i: &[u8])
             -> ::IResult<&[u8], Result<&[u8], Err<&[u8]>>, u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Done(i, o) => ::IResult::Done(i, Ok(o)),
                        ::IResult::Error(e) => ::IResult::Done(i, Err(e)),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                    }
                }
            }
            let a = &b"abcdef"[..];
            let b = &b"bcdefg"[..];
            {
                match (&(o(a)), &(Done(&b"ef"[..], Ok(&b"abcd"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2823u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(o(b)),
                       &(Done(&b"bcdefg"[..],
                              Err(Position(ErrorKind::Tag, b))))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2824u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn cond() {
            let b = true;
            let f:
                    Box<Fn(&'static [u8]) ->
                        IResult<&[u8], Option<&[u8]>, &str>> =
                Box::new(|i: &'static [u8]| {
                         {
                             if b {
                                 match {
                                           #[inline(always)]
                                           fn as_bytes<T: ::AsBytes>(b: &T)
                                            -> &[u8] {
                                               b.as_bytes()
                                           }
                                           let expected = "abcd";
                                           let bytes = as_bytes(&expected);
                                           let res: ::IResult<&[u8], &[u8]> =
                                               if bytes.len() > i.len() {
                                                   ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                               } else if &i[0..bytes.len()] ==
                                                             bytes {
                                                   ::IResult::Done(&i[bytes.len()..],
                                                                   &i[0..bytes.len()])
                                               } else {
                                                   ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                    i))
                                               };
                                           res
                                       } {
                                     ::IResult::Done(i, o) =>
                                     ::IResult::Done(i,
                                                     ::std::option::Option::Some(o)),
                                     ::IResult::Error(_) =>
                                     ::IResult::Done(i,
                                                     ::std::option::Option::None),
                                     ::IResult::Incomplete(i) =>
                                     ::IResult::Incomplete(i),
                                 }
                             } else {
                                 ::IResult::Done(i,
                                                 ::std::option::Option::None)
                             }
                         } });
            let a = b"abcdef";
            {
                match (&(f(&a[..])), &(Done(&b"ef"[..], Some(&b"abcd"[..]))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2833u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b2 = false;
            let f2:
                    Box<Fn(&'static [u8]) ->
                        IResult<&[u8], Option<&[u8]>, &str>> =
                Box::new(|i: &'static [u8]| {
                         {
                             if b2 {
                                 match {
                                           #[inline(always)]
                                           fn as_bytes<T: ::AsBytes>(b: &T)
                                            -> &[u8] {
                                               b.as_bytes()
                                           }
                                           let expected = "abcd";
                                           let bytes = as_bytes(&expected);
                                           let res: ::IResult<&[u8], &[u8]> =
                                               if bytes.len() > i.len() {
                                                   ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                               } else if &i[0..bytes.len()] ==
                                                             bytes {
                                                   ::IResult::Done(&i[bytes.len()..],
                                                                   &i[0..bytes.len()])
                                               } else {
                                                   ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                    i))
                                               };
                                           res
                                       } {
                                     ::IResult::Done(i, o) =>
                                     ::IResult::Done(i,
                                                     ::std::option::Option::Some(o)),
                                     ::IResult::Error(_) =>
                                     ::IResult::Done(i,
                                                     ::std::option::Option::None),
                                     ::IResult::Incomplete(i) =>
                                     ::IResult::Incomplete(i),
                                 }
                             } else {
                                 ::IResult::Done(i,
                                                 ::std::option::Option::None)
                             }
                         } });
            {
                match (&(f2(&a[..])), &(Done(&b"abcdef"[..], None))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2839u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn cond_wrapping() {
            fn silly(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "foo";
                    let bytes = as_bytes(&expected);
                    let res: ::IResult<&[u8], &[u8]> =
                        if bytes.len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size(bytes.len()))
                        } else if &i[0..bytes.len()] == bytes {
                            ::IResult::Done(&i[bytes.len()..],
                                            &i[0..bytes.len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                             i))
                        };
                    res
                }
            }
            let b = true;
            let f:
                    Box<Fn(&'static [u8]) ->
                        IResult<&[u8], Option<&[u8]>, &str>> =
                Box::new(|i: &'static [u8]| {
                         {
                             if b {
                                 match silly(i) {
                                     ::IResult::Done(i, o) =>
                                     ::IResult::Done(i,
                                                     ::std::option::Option::Some(o)),
                                     ::IResult::Error(_) =>
                                     ::IResult::Done(i,
                                                     ::std::option::Option::None),
                                     ::IResult::Incomplete(i) =>
                                     ::IResult::Incomplete(i),
                                 }
                             } else {
                                 ::IResult::Done(i,
                                                 ::std::option::Option::None)
                             }
                         } });
            {
                match (&(f(b"foobar")),
                       &(Done(&b"bar"[..], Some(&b"foo"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2851u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn peek() {
            fn ptag(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Done(_, o) => ::IResult::Done(i, o),
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                    }
                }
            }
            let r1 = ptag(&b"abcdefgh"[..]);
            {
                match (&(r1), &(Done(&b"abcdefgh"[..], &b"abcd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2859u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r1 = ptag(&b"efgh"[..]);
            {
                match (&(r1),
                       &(Error(Position(ErrorKind::Tag, &b"efgh"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2862u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn pair() {
            fn p(i: &[u8]) -> ::IResult<&[u8], (&[u8], &[u8]), u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, o1) => {
                            match {
                                      #[inline(always)]
                                      fn as_bytes<T: ::AsBytes>(b: &T)
                                       -> &[u8] {
                                          b.as_bytes()
                                      }
                                      let expected = "efgh";
                                      let bytes = as_bytes(&expected);
                                      let res: ::IResult<&[u8], &[u8]> =
                                          if bytes.len() > i1.len() {
                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                          } else if &i1[0..bytes.len()] ==
                                                        bytes {
                                              ::IResult::Done(&i1[bytes.len()..],
                                                              &i1[0..bytes.len()])
                                          } else {
                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                               i1))
                                          };
                                      res
                                  } {
                                ::IResult::Error(a) => ::IResult::Error(a),
                                ::IResult::Incomplete(i) =>
                                ::IResult::Incomplete(i),
                                ::IResult::Done(i2, o2) => {
                                    ::IResult::Done(i2, (o1, o2))
                                }
                            }
                        }
                    }
                }
            }
            let r1 = p(&b"abcdefghijkl"[..]);
            {
                match (&(r1),
                       &(Done(&b"ijkl"[..], (&b"abcd"[..], &b"efgh"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2870u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn separated_pair() {
            fn p(i: &[u8]) -> ::IResult<&[u8], (&[u8], &[u8]), u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, o1) => {
                            {
                                match {
                                          #[inline(always)]
                                          fn as_bytes<T: ::AsBytes>(b: &T)
                                           -> &[u8] {
                                              b.as_bytes()
                                          }
                                          let expected = ",";
                                          let bytes = as_bytes(&expected);
                                          let res: ::IResult<&[u8], &[u8]> =
                                              if bytes.len() > i1.len() {
                                                  ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                              } else if &i1[0..bytes.len()] ==
                                                            bytes {
                                                  ::IResult::Done(&i1[bytes.len()..],
                                                                  &i1[0..bytes.len()])
                                              } else {
                                                  ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                   i1))
                                              };
                                          res
                                      } {
                                    ::IResult::Error(a) =>
                                    ::IResult::Error(a),
                                    ::IResult::Incomplete(i) =>
                                    ::IResult::Incomplete(i),
                                    ::IResult::Done(i2, _) => {
                                        {
                                            match {
                                                      #[inline(always)]
                                                      fn as_bytes<T: ::AsBytes>(b:
                                                                                    &T)
                                                       -> &[u8] {
                                                          b.as_bytes()
                                                      }
                                                      let expected = "efgh";
                                                      let bytes =
                                                          as_bytes(&expected);
                                                      let res:
                                                              ::IResult<&[u8],
                                                                        &[u8]> =
                                                          if bytes.len() >
                                                                 i2.len() {
                                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                          } else if &i2[0..bytes.len()]
                                                                        ==
                                                                        bytes
                                                           {
                                                              ::IResult::Done(&i2[bytes.len()..],
                                                                              &i2[0..bytes.len()])
                                                          } else {
                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                               i2))
                                                          };
                                                      res
                                                  } {
                                                ::IResult::Error(a) =>
                                                ::IResult::Error(a),
                                                ::IResult::Incomplete(i) =>
                                                ::IResult::Incomplete(i),
                                                ::IResult::Done(i3, o3) => {
                                                    ::IResult::Done(i3,
                                                                    (o1, o3))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let r1 = p(&b"abcd,efghijkl"[..]);
            {
                match (&(r1),
                       &(Done(&b"ijkl"[..], (&b"abcd"[..], &b"efgh"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2878u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn preceded() {
            fn p(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, _) => {
                            match {
                                      #[inline(always)]
                                      fn as_bytes<T: ::AsBytes>(b: &T)
                                       -> &[u8] {
                                          b.as_bytes()
                                      }
                                      let expected = "efgh";
                                      let bytes = as_bytes(&expected);
                                      let res: ::IResult<&[u8], &[u8]> =
                                          if bytes.len() > i1.len() {
                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                          } else if &i1[0..bytes.len()] ==
                                                        bytes {
                                              ::IResult::Done(&i1[bytes.len()..],
                                                              &i1[0..bytes.len()])
                                          } else {
                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                               i1))
                                          };
                                      res
                                  } {
                                ::IResult::Error(a) => ::IResult::Error(a),
                                ::IResult::Incomplete(i) =>
                                ::IResult::Incomplete(i),
                                ::IResult::Done(i2, o2) => {
                                    ::IResult::Done(i2, o2)
                                }
                            }
                        }
                    }
                }
            }
            let r1 = p(&b"abcdefghijkl"[..]);
            {
                match (&(r1), &(Done(&b"ijkl"[..], &b"efgh"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2886u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn terminated() {
            fn p(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, o1) => {
                            match {
                                      #[inline(always)]
                                      fn as_bytes<T: ::AsBytes>(b: &T)
                                       -> &[u8] {
                                          b.as_bytes()
                                      }
                                      let expected = "efgh";
                                      let bytes = as_bytes(&expected);
                                      let res: ::IResult<&[u8], &[u8]> =
                                          if bytes.len() > i1.len() {
                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                          } else if &i1[0..bytes.len()] ==
                                                        bytes {
                                              ::IResult::Done(&i1[bytes.len()..],
                                                              &i1[0..bytes.len()])
                                          } else {
                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                               i1))
                                          };
                                      res
                                  } {
                                ::IResult::Error(a) => ::IResult::Error(a),
                                ::IResult::Incomplete(i) =>
                                ::IResult::Incomplete(i),
                                ::IResult::Done(i2, _) => {
                                    ::IResult::Done(i2, o1)
                                }
                            }
                        }
                    }
                }
            }
            let r1 = p(&b"abcdefghijkl"[..]);
            {
                match (&(r1), &(Done(&b"ijkl"[..], &b"abcd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2894u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn delimited() {
            fn p(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, _) => {
                            {
                                match {
                                          #[inline(always)]
                                          fn as_bytes<T: ::AsBytes>(b: &T)
                                           -> &[u8] {
                                              b.as_bytes()
                                          }
                                          let expected = "efgh";
                                          let bytes = as_bytes(&expected);
                                          let res: ::IResult<&[u8], &[u8]> =
                                              if bytes.len() > i1.len() {
                                                  ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                              } else if &i1[0..bytes.len()] ==
                                                            bytes {
                                                  ::IResult::Done(&i1[bytes.len()..],
                                                                  &i1[0..bytes.len()])
                                              } else {
                                                  ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                   i1))
                                              };
                                          res
                                      } {
                                    ::IResult::Error(a) =>
                                    ::IResult::Error(a),
                                    ::IResult::Incomplete(i) =>
                                    ::IResult::Incomplete(i),
                                    ::IResult::Done(i2, o2) => {
                                        {
                                            match {
                                                      #[inline(always)]
                                                      fn as_bytes<T: ::AsBytes>(b:
                                                                                    &T)
                                                       -> &[u8] {
                                                          b.as_bytes()
                                                      }
                                                      let expected = "ij";
                                                      let bytes =
                                                          as_bytes(&expected);
                                                      let res:
                                                              ::IResult<&[u8],
                                                                        &[u8]> =
                                                          if bytes.len() >
                                                                 i2.len() {
                                                              ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                          } else if &i2[0..bytes.len()]
                                                                        ==
                                                                        bytes
                                                           {
                                                              ::IResult::Done(&i2[bytes.len()..],
                                                                              &i2[0..bytes.len()])
                                                          } else {
                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                               i2))
                                                          };
                                                      res
                                                  } {
                                                ::IResult::Error(a) =>
                                                ::IResult::Error(a),
                                                ::IResult::Incomplete(i) =>
                                                ::IResult::Incomplete(i),
                                                ::IResult::Done(i3, _) => {
                                                    ::IResult::Done(i3, o2)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let r1 = p(&b"abcdefghijkl"[..]);
            {
                match (&(r1), &(Done(&b"kl"[..], &b"efgh"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2902u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn separated_list() {
            fn multi(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    let mut res = ::std::vec::Vec::new();
                    let mut input = i;
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > input.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &input[0..bytes.len()] == bytes {
                                      ::IResult::Done(&input[bytes.len()..],
                                                      &input[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       input))
                                  };
                              res
                          } {
                        ::IResult::Error(_) =>
                        ::IResult::Done(input, ::std::vec::Vec::new()),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i, o) => {
                            if i.len() == input.len() {
                                ::IResult::Error(::Err::Position(::ErrorKind::SeparatedList,
                                                                 input))
                            } else {
                                res.push(o);
                                input = i;
                                loop  {
                                    if let ::IResult::Done(i2, _) =
                                           {
                                               #[inline(always)]
                                               fn as_bytes<T: ::AsBytes>(b:
                                                                             &T)
                                                -> &[u8] {
                                                   b.as_bytes()
                                               }
                                               let expected = ",";
                                               let bytes =
                                                   as_bytes(&expected);
                                               let res:
                                                       ::IResult<&[u8],
                                                                 &[u8]> =
                                                   if bytes.len() >
                                                          input.len() {
                                                       ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                   } else if &input[0..bytes.len()]
                                                                 == bytes {
                                                       ::IResult::Done(&input[bytes.len()..],
                                                                       &input[0..bytes.len()])
                                                   } else {
                                                       ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                        input))
                                                   };
                                               res
                                           } {
                                        if i2.len() == input.len() { break ; }
                                        input = i2;
                                        if let ::IResult::Done(i3, o3) =
                                               {
                                                   #[inline(always)]
                                                   fn as_bytes<T: ::AsBytes>(b:
                                                                                 &T)
                                                    -> &[u8] {
                                                       b.as_bytes()
                                                   }
                                                   let expected = "abcd";
                                                   let bytes =
                                                       as_bytes(&expected);
                                                   let res:
                                                           ::IResult<&[u8],
                                                                     &[u8]> =
                                                       if bytes.len() >
                                                              input.len() {
                                                           ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                       } else if &input[0..bytes.len()]
                                                                     == bytes
                                                        {
                                                           ::IResult::Done(&input[bytes.len()..],
                                                                           &input[0..bytes.len()])
                                                       } else {
                                                           ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                            input))
                                                       };
                                                   res
                                               } {
                                            if i3.len() == input.len() {
                                                break ;
                                            }
                                            res.push(o3);
                                            input = i3;
                                        } else { break ; }
                                    } else { break ; }
                                }
                                ::IResult::Done(input, res)
                            }
                        }
                    }
                }
            }
            fn multi_empty(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    let mut res = ::std::vec::Vec::new();
                    let mut input = i;
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > input.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &input[0..bytes.len()] == bytes {
                                      ::IResult::Done(&input[bytes.len()..],
                                                      &input[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       input))
                                  };
                              res
                          } {
                        ::IResult::Error(_) =>
                        ::IResult::Done(input, ::std::vec::Vec::new()),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i, o) => {
                            if i.len() == input.len() {
                                ::IResult::Error(::Err::Position(::ErrorKind::SeparatedList,
                                                                 input))
                            } else {
                                res.push(o);
                                input = i;
                                loop  {
                                    if let ::IResult::Done(i2, _) =
                                           {
                                               #[inline(always)]
                                               fn as_bytes<T: ::AsBytes>(b:
                                                                             &T)
                                                -> &[u8] {
                                                   b.as_bytes()
                                               }
                                               let expected = ",";
                                               let bytes =
                                                   as_bytes(&expected);
                                               let res:
                                                       ::IResult<&[u8],
                                                                 &[u8]> =
                                                   if bytes.len() >
                                                          input.len() {
                                                       ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                   } else if &input[0..bytes.len()]
                                                                 == bytes {
                                                       ::IResult::Done(&input[bytes.len()..],
                                                                       &input[0..bytes.len()])
                                                   } else {
                                                       ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                        input))
                                                   };
                                               res
                                           } {
                                        if i2.len() == input.len() { break ; }
                                        input = i2;
                                        if let ::IResult::Done(i3, o3) =
                                               {
                                                   #[inline(always)]
                                                   fn as_bytes<T: ::AsBytes>(b:
                                                                                 &T)
                                                    -> &[u8] {
                                                       b.as_bytes()
                                                   }
                                                   let expected = "";
                                                   let bytes =
                                                       as_bytes(&expected);
                                                   let res:
                                                           ::IResult<&[u8],
                                                                     &[u8]> =
                                                       if bytes.len() >
                                                              input.len() {
                                                           ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                       } else if &input[0..bytes.len()]
                                                                     == bytes
                                                        {
                                                           ::IResult::Done(&input[bytes.len()..],
                                                                           &input[0..bytes.len()])
                                                       } else {
                                                           ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                            input))
                                                       };
                                                   res
                                               } {
                                            if i3.len() == input.len() {
                                                break ;
                                            }
                                            res.push(o3);
                                            input = i3;
                                        } else { break ; }
                                    } else { break ; }
                                }
                                ::IResult::Done(input, res)
                            }
                        }
                    }
                }
            }
            let a = &b"abcdef"[..];
            let b = &b"abcd,abcdef"[..];
            let c = &b"azerty"[..];
            let d = &b",,abc"[..];
            let res1 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..]]));
            {
                match (&(multi(a)), &(Done(&b"ef"[..], res1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2916u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res2 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..],
                                                        &b"abcd"[..]]));
            {
                match (&(multi(b)), &(Done(&b"ef"[..], res2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2918u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(c)), &(Done(&b"azerty"[..], Vec::new()))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2919u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res3 =
                <[_]>::into_vec(::std::boxed::Box::new([&b""[..], &b""[..],
                                                        &b""[..]]));
            {
                match (&(multi_empty(d)), &(Done(&b"abc"[..], res3))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2921u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn separated_nonempty_list() {
            fn multi(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    let mut res = ::std::vec::Vec::new();
                    let mut input = i;
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > input.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &input[0..bytes.len()] == bytes {
                                      ::IResult::Done(&input[bytes.len()..],
                                                      &input[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       input))
                                  };
                              res
                          } {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i, o) => {
                            if i.len() == input.len() {
                                ::IResult::Error(::Err::Position(::ErrorKind::SeparatedNonEmptyList,
                                                                 input))
                            } else {
                                res.push(o);
                                input = i;
                                loop  {
                                    if let ::IResult::Done(i2, _) =
                                           {
                                               #[inline(always)]
                                               fn as_bytes<T: ::AsBytes>(b:
                                                                             &T)
                                                -> &[u8] {
                                                   b.as_bytes()
                                               }
                                               let expected = ",";
                                               let bytes =
                                                   as_bytes(&expected);
                                               let res:
                                                       ::IResult<&[u8],
                                                                 &[u8]> =
                                                   if bytes.len() >
                                                          input.len() {
                                                       ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                   } else if &input[0..bytes.len()]
                                                                 == bytes {
                                                       ::IResult::Done(&input[bytes.len()..],
                                                                       &input[0..bytes.len()])
                                                   } else {
                                                       ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                        input))
                                                   };
                                               res
                                           } {
                                        if i2.len() == input.len() { break ; }
                                        input = i2;
                                        if let ::IResult::Done(i3, o3) =
                                               {
                                                   #[inline(always)]
                                                   fn as_bytes<T: ::AsBytes>(b:
                                                                                 &T)
                                                    -> &[u8] {
                                                       b.as_bytes()
                                                   }
                                                   let expected = "abcd";
                                                   let bytes =
                                                       as_bytes(&expected);
                                                   let res:
                                                           ::IResult<&[u8],
                                                                     &[u8]> =
                                                       if bytes.len() >
                                                              input.len() {
                                                           ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                       } else if &input[0..bytes.len()]
                                                                     == bytes
                                                        {
                                                           ::IResult::Done(&input[bytes.len()..],
                                                                           &input[0..bytes.len()])
                                                       } else {
                                                           ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                            input))
                                                       };
                                                   res
                                               } {
                                            if i3.len() == input.len() {
                                                break ;
                                            }
                                            res.push(o3);
                                            input = i3;
                                        } else { break ; }
                                    } else { break ; }
                                }
                                ::IResult::Done(input, res)
                            }
                        }
                    }
                }
            }
            let a = &b"abcdef"[..];
            let b = &b"abcd,abcdef"[..];
            let c = &b"azerty"[..];
            let res1 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..]]));
            {
                match (&(multi(a)), &(Done(&b"ef"[..], res1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2933u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res2 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..],
                                                        &b"abcd"[..]]));
            {
                match (&(multi(b)), &(Done(&b"ef"[..], res2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2935u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(c)), &(Error(Position(ErrorKind::Tag, c)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2936u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn many0() {
            fn multi(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    use InputLength;
                    if (i).input_len() == 0 {
                        ::IResult::Done(i, ::std::vec::Vec::new())
                    } else {
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > i.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &i[0..bytes.len()] == bytes {
                                          ::IResult::Done(&i[bytes.len()..],
                                                          &i[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           i))
                                      };
                                  res
                              } {
                            ::IResult::Error(_) => {
                                ::IResult::Done(i, ::std::vec::Vec::new())
                            }
                            ::IResult::Incomplete(i) =>
                            ::IResult::Incomplete(i),
                            ::IResult::Done(i1, o1) => {
                                if i1.input_len() == 0 {
                                    ::IResult::Done(i1,
                                                    <[_]>::into_vec(::std::boxed::Box::new([o1])))
                                } else {
                                    let mut res =
                                        ::std::vec::Vec::with_capacity(4);
                                    res.push(o1);
                                    let mut input = i1;
                                    let mut incomplete:
                                            ::std::option::Option<::Needed> =
                                        ::std::option::Option::None;
                                    loop  {
                                        match {
                                                  #[inline(always)]
                                                  fn as_bytes<T: ::AsBytes>(b:
                                                                                &T)
                                                   -> &[u8] {
                                                      b.as_bytes()
                                                  }
                                                  let expected = "abcd";
                                                  let bytes =
                                                      as_bytes(&expected);
                                                  let res:
                                                          ::IResult<&[u8],
                                                                    &[u8]> =
                                                      if bytes.len() >
                                                             input.len() {
                                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                      } else if &input[0..bytes.len()]
                                                                    == bytes {
                                                          ::IResult::Done(&input[bytes.len()..],
                                                                          &input[0..bytes.len()])
                                                      } else {
                                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                           input))
                                                      };
                                                  res
                                              } {
                                            ::IResult::Done(i, o) => {
                                                if i.input_len() ==
                                                       input.input_len() {
                                                    break ;
                                                }
                                                res.push(o);
                                                input = i;
                                            }
                                            ::IResult::Error(_) => { break ; }
                                            ::IResult::Incomplete(::Needed::Unknown)
                                            => {
                                                incomplete =
                                                    ::std::option::Option::Some(::Needed::Unknown);
                                                break ;
                                            }
                                            ::IResult::Incomplete(::Needed::Size(i))
                                            => {
                                                incomplete =
                                                    ::std::option::Option::Some(::Needed::Size(i
                                                                                                   +
                                                                                                   (i).input_len()
                                                                                                   -
                                                                                                   input.input_len()));
                                                break ;
                                            }
                                        }
                                        if input.input_len() == 0 { break ; }
                                    }
                                    match incomplete {
                                        ::std::option::Option::Some(i) =>
                                        ::IResult::Incomplete(i),
                                        ::std::option::Option::None =>
                                        ::IResult::Done(input, res),
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcdef"[..];
            let b = &b"abcdabcdefgh"[..];
            let c = &b"azerty"[..];
            let d = &b"abcdab"[..];
            {
                match (&(multi(a)), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2949u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res2 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..],
                                                        &b"abcd"[..]]));
            {
                match (&(multi(b)), &(Done(&b"efgh"[..], res2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2951u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(c)), &(Done(&b"azerty"[..], Vec::new()))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2952u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(d)), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2953u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn many1() {
            fn multi(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    use InputLength;
                    match {
                              #[inline(always)]
                              fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                  b.as_bytes()
                              }
                              let expected = "abcd";
                              let bytes = as_bytes(&expected);
                              let res: ::IResult<&[u8], &[u8]> =
                                  if bytes.len() > i.len() {
                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                  } else if &i[0..bytes.len()] == bytes {
                                      ::IResult::Done(&i[bytes.len()..],
                                                      &i[0..bytes.len()])
                                  } else {
                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                       i))
                                  };
                              res
                          } {
                        ::IResult::Error(_) =>
                        ::IResult::Error(::Err::Position(::ErrorKind::Many1,
                                                         i)),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, o1) => {
                            if i1.len() == 0 {
                                ::IResult::Done(i1,
                                                <[_]>::into_vec(::std::boxed::Box::new([o1])))
                            } else {
                                let mut res =
                                    ::std::vec::Vec::with_capacity(4);
                                res.push(o1);
                                let mut input = i1;
                                let mut incomplete:
                                        ::std::option::Option<::Needed> =
                                    ::std::option::Option::None;
                                loop  {
                                    if input.input_len() == 0 { break ; }
                                    match {
                                              #[inline(always)]
                                              fn as_bytes<T: ::AsBytes>(b: &T)
                                               -> &[u8] {
                                                  b.as_bytes()
                                              }
                                              let expected = "abcd";
                                              let bytes = as_bytes(&expected);
                                              let res:
                                                      ::IResult<&[u8],
                                                                &[u8]> =
                                                  if bytes.len() > input.len()
                                                     {
                                                      ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                  } else if &input[0..bytes.len()]
                                                                == bytes {
                                                      ::IResult::Done(&input[bytes.len()..],
                                                                      &input[0..bytes.len()])
                                                  } else {
                                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                       input))
                                                  };
                                              res
                                          } {
                                        ::IResult::Error(_) => { break ; }
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        => {
                                            incomplete =
                                                ::std::option::Option::Some(::Needed::Unknown);
                                            break ;
                                        }
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        => {
                                            incomplete =
                                                ::std::option::Option::Some(::Needed::Size(i
                                                                                               +
                                                                                               (i).input_len()
                                                                                               -
                                                                                               input.input_len()));
                                            break ;
                                        }
                                        ::IResult::Done(i, o) => {
                                            if i.input_len() ==
                                                   input.input_len() {
                                                break ;
                                            }
                                            res.push(o);
                                            input = i;
                                        }
                                    }
                                }
                                match incomplete {
                                    ::std::option::Option::Some(i) =>
                                    ::IResult::Incomplete(i),
                                    ::std::option::Option::None =>
                                    ::IResult::Done(input, res),
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcdef"[..];
            let b = &b"abcdabcdefgh"[..];
            let c = &b"azerty"[..];
            let d = &b"abcdab"[..];
            {
                match (&(multi(a)), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2978u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res2 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..],
                                                        &b"abcd"[..]]));
            {
                match (&(multi(b)), &(Done(&b"efgh"[..], res2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2980u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(c)), &(Error(Position(ErrorKind::Many1, c)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2981u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(d)), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2982u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn infinite_many() {
            fn tst(input: &[u8]) -> IResult<&[u8], &[u8]> {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["input: ",
                                                                          "\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match (&input,)
                                                                     {
                                                                     (__arg0,)
                                                                     =>
                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                  ::std::fmt::Debug::fmt)],
                                                                 }));
                Error(Position(ErrorKind::Custom(0), input))
            }
            fn multi0(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    use InputLength;
                    if (i).input_len() == 0 {
                        ::IResult::Done(i, ::std::vec::Vec::new())
                    } else {
                        match tst(i) {
                            ::IResult::Error(_) => {
                                ::IResult::Done(i, ::std::vec::Vec::new())
                            }
                            ::IResult::Incomplete(i) =>
                            ::IResult::Incomplete(i),
                            ::IResult::Done(i1, o1) => {
                                if i1.input_len() == 0 {
                                    ::IResult::Done(i1,
                                                    <[_]>::into_vec(::std::boxed::Box::new([o1])))
                                } else {
                                    let mut res =
                                        ::std::vec::Vec::with_capacity(4);
                                    res.push(o1);
                                    let mut input = i1;
                                    let mut incomplete:
                                            ::std::option::Option<::Needed> =
                                        ::std::option::Option::None;
                                    loop  {
                                        match tst(input) {
                                            ::IResult::Done(i, o) => {
                                                if i.input_len() ==
                                                       input.input_len() {
                                                    break ;
                                                }
                                                res.push(o);
                                                input = i;
                                            }
                                            ::IResult::Error(_) => { break ; }
                                            ::IResult::Incomplete(::Needed::Unknown)
                                            => {
                                                incomplete =
                                                    ::std::option::Option::Some(::Needed::Unknown);
                                                break ;
                                            }
                                            ::IResult::Incomplete(::Needed::Size(i))
                                            => {
                                                incomplete =
                                                    ::std::option::Option::Some(::Needed::Size(i
                                                                                                   +
                                                                                                   (i).input_len()
                                                                                                   -
                                                                                                   input.input_len()));
                                                break ;
                                            }
                                        }
                                        if input.input_len() == 0 { break ; }
                                    }
                                    match incomplete {
                                        ::std::option::Option::Some(i) =>
                                        ::IResult::Incomplete(i),
                                        ::std::option::Option::None =>
                                        ::IResult::Done(input, res),
                                    }
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcdef"[..];
            {
                match (&(multi0(a)), &(Done(a, Vec::new()))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2995u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn multi1(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    use InputLength;
                    match tst(i) {
                        ::IResult::Error(_) =>
                        ::IResult::Error(::Err::Position(::ErrorKind::Many1,
                                                         i)),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, o1) => {
                            if i1.len() == 0 {
                                ::IResult::Done(i1,
                                                <[_]>::into_vec(::std::boxed::Box::new([o1])))
                            } else {
                                let mut res =
                                    ::std::vec::Vec::with_capacity(4);
                                res.push(o1);
                                let mut input = i1;
                                let mut incomplete:
                                        ::std::option::Option<::Needed> =
                                    ::std::option::Option::None;
                                loop  {
                                    if input.input_len() == 0 { break ; }
                                    match tst(input) {
                                        ::IResult::Error(_) => { break ; }
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        => {
                                            incomplete =
                                                ::std::option::Option::Some(::Needed::Unknown);
                                            break ;
                                        }
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        => {
                                            incomplete =
                                                ::std::option::Option::Some(::Needed::Size(i
                                                                                               +
                                                                                               (i).input_len()
                                                                                               -
                                                                                               input.input_len()));
                                            break ;
                                        }
                                        ::IResult::Done(i, o) => {
                                            if i.input_len() ==
                                                   input.input_len() {
                                                break ;
                                            }
                                            res.push(o);
                                            input = i;
                                        }
                                    }
                                }
                                match incomplete {
                                    ::std::option::Option::Some(i) =>
                                    ::IResult::Incomplete(i),
                                    ::std::option::Option::None =>
                                    ::IResult::Done(input, res),
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcdef"[..];
            {
                match (&(multi1(a)), &(Error(Position(ErrorKind::Many1, a))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     2999u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn many_m_n() {
            fn multi(i: &[u8]) -> ::IResult<&[u8], Vec<&[u8]>, u32> {
                {
                    use InputLength;
                    let mut res = ::std::vec::Vec::with_capacity(2);
                    let mut input = i;
                    let mut count: usize = 0;
                    let mut err = false;
                    let mut incomplete: ::std::option::Option<::Needed> =
                        ::std::option::Option::None;
                    loop  {
                        if count == 4 { break  }
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "Abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > input.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &input[0..bytes.len()] ==
                                                    bytes {
                                          ::IResult::Done(&input[bytes.len()..],
                                                          &input[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           input))
                                      };
                                  res
                              } {
                            ::IResult::Done(i, o) => {
                                if i.input_len() == input.input_len() {
                                    break ;
                                }
                                res.push(o);
                                input = i;
                                count += 1;
                            }
                            ::IResult::Error(_) => { err = true; break ; }
                            ::IResult::Incomplete(::Needed::Unknown) => {
                                incomplete =
                                    ::std::option::Option::Some(::Needed::Unknown);
                                break ;
                            }
                            ::IResult::Incomplete(::Needed::Size(i)) => {
                                incomplete =
                                    ::std::option::Option::Some(::Needed::Size(i
                                                                                   +
                                                                                   (i).input_len()
                                                                                   -
                                                                                   input.input_len()));
                                break ;
                            }
                        }
                        if input.input_len() == 0 { break ; }
                    }
                    if count < 2 {
                        if err {
                            ::IResult::Error(::Err::Position(::ErrorKind::ManyMN,
                                                             i))
                        } else {
                            match incomplete {
                                ::std::option::Option::Some(i) =>
                                ::IResult::Incomplete(i),
                                ::std::option::Option::None =>
                                ::IResult::Incomplete(::Needed::Unknown),
                            }
                        }
                    } else {
                        match incomplete {
                            ::std::option::Option::Some(i) =>
                            ::IResult::Incomplete(i),
                            ::std::option::Option::None =>
                            ::IResult::Done(input, res),
                        }
                    }
                }
            }
            let a = &b"Abcdef"[..];
            let b = &b"AbcdAbcdefgh"[..];
            let c = &b"AbcdAbcdAbcdAbcdefgh"[..];
            let d = &b"AbcdAbcdAbcdAbcdAbcdefgh"[..];
            let e = &b"AbcdAb"[..];
            {
                match (&(multi(a)), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3013u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res2 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"Abcd"[..],
                                                        &b"Abcd"[..]]));
            {
                match (&(multi(b)), &(Done(&b"efgh"[..], res2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3015u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res3 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"Abcd"[..],
                                                        &b"Abcd"[..],
                                                        &b"Abcd"[..],
                                                        &b"Abcd"[..]]));
            {
                match (&(multi(c)), &(Done(&b"efgh"[..], res3))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3017u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res4 =
                <[_]>::into_vec(::std::boxed::Box::new([&b"Abcd"[..],
                                                        &b"Abcd"[..],
                                                        &b"Abcd"[..],
                                                        &b"Abcd"[..]]));
            {
                match (&(multi(d)), &(Done(&b"Abcdefgh"[..], res4))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3019u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(multi(e)), &(Incomplete(Needed::Size(8)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3020u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn count() {
            fn counter(input: &[u8]) -> IResult<&[u8], Vec<&[u8]>> {
                let size: usize = 2;
                {
                    let mut input = input;
                    let mut res = ::std::vec::Vec::with_capacity(size);
                    let mut cnt: usize = 0;
                    let mut err = false;
                    loop  {
                        if cnt == size { break  }
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > input.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &input[0..bytes.len()] ==
                                                    bytes {
                                          ::IResult::Done(&input[bytes.len()..],
                                                          &input[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           input))
                                      };
                                  res
                              } {
                            ::IResult::Done(i, o) => {
                                res.push(o);
                                input = i;
                                cnt = cnt + 1;
                            }
                            ::IResult::Error(_) => { err = true; break ; }
                            ::IResult::Incomplete(_) => { break ; }
                        }
                    }
                    if err {
                        ::IResult::Error(::Err::Position(::ErrorKind::Count,
                                                         input))
                    } else if cnt == size {
                        ::IResult::Done(input, res)
                    } else { ::IResult::Incomplete(::Needed::Unknown) }
                }
            }
            let a = b"abcdabcdabcdef";
            let b = b"abcdefgh";
            let res =
                <[_]>::into_vec(::std::boxed::Box::new([&b"abcd"[..],
                                                        &b"abcd"[..]]));
            {
                match (&(counter(&a[..])), &(Done(&b"abcdef"[..], res))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3034u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(counter(&b[..])),
                       &(Error(Position(ErrorKind::Count, &b[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3035u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn count_zero() {
            fn counter(input: &[u8]) -> IResult<&[u8], Vec<&[u8]>> {
                let size: usize = 0;
                {
                    let mut input = input;
                    let mut res = ::std::vec::Vec::with_capacity(size);
                    let mut cnt: usize = 0;
                    let mut err = false;
                    loop  {
                        if cnt == size { break  }
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > input.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &input[0..bytes.len()] ==
                                                    bytes {
                                          ::IResult::Done(&input[bytes.len()..],
                                                          &input[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           input))
                                      };
                                  res
                              } {
                            ::IResult::Done(i, o) => {
                                res.push(o);
                                input = i;
                                cnt = cnt + 1;
                            }
                            ::IResult::Error(_) => { err = true; break ; }
                            ::IResult::Incomplete(_) => { break ; }
                        }
                    }
                    if err {
                        ::IResult::Error(::Err::Position(::ErrorKind::Count,
                                                         input))
                    } else if cnt == size {
                        ::IResult::Done(input, res)
                    } else { ::IResult::Incomplete(::Needed::Unknown) }
                }
            }
            let a = b"abcdabcdabcdef";
            let res: Vec<&[u8]> = Vec::new();
            {
                match (&(counter(&a[..])),
                       &(Done(&b"abcdabcdabcdef"[..], res))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3048u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn count_fixed() {
            fn counter(input: &[u8]) -> IResult<&[u8], [&[u8]; 2], ()> {
                {
                    let mut input = input;
                    let mut res: [&[u8]; 2] =
                        unsafe { [::std::mem::uninitialized(); 2 as usize] };
                    let mut cnt: usize = 0;
                    let mut err = false;
                    loop  {
                        if cnt == 2 { break  }
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > input.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &input[0..bytes.len()] ==
                                                    bytes {
                                          ::IResult::Done(&input[bytes.len()..],
                                                          &input[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           input))
                                      };
                                  res
                              } {
                            ::IResult::Done(i, o) => {
                                res[cnt] = o;
                                input = i;
                                cnt = cnt + 1;
                            }
                            ::IResult::Error(_) => { err = true; break ; }
                            ::IResult::Incomplete(_) => { break ; }
                        }
                    }
                    if err {
                        ::IResult::Error(::Err::Position(::ErrorKind::Count,
                                                         input))
                    } else if cnt == 2 {
                        ::IResult::Done(input, res)
                    } else { ::IResult::Incomplete(::Needed::Unknown) }
                }
            }
            let a = b"abcdabcdabcdef";
            let b = b"abcdefgh";
            let res = [&b"abcd"[..], &b"abcd"[..]];
            {
                match (&(counter(&a[..])), &(Done(&b"abcdef"[..], res))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3062u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(counter(&b[..])),
                       &(Error(Position(ErrorKind::Count, &b[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3063u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        use nom::{le_u16, eof};
        #[allow(dead_code)]
        pub fn compile_count_fixed(input: &[u8]) -> IResult<&[u8], ()> {
            {
                {
                    use InputLength;
                    let res =
                        {
                            #[inline(always)]
                            fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                b.as_bytes()
                            }
                            let expected = "abcd";
                            let bytes = as_bytes(&expected);
                            let res: ::IResult<&[u8], &[u8]> =
                                if bytes.len() > input.len() {
                                    ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                } else if &input[0..bytes.len()] == bytes {
                                    ::IResult::Done(&input[bytes.len()..],
                                                    &input[0..bytes.len()])
                                } else {
                                    ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                     input))
                                };
                            res
                        };
                    match res {
                        ::IResult::Error(e) => ::IResult::Error(e),
                        ::IResult::Incomplete(::Needed::Unknown) =>
                        ::IResult::Incomplete(::Needed::Unknown),
                        ::IResult::Incomplete(::Needed::Size(i)) =>
                        ::IResult::Incomplete(::Needed::Size(0usize + i)),
                        ::IResult::Done(i, _) => {
                            {
                                use InputLength;
                                let res =
                                    {
                                        let mut input = i;
                                        let mut res: [u16; 4] =
                                            unsafe {
                                                [::std::mem::uninitialized();
                                                    4 as usize]
                                            };
                                        let mut cnt: usize = 0;
                                        let mut err = false;
                                        loop  {
                                            if cnt == 4 { break  }
                                            match le_u16(input) {
                                                ::IResult::Done(i, o) => {
                                                    res[cnt] = o;
                                                    input = i;
                                                    cnt = cnt + 1;
                                                }
                                                ::IResult::Error(_) => {
                                                    err = true;
                                                    break ;
                                                }
                                                ::IResult::Incomplete(_) => {
                                                    break ;
                                                }
                                            }
                                        }
                                        if err {
                                            ::IResult::Error(::Err::Position(::ErrorKind::Count,
                                                                             i))
                                        } else if cnt == 4 {
                                            ::IResult::Done(input, res)
                                        } else {
                                            ::IResult::Incomplete(::Needed::Unknown)
                                        }
                                    };
                                match res {
                                    ::IResult::Error(e) =>
                                    ::IResult::Error(e),
                                    ::IResult::Incomplete(::Needed::Unknown)
                                    =>
                                    ::IResult::Incomplete(::Needed::Unknown),
                                    ::IResult::Incomplete(::Needed::Size(i))
                                    =>
                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                             +
                                                                             ((input).input_len()
                                                                                  -
                                                                                  i.input_len())
                                                                             +
                                                                             i)),
                                    ::IResult::Done(i, _) => {
                                        {
                                            let res = eof(i);
                                            match res {
                                                ::IResult::Error(e) =>
                                                ::IResult::Error(e),
                                                ::IResult::Incomplete(::Needed::Unknown)
                                                =>
                                                ::IResult::Incomplete(::Needed::Unknown),
                                                ::IResult::Incomplete(::Needed::Size(i))
                                                =>
                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                         +
                                                                                         ((input).input_len()
                                                                                              -
                                                                                              i.input_len())
                                                                                         +
                                                                                         ((i).input_len()
                                                                                              -
                                                                                              i.input_len())
                                                                                         +
                                                                                         i)),
                                                ::IResult::Done(i, _) => {
                                                    ::IResult::Done(i,
                                                                    (|| { ()
                                                                    })())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[test]
        pub fn count_fixed_no_type() {
            fn counter(input: &[u8]) -> IResult<&[u8], [&[u8]; 2], ()> {
                {
                    let mut input = input;
                    let mut res: [&[u8]; 2] =
                        unsafe { [::std::mem::uninitialized(); 2 as usize] };
                    let mut cnt: usize = 0;
                    let mut err = false;
                    loop  {
                        if cnt == 2 { break  }
                        match {
                                  #[inline(always)]
                                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                                      b.as_bytes()
                                  }
                                  let expected = "abcd";
                                  let bytes = as_bytes(&expected);
                                  let res: ::IResult<&[u8], &[u8]> =
                                      if bytes.len() > input.len() {
                                          ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                      } else if &input[0..bytes.len()] ==
                                                    bytes {
                                          ::IResult::Done(&input[bytes.len()..],
                                                          &input[0..bytes.len()])
                                      } else {
                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                           input))
                                      };
                                  res
                              } {
                            ::IResult::Done(i, o) => {
                                res[cnt] = o;
                                input = i;
                                cnt = cnt + 1;
                            }
                            ::IResult::Error(_) => { err = true; break ; }
                            ::IResult::Incomplete(_) => { break ; }
                        }
                    }
                    if err {
                        ::IResult::Error(::Err::Position(::ErrorKind::Count,
                                                         input))
                    } else if cnt == 2 {
                        ::IResult::Done(input, res)
                    } else { ::IResult::Incomplete(::Needed::Unknown) }
                }
            }
            let a = b"abcdabcdabcdef";
            let b = b"abcdefgh";
            let res = [&b"abcd"[..], &b"abcd"[..]];
            {
                match (&(counter(&a[..])), &(Done(&b"abcdef"[..], res))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3088u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(counter(&b[..])),
                       &(Error(Position(ErrorKind::Count, &b[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3089u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        use nom::{be_u8, be_u16};
        #[test]
        pub fn length_value_test() {
            fn tst1(i: &[u8]) -> ::IResult<&[u8], Vec<u16>, u32> {
                {
                    match be_u8(i) {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, nb) => {
                            let length_token = i.len() - i1.len();
                            let mut input = i1;
                            let mut res = ::std::vec::Vec::new();
                            let mut err = false;
                            let mut inc = ::Needed::Unknown;
                            loop  {
                                if res.len() == (nb as usize) { break ; }
                                match be_u16(input) {
                                    ::IResult::Done(i2, o2) => {
                                        res.push(o2);
                                        input = i2;
                                    }
                                    ::IResult::Error(_) => { err = true; }
                                    ::IResult::Incomplete(a) => {
                                        inc = a;
                                        break ;
                                    }
                                }
                            }
                            if err {
                                ::IResult::Error(::Err::Position(::ErrorKind::LengthValue,
                                                                 i))
                            } else if res.len() < (nb as usize) {
                                match inc {
                                    ::Needed::Unknown =>
                                    ::IResult::Incomplete(::Needed::Unknown),
                                    ::Needed::Size(length) =>
                                    ::IResult::Incomplete(::Needed::Size(length_token
                                                                             +
                                                                             (nb
                                                                                  as
                                                                                  usize)
                                                                                 *
                                                                                 length)),
                                }
                            } else { ::IResult::Done(input, res) }
                        }
                    }
                }
            }
            fn tst2(i: &[u8]) -> ::IResult<&[u8], Vec<u16>, u32> {
                {
                    match be_u8(i) {
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                        ::IResult::Done(i1, nb) => {
                            let length_token = i.len() - i1.len();
                            let mut input = i1;
                            let mut res = ::std::vec::Vec::new();
                            let mut err = false;
                            let mut inc = ::Needed::Unknown;
                            loop  {
                                if res.len() == (nb as usize) { break ; }
                                match be_u16(input) {
                                    ::IResult::Done(i2, o2) => {
                                        res.push(o2);
                                        input = i2;
                                    }
                                    ::IResult::Error(_) => { err = true; }
                                    ::IResult::Incomplete(a) => {
                                        inc = a;
                                        break ;
                                    }
                                }
                            }
                            if err {
                                ::IResult::Error(::Err::Position(::ErrorKind::LengthValue,
                                                                 i))
                            } else if res.len() < (nb as usize) {
                                match inc {
                                    ::Needed::Unknown =>
                                    ::IResult::Incomplete(::Needed::Unknown),
                                    ::Needed::Size(_) =>
                                    ::IResult::Incomplete(::Needed::Size(length_token
                                                                             +
                                                                             (nb
                                                                                  as
                                                                                  usize)
                                                                                 *
                                                                                 2)),
                                }
                            } else { ::IResult::Done(input, res) }
                        }
                    }
                }
            }
            let i1 = <[_]>::into_vec(::std::boxed::Box::new([0, 5, 6]));
            let i2 = <[_]>::into_vec(::std::boxed::Box::new([1, 5, 6, 3]));
            let i3 = <[_]>::into_vec(::std::boxed::Box::new([2, 5, 6, 3]));
            let i4 =
                <[_]>::into_vec(::std::boxed::Box::new([2, 5, 6, 3, 4, 5,
                                                        7]));
            let i5 =
                <[_]>::into_vec(::std::boxed::Box::new([3, 5, 6, 3, 4, 5]));
            let r1: Vec<u16> = Vec::new();
            let r2: Vec<u16> =
                <[_]>::into_vec(::std::boxed::Box::new([1286]));
            let r4: Vec<u16> =
                <[_]>::into_vec(::std::boxed::Box::new([1286, 772]));
            {
                match (&(tst1(&i1)), &(IResult::Done(&i1[1..], r1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3107u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst1(&i2)), &(IResult::Done(&i2[3..], r2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3108u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst1(&i3)), &(IResult::Incomplete(Needed::Size(5))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3109u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst1(&i4)), &(IResult::Done(&i4[5..], r4))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3110u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst1(&i5)), &(IResult::Incomplete(Needed::Size(7))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3111u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r6: Vec<u16> = Vec::new();
            let r7: Vec<u16> =
                <[_]>::into_vec(::std::boxed::Box::new([1286]));
            let r9: Vec<u16> =
                <[_]>::into_vec(::std::boxed::Box::new([1286, 772]));
            {
                match (&(tst2(&i1)), &(IResult::Done(&i1[1..], r6))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3116u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst2(&i2)), &(IResult::Done(&i2[3..], r7))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3117u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst2(&i3)), &(IResult::Incomplete(Needed::Size(5))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3118u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst2(&i4)), &(IResult::Done(&i4[5..], r9))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3119u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tst1(&i5)), &(IResult::Incomplete(Needed::Size(7))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3120u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn chain_incomplete() {
            let res =
                {
                    {
                        use InputLength;
                        let res =
                            {
                                let cnt = 4 as usize;
                                let res: ::IResult<&[u8], &[u8]> =
                                    if &b"abcdefgh"[..].len() < cnt {
                                        ::IResult::Incomplete(::Needed::Size(cnt))
                                    } else {
                                        ::IResult::Done(&&b"abcdefgh"[..][cnt..],
                                                        &&b"abcdefgh"[..][0..cnt])
                                    };
                                res
                            };
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, o) => {
                                let a = o;
                                {
                                    let res =
                                        {
                                            let cnt = 8 as usize;
                                            let res: ::IResult<&[u8], &[u8]> =
                                                if i.len() < cnt {
                                                    ::IResult::Incomplete(::Needed::Size(cnt))
                                                } else {
                                                    ::IResult::Done(&i[cnt..],
                                                                    &i[0..cnt])
                                                };
                                            res
                                        };
                                    match res {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 ((&b"abcdefgh"[..]).input_len()
                                                                                      -
                                                                                      i.input_len())
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, o) => {
                                            let b = o;
                                            ::IResult::Done(i,
                                                            (|| { (a, b) })())
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            {
                match (&(res), &(IResult::Incomplete(Needed::Size(12)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3131u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn tuple_test() {
            fn tpl(i: &[u8]) -> ::IResult<&[u8], (u16, &[u8], &[u8]), u32> {
                {
                    {
                        use InputLength;
                        match be_u16(i) {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, o) => {
                                {
                                    use InputLength;
                                    match {
                                              let cnt = 3 as usize;
                                              let res:
                                                      ::IResult<&[u8],
                                                                &[u8]> =
                                                  if i.len() < cnt {
                                                      ::IResult::Incomplete(::Needed::Size(cnt))
                                                  } else {
                                                      ::IResult::Done(&i[cnt..],
                                                                      &i[0..cnt])
                                                  };
                                              res
                                          } {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 ((i).input_len()
                                                                                      -
                                                                                      i.input_len())
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, o) => {
                                            {
                                                use InputLength;
                                                match {
                                                          #[inline(always)]
                                                          fn as_bytes<T: ::AsBytes>(b:
                                                                                        &T)
                                                           -> &[u8] {
                                                              b.as_bytes()
                                                          }
                                                          let expected = "fg";
                                                          let bytes =
                                                              as_bytes(&expected);
                                                          let res:
                                                                  ::IResult<&[u8],
                                                                            &[u8]> =
                                                              if bytes.len() >
                                                                     i.len() {
                                                                  ::IResult::Incomplete(::Needed::Size(bytes.len()))
                                                              } else if &i[0..bytes.len()]
                                                                            ==
                                                                            bytes
                                                               {
                                                                  ::IResult::Done(&i[bytes.len()..],
                                                                                  &i[0..bytes.len()])
                                                              } else {
                                                                  ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                   i))
                                                              };
                                                          res
                                                      } {
                                                    ::IResult::Error(e) =>
                                                    ::IResult::Error(e),
                                                    ::IResult::Incomplete(::Needed::Unknown)
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Unknown),
                                                    ::IResult::Incomplete(::Needed::Size(i))
                                                    =>
                                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  i.input_len())
                                                                                             +
                                                                                             ((i).input_len()
                                                                                                  -
                                                                                                  i.input_len())
                                                                                             +
                                                                                             i)),
                                                    ::IResult::Done(i, o) => {
                                                        ::IResult::Done(i,
                                                                        (o, o,
                                                                         o))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                match (&(tpl(&b"abcdefgh"[..])),
                       &(Done(&b"h"[..],
                              (24930u16, &b"cde"[..], &b"fg"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3144u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tpl(&b"abcd"[..])), &(Incomplete(Needed::Size(5)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3145u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(tpl(&b"abcde"[..])), &(Incomplete(Needed::Size(7))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3146u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let input = &b"abcdejk"[..];
            {
                match (&(tpl(input)),
                       &(Error(Position(ErrorKind::Tag, &input[5..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/macros.rs",
                                                                     3148u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::pub_named_test;
            pub use super::apply_test;
            pub use super::chain2;
            pub use super::nested_chain;
            pub use super::chain_mut;
            pub use super::chain_opt;
            pub use super::err;
            pub use super::add_err;
            pub use super::complete;
            pub use super::alt;
            pub use super::alt_incomplete;
            pub use super::alt_complete;
            pub use super::switch;
            pub use super::opt;
            pub use super::opt_res;
            pub use super::cond;
            pub use super::cond_wrapping;
            pub use super::peek;
            pub use super::pair;
            pub use super::separated_pair;
            pub use super::preceded;
            pub use super::terminated;
            pub use super::delimited;
            pub use super::separated_list;
            pub use super::separated_nonempty_list;
            pub use super::many0;
            pub use super::many1;
            pub use super::infinite_many;
            pub use super::many_m_n;
            pub use super::count;
            pub use super::count_zero;
            pub use super::count_fixed;
            pub use super::count_fixed_no_type;
            pub use super::length_value_test;
            pub use super::chain_incomplete;
            pub use super::tuple_test;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[macro_use]
mod methods {
    //! Macro combinators
    //!
    //! Macros are used to make combination easier,
    //! since they often do not depend on the type
    //! of the data they manipulate or return.
    //!
    //! There is a trick to make them easier to assemble,
    //! combinators are defined like this:
    //!
    //! ```ignore
    //! macro_rules! tag (
    //!   ($i:expr, $inp: expr) => (
    //!     {
    //!       ...
    //!     }
    //!   );
    //! );
    //! ```
    //!
    //! But when used as methods in other combinators, are used
    //! like this:
    //!
    //! ```ignore
    //! method!(my_function<&Parser>,self, [(self, self_ref_cell)] tag!("abcd"));
    //! ```
    //!
    //! Internally, other combinators will rewrite
    //! that call to pass the input as first argument:
    //!
    //! ```ignore
    //! macro_rules! method (
    //!   ($name:ident<$a:ty>, $self_:ident, [ $( ($stt:ident, $cell:ident) ),* ], $submac:ident!( $($args:tt)* )) => (
    //!     fn $name( $self_: $a, i: &[u8] ) -> $crate::IResult<&[u8], &[u8]> {
    //!       use std::cell::RefCell;
    //!       $(let $cell = RefCell::new($stt)),*;
    //!       $submac!(i, $($args)*)
    //!     }
    //!   );
    //! );
    //! ```
    //! 
    //! The `method!` macro is similar to the `named!` macro in the macros module.
    //! While `named!` will create a parser function, `method!` will create a parser
    //! method on the struct it is defined in.
    //!
    //! Compared to the `named!` macro there are a few differences in how they are
    //! invodked. A `method!` invocation always has to have the type of `self`
    //! declared:
    //! ```ignore
    //! //                  -`self`'s type-
    //! method!(method_name<  &Parser<'a> >, ...);
    //! ```
    //! `self`'s type always comes first except in the `method!` macro that takes
    //! a lifetime parameter.
    //! ```ignore
    //! //                  lifetime | `self`'s type |   in/out types
    //! method!(method_name<lifetime , &Parser<'a>   , &'a str, &'a str>, ...);
    //!```
    //! The next difference is you have to input the self struct. Due to Rust's
    //! macro hygiene the macro can't declare it on it's own.
    //! ```ignore
    //! //                                                 -self-
    //! method!(method_name<&Parser<'a>, &'a str, &'a str>, self, ...);
    //! ```
    //! When making a parsing struct with parsing methods, due to the static borrow
    //! checker,calling any parsing methods on self (or any other parsing struct)
    //! will cause self to be borrowed for the entire method, even in lines before
    //! the borrow happened. To get around this restriction all parsing structs
    //! that will have methods called on them will be wrapped in `RefCell`s and
    //! and methods will be called on a borrowed (mutable) reference of the
    //! `RefCell`. This allows for more intuitive and usable borrow lifetimes
    //! (though it does come with a slight performance penalty as Rust's runtime
    //! borrow-checker is used instead of the compile-time borrow checker).
    //!
    //! The `method!` creator needs specify the structs they want wrapped in
    //! `RefCell`s for later calling as well as the name of the wrapping `RefCell`.
    //! ```ignore
    //! 
    //! method!(method_name<&Parser<'a>, &'a str, &'a str>, self,
    //! // -struct, wrapped struct's name-    -struct,     wrapped struct's name-
    //!   [(self,     ref_cell_self     ), (other_parser,      ref_cell_other  )], ...);
    //! ```
    //! Again, due to macro hygiene the `method!` macro can't auto-generate the
    //! the wrapper's names, so you need to supply them yourself, but this is okay
    //! because you'll need to use them later.
    //! 
    //! To call a wrapped struct you need to use the `call_rc!` macro. For example:
    //! ```ignore
    //! struct<'a> Parser<'a> {
    //!   parsed: &'a str,
    //! }
    //! impl<'a> Parser<'a> {
    //!   // Constructor omitted for brevity
    //!   method!(take4<&Parser<'a>, &'a str, &'a str>, self, take!(4));
    //!   method!(caller<&Parser<'a>, &'a str, &'a str>, self, [(self, rcs)]), call_rc!(rcs.take4));
    //! }
    //! ```
    //! Notice in the definition of `take4` no structs and wrapped names are specified
    //! because they aren't needed since it won't be calling any methods. The `caller`
    //! method however does call a method on the `self` struct so it specifies `self`
    //! as a struct to be wrapped and `rcs` as the wrapped name. Later, we make use of
    //! the `call_rc!` macro to call the `take4` method on the wrapped `self` struct, 
    //! `rcs`.
    //! 
    //! More complicated combinations still mostly look the same as their `named!`
    //! counterparts:
    //! ```ignore
    //!    method!(pub simple_chain<&mut Parser<'a>, &'a str, &'a str>, self, [(self, rcs)],
    //!      chain!(
    //!             call_rc!(rcs.tag_abc)      ~
    //!             call_rc!(rcs.tag_def)      ~
    //!             call_rc!(rcs.tag_ghi)      ~
    //!       last: call_rc!(rcs.simple_peek)  ,
    //!        ||{rcs.borrow_mut().parsed = last; last}
    //!      )
    //!    );
    //! ```
    //!
    //! The four additions to method definitions remeber are:
    //! 1. Specify `self`'s type
    //! 2. Pass `self` to the macro
    //! 3. Specify structs that need to be wrapped and the name of their wrapper
    //! 4. Call parser methods using the `call_rc!` macro.
    #[prelude_import]
    use std::prelude::v1::*;
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use internal::IResult::*;
        struct Parser<'a> {
            bcd: &'a str,
        }
        impl <'a> Parser<'a> {
            pub fn new() -> Parser<'a> { Parser{bcd: "",} }
            fn tag_abc(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                {
                    let res: ::IResult<_, _> =
                        if "\u{e1}\u{3b2}\u{e7}".len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size("\u{e1}\u{3b2}\u{e7}".len()))
                        } else if (i).starts_with("\u{e1}\u{3b2}\u{e7}") {
                            ::IResult::Done(&i["\u{e1}\u{3b2}\u{e7}".len()..],
                                            &i[0.."\u{e1}\u{3b2}\u{e7}".len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                             i))
                        };
                    res
                }
            }
            fn tag_bcd(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                {
                    let res: ::IResult<_, _> =
                        if "\u{3b2}\u{e7}\u{3b4}".len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size("\u{3b2}\u{e7}\u{3b4}".len()))
                        } else if (i).starts_with("\u{3b2}\u{e7}\u{3b4}") {
                            ::IResult::Done(&i["\u{3b2}\u{e7}\u{3b4}".len()..],
                                            &i[0.."\u{3b2}\u{e7}\u{3b4}".len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                             i))
                        };
                    res
                }
            }
            pub fn tag_hij(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                {
                    let res: ::IResult<_, _> =
                        if "\u{3bb}\u{ef}J".len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size("\u{3bb}\u{ef}J".len()))
                        } else if (i).starts_with("\u{3bb}\u{ef}J") {
                            ::IResult::Done(&i["\u{3bb}\u{ef}J".len()..],
                                            &i[0.."\u{3bb}\u{ef}J".len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                             i))
                        };
                    res
                }
            }
            pub fn tag_ijk(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                {
                    let res: ::IResult<_, _> =
                        if "\u{ef}J\u{199}".len() > i.len() {
                            ::IResult::Incomplete(::Needed::Size("\u{ef}J\u{199}".len()))
                        } else if (i).starts_with("\u{ef}J\u{199}") {
                            ::IResult::Done(&i["\u{ef}J\u{199}".len()..],
                                            &i[0.."\u{ef}J\u{199}".len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                             i))
                        };
                    res
                }
            }
            fn take3(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                {
                    let cnt = 3 as usize;
                    let res: ::IResult<_, _> =
                        if i.chars().count() < cnt {
                            ::IResult::Incomplete(::Needed::Size(cnt))
                        } else {
                            let mut offset = i.len();
                            let mut count = 0;
                            for (o, _) in i.char_indices() {
                                if count == cnt { offset = o; break ; }
                                count += 1;
                            }
                            ::IResult::Done(&i[offset..], &i[..offset])
                        };
                    res
                }
            }
            pub fn simple_call(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                use std::cell::RefCell;
                let ref_cell_self = RefCell::new(self);
                ref_cell_self.borrow_mut().tag_abc(i)
            }
            pub fn simple_peek(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                use std::cell::RefCell;
                let rcs = RefCell::new(self);
                {
                    match rcs.borrow_mut().take3(i) {
                        ::IResult::Done(_, o) => ::IResult::Done(i, o),
                        ::IResult::Error(a) => ::IResult::Error(a),
                        ::IResult::Incomplete(i) => ::IResult::Incomplete(i),
                    }
                }
            }
            pub fn simple_chain(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                use std::cell::RefCell;
                let rcs = RefCell::new(self);
                {
                    {
                        use InputLength;
                        let res = rcs.borrow_mut().tag_bcd(i);
                        match res {
                            ::IResult::Error(e) => ::IResult::Error(e),
                            ::IResult::Incomplete(::Needed::Unknown) =>
                            ::IResult::Incomplete(::Needed::Unknown),
                            ::IResult::Incomplete(::Needed::Size(i)) =>
                            ::IResult::Incomplete(::Needed::Size(0usize + i)),
                            ::IResult::Done(i, o) => {
                                let bcd = o;
                                {
                                    let res = rcs.borrow_mut().simple_peek(i);
                                    match res {
                                        ::IResult::Error(e) =>
                                        ::IResult::Error(e),
                                        ::IResult::Incomplete(::Needed::Unknown)
                                        =>
                                        ::IResult::Incomplete(::Needed::Unknown),
                                        ::IResult::Incomplete(::Needed::Size(i))
                                        =>
                                        ::IResult::Incomplete(::Needed::Size(0usize
                                                                                 +
                                                                                 ((i).input_len()
                                                                                      -
                                                                                      i.input_len())
                                                                                 +
                                                                                 i)),
                                        ::IResult::Done(i, o) => {
                                            let last = o;
                                            ::IResult::Done(i,
                                                            (|| {
                                                                rcs.borrow_mut().bcd
                                                                    = bcd;
                                                                last })())
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            fn tag_stuff(self: &mut Parser<'a>, input: &'a str,
                         something: &'a str) -> ::IResult<&'a str, &'a str> {
                use std::cell::RefCell;
                let rcs = RefCell::new(self);
                let mut borrow = rcs.borrow_mut();
                borrow.bcd = something;
                borrow.tag_abc(input)
            }
            fn use_apply(self: &mut Parser<'a>, i: &'a str)
             -> ::IResult<&'a str, &'a str> {
                use std::cell::RefCell;
                let rcs = RefCell::new(self);
                {
                    let res =
                        rcs.borrow_mut().tag_stuff(i, "\u{3b2}\u{e7}\u{3b4}");
                    res
                }
            }
        }
        #[test]
        pub fn test_method_call_abc() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{e1}\u{3b2}\u{e7}\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            const CONSUMED: &'static str = "\u{e1}\u{3b2}\u{e7}";
            const LEFTOVER: &'static str =
                "\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            match p.tag_abc(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_abc` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 310u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_abc` doesnt return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 311u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.tag_abc` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         314u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_method_call_bcd() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{3b2}\u{e7}\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            const CONSUMED: &'static str = "\u{3b2}\u{e7}\u{3b4}";
            const LEFTOVER: &'static str =
                "\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            match p.tag_bcd(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_bcd` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 325u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_bcd` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 326u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.tag_bcd` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         329u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_method_call_hij() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{3bb}\u{ef}J\u{199}\u{2113}\u{20a5}\u{f1}\u{f4}\u{1a5}9\u{159}\u{1a8}";
            const CONSUMED: &'static str = "\u{3bb}\u{ef}J";
            const LEFTOVER: &'static str =
                "\u{199}\u{2113}\u{20a5}\u{f1}\u{f4}\u{1a5}9\u{159}\u{1a8}";
            match p.tag_hij(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_hij` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 340u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_hij` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 341u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.tag_hij` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         344u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_method_call_ijk() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{ef}J\u{199}\u{2113}\u{20a5}\u{f1}\u{f4}\u{1a5}9\u{159}\u{1a8}";
            const CONSUMED: &'static str = "\u{ef}J\u{199}";
            const LEFTOVER: &'static str =
                "\u{2113}\u{20a5}\u{f1}\u{f4}\u{1a5}9\u{159}\u{1a8}";
            match p.tag_ijk(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_ijk` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 356u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.tag_ijk` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 357u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.tag_ijk` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         360u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_method_call_rc() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{e1}\u{3b2}\u{e7}\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            const CONSUMED: &'static str = "\u{e1}\u{3b2}\u{e7}";
            const LEFTOVER: &'static str =
                "\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            match p.simple_call(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.simple_call` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 371u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.simple_call` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 372u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.simple_call` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         375u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_apply_rf() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{e1}\u{3b2}\u{e7}\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            const CONSUMED: &'static str = "\u{e1}\u{3b2}\u{e7}";
            const LEFTOVER: &'static str =
                "\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            match p.use_apply(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.use_apply` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 387u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.use_apply` doesn\'t return the string it was supposed to on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&LEFTOVER,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 388u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(p.bcd == "\u{3b2}\u{e7}\u{3b4}") {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser.use_apply didn\'t modify the parser field correctly: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&p.bcd,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 390u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.use_apply` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         392u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_method_call_peek() {
            let mut p = Parser::new();
            const INPUT: &'static str =
                "\u{436}\u{a5}\u{1ba}\u{e1}\u{3b2}\u{e7}\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}";
            const CONSUMED: &'static str = "\u{436}\u{a5}\u{1ba}";
            match p.simple_peek(INPUT) {
                Done(extra, output) => {
                    if !(extra == INPUT) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.simple_peek` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 403u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.simple_peek` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 404u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.simple_peek` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         407u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        #[test]
        pub fn test_method_call_chain() {
            let mut p = Parser::new();
            let INPUT: &str =
                "\u{3b2}\u{e7}\u{3b4}\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}\u{2113}";
            let LEFTOVER: &str =
                "\u{3b4}\u{e8}\u{192}\u{3f1}\u{3bb}\u{ef}J\u{199}\u{2113}";
            let OUTPUT: &str = "\u{3b4}\u{e8}\u{192}";
            match p.simple_chain(INPUT) {
                Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.simple_chain` consumed leftover input. Leftover: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 419u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == OUTPUT) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["`Parser.simple_chain` doesn\'t return the string it was supposed to on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&LEFTOVER,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 420u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(p.bcd == "\u{3b2}\u{e7}\u{3b4}") {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser.simple_chain didn\'t modify the parser field correctly: "];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&p.bcd,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/methods.rs",
                                                                 422u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["`Parser.simple_chain` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/methods.rs",
                                                         424u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::test_method_call_abc;
            pub use super::test_method_call_bcd;
            pub use super::test_method_call_hij;
            pub use super::test_method_call_ijk;
            pub use super::test_method_call_rc;
            pub use super::test_apply_rf;
            pub use super::test_method_call_peek;
            pub use super::test_method_call_chain;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[macro_use]
mod bytes {
    //! Byte level parsers and combinators
    //!
    #[prelude_import]
    use std::prelude::v1::*;
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use internal::Needed;
        use internal::IResult::*;
        use internal::Err::*;
        use util::ErrorKind;
        use nom::{alpha, digit, hex_digit, alphanumeric, space, multispace};
        #[test]
        pub fn is_a() {
            fn a_or_b(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = &b"ab"[..];
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            match i.iter().position(|c| {
                                                    for &i in bytes.iter() {
                                                        if *c == i {
                                                            return false
                                                        }
                                                    } true }) {
                                Some(0) =>
                                ::IResult::Error(::Err::Position(::ErrorKind::IsA,
                                                                 i)),
                                Some(n) => {
                                    let res: ::IResult<_, _> =
                                        ::IResult::Done(&i[n..], &i[..n]);
                                    res
                                }
                                None => { ::IResult::Done(&b""[..], i) }
                            };
                        res
                    }
                }
            }
            let a = &b"abcd"[..];
            {
                match (&(a_or_b(a)), &(Done(&b"cd"[..], &b"ab"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     779u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b = &b"bcde"[..];
            {
                match (&(a_or_b(b)), &(Done(&b"cde"[..], &b"b"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     782u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let c = &b"cdef"[..];
            {
                match (&(a_or_b(c)), &(Error(Position(ErrorKind::IsA, c)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     785u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let d = &b"bacdef"[..];
            {
                match (&(a_or_b(d)), &(Done(&b"cdef"[..], &b"ba"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     788u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn is_not() {
            fn a_or_b(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = &b"ab"[..];
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            match i.iter().position(|c| {
                                                    for &i in bytes.iter() {
                                                        if *c == i {
                                                            return true
                                                        }
                                                    } false }) {
                                Some(0) =>
                                ::IResult::Error(::Err::Position(::ErrorKind::IsNot,
                                                                 i)),
                                Some(n) => {
                                    let res =
                                        ::IResult::Done(&i[n..], &i[..n]);
                                    res
                                }
                                None => { ::IResult::Done(&b""[..], i) }
                            };
                        res
                    }
                }
            }
            let a = &b"cdab"[..];
            {
                match (&(a_or_b(a)), &(Done(&b"ab"[..], &b"cd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     796u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b = &b"cbde"[..];
            {
                match (&(a_or_b(b)), &(Done(&b"bde"[..], &b"c"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     799u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let c = &b"abab"[..];
            {
                match (&(a_or_b(c)), &(Error(Position(ErrorKind::IsNot, c))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     802u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let d = &b"cdefba"[..];
            {
                match (&(a_or_b(d)), &(Done(&b"ba"[..], &b"cdef"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     805u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let e = &b"e"[..];
            {
                match (&(a_or_b(e)), &(Done(&b""[..], &b"e"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     808u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let f = &b"fghi"[..];
            {
                match (&(a_or_b(f)), &(Done(&b""[..], &b"fghi"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     811u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn escaping() {
            fn esc(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    {
                        {
                            let cl = || {
                                use HexDisplay; let mut index = 0;
                                while index < i.len() {
                                    if let ::IResult::Done(i, _) =
                                           alpha(&i[index..]) {
                                        if i.is_empty() {
                                            return ::IResult::Done(&b""[..],
                                                                   i)
                                        } else { index = i.offset(i); }
                                    } else if i[index] == ('\\' as u8) {
                                        if index + 1 >= i.len() {
                                            return ::IResult::Error(::Err::Position(::ErrorKind::Escaped,
                                                                                    &i[index..]));
                                        } else {
                                            match {
                                                      let res:
                                                              ::IResult<_,
                                                                        _> =
                                                          match &i[index +
                                                                       1..].iter().position(|c|
                                                                                                {
                                                                                            for &i
                                                                                                in
                                                                                                &b"\"n\\"[..].iter()
                                                                                                {
                                                                                                if *c
                                                                                                       ==
                                                                                                       i
                                                                                                   {
                                                                                                    return false
                                                                                                }
                                                                                            }
                                                                                            true
                                                                                        })
                                                              {
                                                              Some(0) =>
                                                              ::IResult::Error(::Err::Position(::ErrorKind::IsA,
                                                                                               &i[index
                                                                                                      +
                                                                                                      1..])),
                                                              Some(n) => {
                                                                  let res:
                                                                          ::IResult<_,
                                                                                    _> =
                                                                      ::IResult::Done(&&i[index
                                                                                              +
                                                                                              1..][n..],
                                                                                      &&i[index
                                                                                              +
                                                                                              1..][..n]);
                                                                  res
                                                              }
                                                              None => {
                                                                  ::IResult::Done(&b""[..],
                                                                                  &i[index
                                                                                         +
                                                                                         1..])
                                                              }
                                                          };
                                                      res
                                                  } {
                                                ::IResult::Done(i, _) => {
                                                    if i.is_empty() {
                                                        return ::IResult::Done(&b""[..],
                                                                               i)
                                                    } else {
                                                        index = i.offset(i);
                                                    }
                                                }
                                                ::IResult::Incomplete(i) =>
                                                return ::IResult::Incomplete(i),
                                                ::IResult::Error(e) =>
                                                return ::IResult::Error(e),
                                            }
                                        }
                                    } else {
                                        if index == 0 {
                                            return ::IResult::Error(::Err::Position(::ErrorKind::Escaped,
                                                                                    &i[index..]))
                                        } else {
                                            return ::IResult::Done(&i[index..],
                                                                   &i[..index])
                                        }
                                    }
                                } ::IResult::Done(&i[index..], &i[..index]) };
                            match cl() {
                                ::IResult::Incomplete(x) =>
                                ::IResult::Incomplete(x),
                                ::IResult::Done(i, o) =>
                                ::IResult::Done(i, o),
                                ::IResult::Error(e) => {
                                    return ::IResult::Error(::Err::NodePosition(::ErrorKind::Escaped,
                                                                                i,
                                                                                Box::new(e)))
                                }
                            }
                        }
                    }
                }
            }
            {
                match (&(esc(&b"abcd"[..])), &(Done(&b""[..], &b"abcd"[..])))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     817u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"ab\\\"cd"[..])),
                       &(Done(&b""[..], &b"ab\\\"cd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     818u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"\\\"abcd"[..])),
                       &(Done(&b""[..], &b"\\\"abcd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     819u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"\\n"[..])), &(Done(&b""[..], &b"\\n"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     820u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"ab\\\"12"[..])),
                       &(Done(&b"12"[..], &b"ab\\\""[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     821u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"AB\\"[..])),
                       &(Error(NodePosition(ErrorKind::Escaped, &b"AB\\"[..],
                                            Box::new(Position(ErrorKind::Escaped,
                                                              &b"\\"[..]))))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     822u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"AB\\A"[..])),
                       &(Error(NodePosition(ErrorKind::Escaped, &b"AB\\A"[..],
                                            Box::new(Position(ErrorKind::IsA,
                                                              &b"A"[..]))))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     823u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        fn to_s(i: Vec<u8>) -> String {
            String::from_utf8_lossy(&i).into_owned()
        }
        #[test]
        pub fn escape_transform() {
            use std::str;
            fn esc<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], String, u32> {
                {
                    match {
                              {
                                  let cl = || {
                                      use HexDisplay; let mut index = 0;
                                      let mut res = Vec::new();
                                      while index < i.len() {
                                          if let ::IResult::Done(i, o) =
                                                 alpha(&i[index..]) {
                                              res.extend(o.iter().cloned());
                                              if i.is_empty() {
                                                  return ::IResult::Done(&b""[..],
                                                                         res)
                                              } else { index = i.offset(i); }
                                          } else if i[index] == ('\\' as u8) {
                                              if index + 1 >= i.len() {
                                                  return ::IResult::Error(::Err::Position(::ErrorKind::EscapedTransform,
                                                                                          &i[index..]));
                                              } else {
                                                  match {
                                                            {
                                                                match {
                                                                          #[inline(always)]
                                                                          fn as_bytes<T: ::AsBytes>(b:
                                                                                                        &T)
                                                                           ->
                                                                               &[u8] {
                                                                              b.as_bytes()
                                                                          }
                                                                          let expected =
                                                                              "\\";
                                                                          let bytes =
                                                                              as_bytes(&expected);
                                                                          {
                                                                              use std::cmp::min;
                                                                              let len =
                                                                                  &i[index
                                                                                         +
                                                                                         1..].len();
                                                                              let blen =
                                                                                  bytes.len();
                                                                              let m =
                                                                                  min(len,
                                                                                      blen);
                                                                              let reduced =
                                                                                  &&i[index
                                                                                          +
                                                                                          1..][..m];
                                                                              let b =
                                                                                  &bytes[..m];
                                                                              let res:
                                                                                      ::IResult<_,
                                                                                                _> =
                                                                                  if reduced
                                                                                         !=
                                                                                         b
                                                                                     {
                                                                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                       &i[index
                                                                                                                              +
                                                                                                                              1..]))
                                                                                  } else if m
                                                                                                <
                                                                                                blen
                                                                                   {
                                                                                      ::IResult::Incomplete(::Needed::Size(blen))
                                                                                  } else {
                                                                                      ::IResult::Done(&&i[index
                                                                                                              +
                                                                                                              1..][blen..],
                                                                                                      reduced)
                                                                                  };
                                                                              res
                                                                          }
                                                                      } {
                                                                    ::IResult::Done(i,
                                                                                    o)
                                                                    =>
                                                                    ::IResult::Done(i,
                                                                                    (|_|
                                                                                         &b"\\"[..])(o)),
                                                                    ::IResult::Incomplete(x)
                                                                    =>
                                                                    ::IResult::Incomplete(x),
                                                                    ::IResult::Error(_)
                                                                    => {
                                                                        {
                                                                            match {
                                                                                      #[inline(always)]
                                                                                      fn as_bytes<T: ::AsBytes>(b:
                                                                                                                    &T)
                                                                                       ->
                                                                                           &[u8] {
                                                                                          b.as_bytes()
                                                                                      }
                                                                                      let expected =
                                                                                          "\"";
                                                                                      let bytes =
                                                                                          as_bytes(&expected);
                                                                                      {
                                                                                          use std::cmp::min;
                                                                                          let len =
                                                                                              &i[index
                                                                                                     +
                                                                                                     1..].len();
                                                                                          let blen =
                                                                                              bytes.len();
                                                                                          let m =
                                                                                              min(len,
                                                                                                  blen);
                                                                                          let reduced =
                                                                                              &&i[index
                                                                                                      +
                                                                                                      1..][..m];
                                                                                          let b =
                                                                                              &bytes[..m];
                                                                                          let res:
                                                                                                  ::IResult<_,
                                                                                                            _> =
                                                                                              if reduced
                                                                                                     !=
                                                                                                     b
                                                                                                 {
                                                                                                  ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                                   &i[index
                                                                                                                                          +
                                                                                                                                          1..]))
                                                                                              } else if m
                                                                                                            <
                                                                                                            blen
                                                                                               {
                                                                                                  ::IResult::Incomplete(::Needed::Size(blen))
                                                                                              } else {
                                                                                                  ::IResult::Done(&&i[index
                                                                                                                          +
                                                                                                                          1..][blen..],
                                                                                                                  reduced)
                                                                                              };
                                                                                          res
                                                                                      }
                                                                                  }
                                                                                {
                                                                                ::IResult::Done(i,
                                                                                                o)
                                                                                =>
                                                                                ::IResult::Done(i,
                                                                                                (|_|
                                                                                                     &b"\""[..])(o)),
                                                                                ::IResult::Incomplete(x)
                                                                                =>
                                                                                ::IResult::Incomplete(x),
                                                                                ::IResult::Error(_)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        match {
                                                                                                  #[inline(always)]
                                                                                                  fn as_bytes<T: ::AsBytes>(b:
                                                                                                                                &T)
                                                                                                   ->
                                                                                                       &[u8] {
                                                                                                      b.as_bytes()
                                                                                                  }
                                                                                                  let expected =
                                                                                                      "n";
                                                                                                  let bytes =
                                                                                                      as_bytes(&expected);
                                                                                                  {
                                                                                                      use std::cmp::min;
                                                                                                      let len =
                                                                                                          &i[index
                                                                                                                 +
                                                                                                                 1..].len();
                                                                                                      let blen =
                                                                                                          bytes.len();
                                                                                                      let m =
                                                                                                          min(len,
                                                                                                              blen);
                                                                                                      let reduced =
                                                                                                          &&i[index
                                                                                                                  +
                                                                                                                  1..][..m];
                                                                                                      let b =
                                                                                                          &bytes[..m];
                                                                                                      let res:
                                                                                                              ::IResult<_,
                                                                                                                        _> =
                                                                                                          if reduced
                                                                                                                 !=
                                                                                                                 b
                                                                                                             {
                                                                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                                               &i[index
                                                                                                                                                      +
                                                                                                                                                      1..]))
                                                                                                          } else if m
                                                                                                                        <
                                                                                                                        blen
                                                                                                           {
                                                                                                              ::IResult::Incomplete(::Needed::Size(blen))
                                                                                                          } else {
                                                                                                              ::IResult::Done(&&i[index
                                                                                                                                      +
                                                                                                                                      1..][blen..],
                                                                                                                              reduced)
                                                                                                          };
                                                                                                      res
                                                                                                  }
                                                                                              }
                                                                                            {
                                                                                            ::IResult::Done(i,
                                                                                                            o)
                                                                                            =>
                                                                                            ::IResult::Done(i,
                                                                                                            (|_|
                                                                                                                 &b"\n"[..])(o)),
                                                                                            ::IResult::Incomplete(x)
                                                                                            =>
                                                                                            ::IResult::Incomplete(x),
                                                                                            ::IResult::Error(_)
                                                                                            =>
                                                                                            {
                                                                                                ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                                                                                 &i[index
                                                                                                                                        +
                                                                                                                                        1..]))
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        } {
                                                      ::IResult::Done(i, o) =>
                                                      {
                                                          res.extend(o.iter().cloned());
                                                          if i.is_empty() {
                                                              return ::IResult::Done(&b""[..],
                                                                                     res)
                                                          } else {
                                                              index =
                                                                  i.offset(i);
                                                          }
                                                      }
                                                      ::IResult::Incomplete(i)
                                                      =>
                                                      return ::IResult::Incomplete(i),
                                                      ::IResult::Error(e) =>
                                                      return ::IResult::Error(e),
                                                  }
                                              }
                                          } else {
                                              if index == 0 {
                                                  return ::IResult::Error(::Err::Position(::ErrorKind::EscapedTransform,
                                                                                          &i[index..]))
                                              } else {
                                                  return ::IResult::Done(&i[index..],
                                                                         res)
                                              }
                                          }
                                      } ::IResult::Done(&i[index..], res) };
                                  match cl() {
                                      ::IResult::Incomplete(x) =>
                                      ::IResult::Incomplete(x),
                                      ::IResult::Done(i, o) =>
                                      ::IResult::Done(i, o),
                                      ::IResult::Error(e) => {
                                          return ::IResult::Error(::Err::NodePosition(::ErrorKind::EscapedTransform,
                                                                                      i,
                                                                                      Box::new(e)))
                                      }
                                  }
                              }
                          } {
                        ::IResult::Error(e) => ::IResult::Error(e),
                        ::IResult::Incomplete(::Needed::Unknown) =>
                        ::IResult::Incomplete(::Needed::Unknown),
                        ::IResult::Incomplete(::Needed::Size(i)) =>
                        ::IResult::Incomplete(::Needed::Size(i)),
                        ::IResult::Done(i, o) => ::IResult::Done(i, to_s(o)),
                    }
                }
            }
            {
                match (&(esc(&b"abcd"[..])),
                       &(Done(&b""[..], String::from("abcd")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     842u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"ab\\\"cd"[..])),
                       &(Done(&b""[..], String::from("ab\"cd")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     843u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"\\\"abcd"[..])),
                       &(Done(&b""[..], String::from("\"abcd")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     844u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"\\n"[..])),
                       &(Done(&b""[..], String::from("\n")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     845u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"ab\\\"12"[..])),
                       &(Done(&b"12"[..], String::from("ab\"")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     846u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"AB\\"[..])),
                       &(Error(NodePosition(ErrorKind::EscapedTransform,
                                            &b"AB\\"[..],
                                            Box::new(Position(ErrorKind::EscapedTransform,
                                                              &b"\\"[..]))))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     847u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc(&b"AB\\A"[..])),
                       &(Error(NodePosition(ErrorKind::EscapedTransform,
                                            &b"AB\\A"[..],
                                            Box::new(Position(ErrorKind::Alt,
                                                              &b"A"[..]))))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     848u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let e = "\u{e8}";
            let a = "\u{e0}";
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["\u{e8}: ",
                                                                      " | \u{e0}: ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&str::as_bytes(e),
                                                                    &str::as_bytes(a))
                                                                 {
                                                                 (__arg0,
                                                                  __arg1) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt),
                                                                  ::std::fmt::ArgumentV1::new(__arg1,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            fn esc2<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], String, u32> {
                {
                    match {
                              {
                                  {
                                      let cl = || {
                                          use HexDisplay; let mut index = 0;
                                          let mut res = Vec::new();
                                          while index < i.len() {
                                              if let ::IResult::Done(i, o) =
                                                     alpha(&i[index..]) {
                                                  res.extend(o.iter().cloned());
                                                  if i.is_empty() {
                                                      return ::IResult::Done(&b""[..],
                                                                             res)
                                                  } else {
                                                      index = i.offset(i);
                                                  }
                                              } else if i[index] ==
                                                            ('&' as u8) {
                                                  if index + 1 >= i.len() {
                                                      return ::IResult::Error(::Err::Position(::ErrorKind::EscapedTransform,
                                                                                              &i[index..]));
                                                  } else {
                                                      match {
                                                                {
                                                                    match {
                                                                              #[inline(always)]
                                                                              fn as_bytes<T: ::AsBytes>(b:
                                                                                                            &T)
                                                                               ->
                                                                                   &[u8] {
                                                                                  b.as_bytes()
                                                                              }
                                                                              let expected =
                                                                                  "egrave;";
                                                                              let bytes =
                                                                                  as_bytes(&expected);
                                                                              {
                                                                                  use std::cmp::min;
                                                                                  let len =
                                                                                      &i[index
                                                                                             +
                                                                                             1..].len();
                                                                                  let blen =
                                                                                      bytes.len();
                                                                                  let m =
                                                                                      min(len,
                                                                                          blen);
                                                                                  let reduced =
                                                                                      &&i[index
                                                                                              +
                                                                                              1..][..m];
                                                                                  let b =
                                                                                      &bytes[..m];
                                                                                  let res:
                                                                                          ::IResult<_,
                                                                                                    _> =
                                                                                      if reduced
                                                                                             !=
                                                                                             b
                                                                                         {
                                                                                          ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                           &i[index
                                                                                                                                  +
                                                                                                                                  1..]))
                                                                                      } else if m
                                                                                                    <
                                                                                                    blen
                                                                                       {
                                                                                          ::IResult::Incomplete(::Needed::Size(blen))
                                                                                      } else {
                                                                                          ::IResult::Done(&&i[index
                                                                                                                  +
                                                                                                                  1..][blen..],
                                                                                                          reduced)
                                                                                      };
                                                                                  res
                                                                              }
                                                                          } {
                                                                        ::IResult::Done(i,
                                                                                        o)
                                                                        =>
                                                                        ::IResult::Done(i,
                                                                                        (|_|
                                                                                             str::as_bytes("\u{e8}"))(o)),
                                                                        ::IResult::Incomplete(x)
                                                                        =>
                                                                        ::IResult::Incomplete(x),
                                                                        ::IResult::Error(_)
                                                                        => {
                                                                            {
                                                                                match {
                                                                                          #[inline(always)]
                                                                                          fn as_bytes<T: ::AsBytes>(b:
                                                                                                                        &T)
                                                                                           ->
                                                                                               &[u8] {
                                                                                              b.as_bytes()
                                                                                          }
                                                                                          let expected =
                                                                                              "agrave;";
                                                                                          let bytes =
                                                                                              as_bytes(&expected);
                                                                                          {
                                                                                              use std::cmp::min;
                                                                                              let len =
                                                                                                  &i[index
                                                                                                         +
                                                                                                         1..].len();
                                                                                              let blen =
                                                                                                  bytes.len();
                                                                                              let m =
                                                                                                  min(len,
                                                                                                      blen);
                                                                                              let reduced =
                                                                                                  &&i[index
                                                                                                          +
                                                                                                          1..][..m];
                                                                                              let b =
                                                                                                  &bytes[..m];
                                                                                              let res:
                                                                                                      ::IResult<_,
                                                                                                                _> =
                                                                                                  if reduced
                                                                                                         !=
                                                                                                         b
                                                                                                     {
                                                                                                      ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                                                       &i[index
                                                                                                                                              +
                                                                                                                                              1..]))
                                                                                                  } else if m
                                                                                                                <
                                                                                                                blen
                                                                                                   {
                                                                                                      ::IResult::Incomplete(::Needed::Size(blen))
                                                                                                  } else {
                                                                                                      ::IResult::Done(&&i[index
                                                                                                                              +
                                                                                                                              1..][blen..],
                                                                                                                      reduced)
                                                                                                  };
                                                                                              res
                                                                                          }
                                                                                      }
                                                                                    {
                                                                                    ::IResult::Done(i,
                                                                                                    o)
                                                                                    =>
                                                                                    ::IResult::Done(i,
                                                                                                    (|_|
                                                                                                         str::as_bytes("\u{e0}"))(o)),
                                                                                    ::IResult::Incomplete(x)
                                                                                    =>
                                                                                    ::IResult::Incomplete(x),
                                                                                    ::IResult::Error(_)
                                                                                    =>
                                                                                    {
                                                                                        ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                                                                         &i[index
                                                                                                                                +
                                                                                                                                1..]))
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            } {
                                                          ::IResult::Done(i,
                                                                          o)
                                                          => {
                                                              res.extend(o.iter().cloned());
                                                              if i.is_empty()
                                                                 {
                                                                  return ::IResult::Done(&b""[..],
                                                                                         res)
                                                              } else {
                                                                  index =
                                                                      i.offset(i);
                                                              }
                                                          }
                                                          ::IResult::Incomplete(i)
                                                          =>
                                                          return ::IResult::Incomplete(i),
                                                          ::IResult::Error(e)
                                                          =>
                                                          return ::IResult::Error(e),
                                                      }
                                                  }
                                              } else {
                                                  if index == 0 {
                                                      return ::IResult::Error(::Err::Position(::ErrorKind::EscapedTransform,
                                                                                              &i[index..]))
                                                  } else {
                                                      return ::IResult::Done(&i[index..],
                                                                             res)
                                                  }
                                              }
                                          } ::IResult::Done(&i[index..], res)
                                      };
                                      match cl() {
                                          ::IResult::Incomplete(x) =>
                                          ::IResult::Incomplete(x),
                                          ::IResult::Done(i, o) =>
                                          ::IResult::Done(i, o),
                                          ::IResult::Error(e) => {
                                              return ::IResult::Error(::Err::NodePosition(::ErrorKind::EscapedTransform,
                                                                                          i,
                                                                                          Box::new(e)))
                                          }
                                      }
                                  }
                              }
                          } {
                        ::IResult::Error(e) => ::IResult::Error(e),
                        ::IResult::Incomplete(::Needed::Unknown) =>
                        ::IResult::Incomplete(::Needed::Unknown),
                        ::IResult::Incomplete(::Needed::Size(i)) =>
                        ::IResult::Incomplete(::Needed::Size(i)),
                        ::IResult::Done(i, o) => ::IResult::Done(i, to_s(o)),
                    }
                }
            }
            {
                match (&(esc2(&b"ab&egrave;DEF"[..])),
                       &(Done(&b""[..], String::from("ab\u{e8}DEF")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     859u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(esc2(&b"ab&egrave;D&agrave;EF"[..])),
                       &(Done(&b""[..], String::from("ab\u{e8}D\u{e0}EF")))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     860u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn issue_84() {
            let r0 =
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "abcd";
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            match &b"aaaaefgh"[..].iter().position(|c| {
                                                                   for &i in
                                                                       bytes.iter()
                                                                       {
                                                                       if *c
                                                                              ==
                                                                              i
                                                                          {
                                                                           return false
                                                                       }
                                                                   } true }) {
                                Some(0) =>
                                ::IResult::Error(::Err::Position(::ErrorKind::IsA,
                                                                 &b"aaaaefgh"[..])),
                                Some(n) => {
                                    let res: ::IResult<_, _> =
                                        ::IResult::Done(&&b"aaaaefgh"[..][n..],
                                                        &&b"aaaaefgh"[..][..n]);
                                    res
                                }
                                None => {
                                    ::IResult::Done(&b""[..],
                                                    &b"aaaaefgh"[..])
                                }
                            };
                        res
                    }
                };
            {
                match (&(r0), &(Done(&b"efgh"[..], &b"aaaa"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     866u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r1 =
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "abcd";
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            match &b"aaaa"[..].iter().position(|c| {
                                                               for &i in
                                                                   bytes.iter()
                                                                   {
                                                                   if *c == i
                                                                      {
                                                                       return false
                                                                   }
                                                               } true }) {
                                Some(0) =>
                                ::IResult::Error(::Err::Position(::ErrorKind::IsA,
                                                                 &b"aaaa"[..])),
                                Some(n) => {
                                    let res: ::IResult<_, _> =
                                        ::IResult::Done(&&b"aaaa"[..][n..],
                                                        &&b"aaaa"[..][..n]);
                                    res
                                }
                                None => {
                                    ::IResult::Done(&b""[..], &b"aaaa"[..])
                                }
                            };
                        res
                    }
                };
            {
                match (&(r1), &(Done(&b""[..], &b"aaaa"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     868u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r2 =
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "123456789";
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            match &b"1"[..].iter().position(|c| {
                                                            for &i in
                                                                bytes.iter() {
                                                                if *c == i {
                                                                    return false
                                                                }
                                                            } true }) {
                                Some(0) =>
                                ::IResult::Error(::Err::Position(::ErrorKind::IsA,
                                                                 &b"1"[..])),
                                Some(n) => {
                                    let res: ::IResult<_, _> =
                                        ::IResult::Done(&&b"1"[..][n..],
                                                        &&b"1"[..][..n]);
                                    res
                                }
                                None => {
                                    ::IResult::Done(&b""[..], &b"1"[..])
                                }
                            };
                        res
                    }
                };
            {
                match (&(r2), &(Done(&b""[..], &b"1"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     870u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_str_test() {
            let a = b"omnomnom";
            {
                match (&({
                             match {
                                       let cnt = 5 as usize;
                                       let res: ::IResult<_, _> =
                                           if &a[..].len() < cnt {
                                               ::IResult::Incomplete(::Needed::Size(cnt))
                                           } else {
                                               ::IResult::Done(&&a[..][cnt..],
                                                               &&a[..][0..cnt])
                                           };
                                       res
                                   } {
                                 ::IResult::Error(e) => ::IResult::Error(e),
                                 ::IResult::Incomplete(::Needed::Unknown) =>
                                 ::IResult::Incomplete(::Needed::Unknown),
                                 ::IResult::Incomplete(::Needed::Size(i)) =>
                                 ::IResult::Incomplete(::Needed::Size(i)),
                                 ::IResult::Done(i, o) =>
                                 match ::std::str::from_utf8(o) {
                                     Ok(output) => ::IResult::Done(i, output),
                                     Err(_) =>
                                     ::IResult::Error(::Err::Position(::ErrorKind::MapRes,
                                                                      &a[..])),
                                 },
                             }
                         }), &(Done(&b"nom"[..], "omnom"))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     877u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             match {
                                       let cnt = 9 as usize;
                                       let res: ::IResult<_, _> =
                                           if &a[..].len() < cnt {
                                               ::IResult::Incomplete(::Needed::Size(cnt))
                                           } else {
                                               ::IResult::Done(&&a[..][cnt..],
                                                               &&a[..][0..cnt])
                                           };
                                       res
                                   } {
                                 ::IResult::Error(e) => ::IResult::Error(e),
                                 ::IResult::Incomplete(::Needed::Unknown) =>
                                 ::IResult::Incomplete(::Needed::Unknown),
                                 ::IResult::Incomplete(::Needed::Size(i)) =>
                                 ::IResult::Incomplete(::Needed::Size(i)),
                                 ::IResult::Done(i, o) =>
                                 match ::std::str::from_utf8(o) {
                                     Ok(output) => ::IResult::Done(i, output),
                                     Err(_) =>
                                     ::IResult::Error(::Err::Position(::ErrorKind::MapRes,
                                                                      &a[..])),
                                 },
                             }
                         }), &(Incomplete(Needed::Size(9)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     878u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_until_test() {
            fn x(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "efgh";
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            if bytes.len() > i.len() {
                                ::IResult::Incomplete(::Needed::Size(bytes.len()))
                            } else {
                                let mut index = 0;
                                let mut parsed = false;
                                for idx in 0..i.len() {
                                    if idx + bytes.len() > i.len() {
                                        index = idx;
                                        break ;
                                    }
                                    if &i[idx..idx + bytes.len()] == bytes {
                                        parsed = true;
                                        index = idx;
                                        break ;
                                    }
                                }
                                if parsed {
                                    ::IResult::Done(&i[(index +
                                                            bytes.len())..],
                                                    &i[0..index])
                                } else {
                                    ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilAndConsume,
                                                                     i))
                                }
                            };
                        res
                    }
                }
            }
            let r = x(&b"abcdabcdefghijkl"[..]);
            {
                match (&(r), &(Done(&b"ijkl"[..], &b"abcdabcd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     885u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["Done 1\n\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match () {
                                                                 () => [],
                                                             }));
            let r2 = x(&b"abcdabcdefgh"[..]);
            {
                match (&(r2), &(Done(&b""[..], &b"abcdabcd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     890u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["Done 2\n\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match () {
                                                                 () => [],
                                                             }));
            let r3 = x(&b"abcefg"[..]);
            {
                match (&(r3),
                       &(Error(Position(ErrorKind::TakeUntilAndConsume,
                                        &b"abcefg"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     894u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(x(&b"ab"[..])), &(Incomplete(Needed::Size(4)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     896u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_until_either_incomplete() {
            fn x(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "!.";
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            if 1 > i.len() {
                                ::IResult::Incomplete(::Needed::Size(1))
                            } else {
                                let mut index = 0;
                                let mut parsed = false;
                                for idx in 0..i.len() {
                                    if idx + 1 > i.len() {
                                        index = idx;
                                        break ;
                                    }
                                    for &t in bytes.iter() {
                                        if i[idx] == t {
                                            parsed = true;
                                            index = idx;
                                            break ;
                                        }
                                    }
                                    if parsed { break ; }
                                }
                                if parsed {
                                    ::IResult::Done(&i[index..], &i[0..index])
                                } else {
                                    ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilEither,
                                                                     i))
                                }
                            };
                        res
                    }
                }
            }
            {
                match (&(x(&b"123"[..])),
                       &(Error(Position(ErrorKind::TakeUntilEither,
                                        &b"123"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     905u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_until_incomplete() {
            fn y(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    #[inline(always)]
                    fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                    let expected = "end";
                    let bytes = as_bytes(&expected);
                    {
                        let res: ::IResult<_, _> =
                            if bytes.len() > i.len() {
                                ::IResult::Incomplete(::Needed::Size(bytes.len()))
                            } else {
                                let mut index = 0;
                                let mut parsed = false;
                                for idx in 0..i.len() {
                                    if idx + bytes.len() > i.len() {
                                        index = idx;
                                        break ;
                                    }
                                    if &i[idx..idx + bytes.len()] == bytes {
                                        parsed = true;
                                        index = idx;
                                        break ;
                                    }
                                }
                                if parsed {
                                    ::IResult::Done(&i[index..], &i[0..index])
                                } else {
                                    ::IResult::Error(::Err::Position(::ErrorKind::TakeUntil,
                                                                     i))
                                }
                            };
                        res
                    }
                }
            }
            {
                match (&(y(&b"nd"[..])), &(Incomplete(Needed::Size(3)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     914u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(y(&b"123"[..])),
                       &(Error(Position(ErrorKind::TakeUntil, &b"123"[..]))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     918u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn recognize() {
            fn x(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match {
                              match {
                                        #[inline(always)]
                                        fn as_bytes<T: ::AsBytes>(b: &T)
                                         -> &[u8] {
                                            b.as_bytes()
                                        }
                                        let expected = "<!--";
                                        let bytes = as_bytes(&expected);
                                        {
                                            use std::cmp::min;
                                            let len = i.len();
                                            let blen = bytes.len();
                                            let m = min(len, blen);
                                            let reduced = &i[..m];
                                            let b = &bytes[..m];
                                            let res: ::IResult<_, _> =
                                                if reduced != b {
                                                    ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                     i))
                                                } else if m < blen {
                                                    ::IResult::Incomplete(::Needed::Size(blen))
                                                } else {
                                                    ::IResult::Done(&i[blen..],
                                                                    reduced)
                                                };
                                            res
                                        }
                                    } {
                                  ::IResult::Error(a) => ::IResult::Error(a),
                                  ::IResult::Incomplete(i) =>
                                  ::IResult::Incomplete(i),
                                  ::IResult::Done(i1, _) => {
                                      {
                                          match {
                                                    let cnt = 5 as usize;
                                                    let res: ::IResult<_, _> =
                                                        if i1.len() < cnt {
                                                            ::IResult::Incomplete(::Needed::Size(cnt))
                                                        } else {
                                                            ::IResult::Done(&i1[cnt..],
                                                                            &i1[0..cnt])
                                                        };
                                                    res
                                                } {
                                              ::IResult::Error(a) =>
                                              ::IResult::Error(a),
                                              ::IResult::Incomplete(i) =>
                                              ::IResult::Incomplete(i),
                                              ::IResult::Done(i2, o2) => {
                                                  {
                                                      match {
                                                                #[inline(always)]
                                                                fn as_bytes<T: ::AsBytes>(b:
                                                                                              &T)
                                                                 -> &[u8] {
                                                                    b.as_bytes()
                                                                }
                                                                let expected =
                                                                    "-->";
                                                                let bytes =
                                                                    as_bytes(&expected);
                                                                {
                                                                    use std::cmp::min;
                                                                    let len =
                                                                        i2.len();
                                                                    let blen =
                                                                        bytes.len();
                                                                    let m =
                                                                        min(len,
                                                                            blen);
                                                                    let reduced =
                                                                        &i2[..m];
                                                                    let b =
                                                                        &bytes[..m];
                                                                    let res:
                                                                            ::IResult<_,
                                                                                      _> =
                                                                        if reduced
                                                                               !=
                                                                               b
                                                                           {
                                                                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                             i2))
                                                                        } else if m
                                                                                      <
                                                                                      blen
                                                                         {
                                                                            ::IResult::Incomplete(::Needed::Size(blen))
                                                                        } else {
                                                                            ::IResult::Done(&i2[blen..],
                                                                                            reduced)
                                                                        };
                                                                    res
                                                                }
                                                            } {
                                                          ::IResult::Error(a)
                                                          =>
                                                          ::IResult::Error(a),
                                                          ::IResult::Incomplete(i)
                                                          =>
                                                          ::IResult::Incomplete(i),
                                                          ::IResult::Done(i3,
                                                                          _)
                                                          => {
                                                              ::IResult::Done(i3,
                                                                              o2)
                                                          }
                                                      }
                                                  }
                                              }
                                          }
                                      }
                                  }
                              }
                          } {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let r = x(&b"<!-- abc --> aaa"[..]);
            {
                match (&(r), &(Done(&b" aaa"[..], &b"<!-- abc -->"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     928u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let empty = &b""[..];
            fn ya(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match alpha(i) {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let ra = ya(&b"abc"[..]);
            {
                match (&(ra), &(Done(empty, &b"abc"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     934u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn yd(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match digit(i) {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let rd = yd(&b"123"[..]);
            {
                match (&(rd), &(Done(empty, &b"123"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     938u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn yhd(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match hex_digit(i) {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let rhd = yhd(&b"123abcDEF"[..]);
            {
                match (&(rhd), &(Done(empty, &b"123abcDEF"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     942u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn yan(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match alphanumeric(i) {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let ran = yan(&b"123abc"[..]);
            {
                match (&(ran), &(Done(empty, &b"123abc"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     946u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn ys(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match space(i) {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let rs = ys(&b" \t"[..]);
            {
                match (&(rs), &(Done(empty, &b" \t"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     950u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn yms(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use HexDisplay;
                    match multispace(i) {
                        ::IResult::Done(i, _) => {
                            let index = (i).offset(i);
                            ::IResult::Done(i, &(i)[..index])
                        }
                        ::IResult::Error(e) => return ::IResult::Error(e),
                        ::IResult::Incomplete(i) =>
                        return ::IResult::Incomplete(i),
                    }
                }
            }
            let rms = yms(&b" \t\r\n"[..]);
            {
                match (&(rms), &(Done(empty, &b" \t\r\n"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     954u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_while() {
            use nom::is_alphabetic;
            fn f(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    match i.iter().position(|c| !is_alphabetic(*c)) {
                        Some(n) => {
                            let res: ::IResult<_, _> =
                                ::IResult::Done(&i[n..], &i[..n]);
                            res
                        }
                        None => { ::IResult::Done(&i[..0], i) }
                    }
                }
            }
            let a = b"";
            let b = b"abcd";
            let c = b"abcd123";
            let d = b"123";
            {
                match (&(f(&a[..])), &(Done(&a[..], &a[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     966u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&b[..])), &(Done(&a[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     967u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&c[..])), &(Done(&d[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     968u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&d[..])), &(Done(&d[..], &a[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     969u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_while1() {
            use nom::is_alphabetic;
            fn f(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
                {
                    use InputLength;
                    if (i).input_len() == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::TakeWhile1,
                                                         i))
                    } else {
                        match i.iter().position(|c| !is_alphabetic(*c)) {
                            Some(0) =>
                            ::IResult::Error(::Err::Position(::ErrorKind::TakeWhile1,
                                                             i)),
                            Some(n) => { ::IResult::Done(&i[n..], &i[..n]) }
                            None => { ::IResult::Done(&i[..0], i) }
                        }
                    }
                }
            }
            let a = b"";
            let b = b"abcd";
            let c = b"abcd123";
            let d = b"123";
            {
                match (&(f(&a[..])),
                       &(Error(Position(ErrorKind::TakeWhile1, &b""[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     981u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&b[..])), &(Done(&a[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     982u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&c[..])), &(Done(&b"123"[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     983u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&d[..])),
                       &(Error(Position(ErrorKind::TakeWhile1, &d[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bytes.rs",
                                                                     984u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::is_a;
            pub use super::is_not;
            pub use super::escaping;
            pub use super::escape_transform;
            pub use super::issue_84;
            pub use super::take_str_test;
            pub use super::take_until_test;
            pub use super::take_until_either_incomplete;
            pub use super::take_until_incomplete;
            pub use super::recognize;
            pub use super::take_while;
            pub use super::take_while1;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[macro_use]
mod bits {
    //! Bit level parsers and combinators
    //!
    //! Bit parsing is handled by tweaking the input in most macros.
    //! In byte level parsing, the input is generally a `&[u8]` passed from combinator
    //! to combinator until the slices are manipulated.
    //!
    //! Bit parsers take a `(&[u8], usize)` as input. The first part of the tuple is an byte slice,
    //! the second part is a bit offset in the first byte of the slice.
    //!
    //! By passing a pair like this, we can leverage most of the combinators, and avoid
    //! transforming the whole slice to a vector of booleans. This should make it easy
    //! to see a byte slice as a bit stream, and parse code points of arbitrary bit length.
    #[prelude_import]
    use std::prelude::v1::*;
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use internal::{IResult, Needed, Err};
        use ErrorKind;
        #[test]
        pub fn take_bits() {
            let input =
                <[_]>::into_vec(::std::boxed::Box::new([170, 240, 51]));
            let sl = &input[..];
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 0 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((0 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (0 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(0
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 0;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((sl, 0), 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     167u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 8 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((8 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (8 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(8
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 8;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[1..], 0), 170))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     168u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 3 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((3 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (3 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(3
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 3;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[0..], 3), 5))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     169u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 6 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((6 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (6 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(6
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 6;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[0..], 6), 42))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     170u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 1);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 1 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((1 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (1 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(1
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 1;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[0..], 2), 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     171u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 1);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 2 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((2 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (2 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(2
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 2;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[0..], 3), 1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     172u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 1);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 3 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((3 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (3 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(3
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 3;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[0..], 4), 2))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     173u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 6);
                             let res: ::IResult<(&[u8], usize), u8> =
                                 if 3 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((3 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (3 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(3
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u8 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 3;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u8 =
                                                 if offset == 0 {
                                                     input[it] as u8
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u8
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[1..], 1), 5))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     174u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u16> =
                                 if 10 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((10 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (10 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(10
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u16 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 10;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u16 =
                                                 if offset == 0 {
                                                     input[it] as u16
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u16
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[1..], 2), 683))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     175u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u16> =
                                 if 8 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((8 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (8 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(8
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u16 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 8;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u16 =
                                                 if offset == 0 {
                                                     input[it] as u16
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u16
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[1..], 0), 170))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     176u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 6);
                             let res: ::IResult<(&[u8], usize), u16> =
                                 if 10 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((10 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (10 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(10
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u16 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 10;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u16 =
                                                 if offset == 0 {
                                                     input[it] as u16
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u16
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[2..], 0), 752))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     177u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 6);
                             let res: ::IResult<(&[u8], usize), u16> =
                                 if 11 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((11 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (11 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(11
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u16 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 11;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u16 =
                                                 if offset == 0 {
                                                     input[it] as u16
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u16
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[2..], 1), 1504))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     178u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 0);
                             let res: ::IResult<(&[u8], usize), u32> =
                                 if 20 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((20 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (20 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(20
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u32 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 20;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u32 =
                                                 if offset == 0 {
                                                     input[it] as u32
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u32
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[2..], 4), 700163))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     179u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 4);
                             let res: ::IResult<(&[u8], usize), u32> =
                                 if 20 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((20 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (20 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(20
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u32 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 20;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u32 =
                                                 if offset == 0 {
                                                     input[it] as u32
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u32
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Done((&sl[3..], 0), 716851))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     180u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             use std::ops::Div;
                             let (input, bit_offset) = (sl, 4);
                             let res: ::IResult<(&[u8], usize), u32> =
                                 if 22 == 0 {
                                     ::IResult::Done((input, bit_offset), 0)
                                 } else {
                                     let cnt =
                                         ((22 as usize) + bit_offset).div(8);
                                     if input.len() * 8 <
                                            (22 as usize) + bit_offset {
                                         ::IResult::Incomplete(::Needed::Size(22
                                                                                  as
                                                                                  usize))
                                     } else {
                                         let mut acc: u32 = 0;
                                         let mut offset: usize = bit_offset;
                                         let mut remaining: usize = 22;
                                         let mut end_offset: usize = 0;
                                         for it in 0..cnt + 1 {
                                             if remaining == 0 { break ; }
                                             let val: u32 =
                                                 if offset == 0 {
                                                     input[it] as u32
                                                 } else {
                                                     (((input[it] << offset)
                                                           as u8) >> offset)
                                                         as u32
                                                 };
                                             if remaining < 8 - offset {
                                                 acc +=
                                                     val >>
                                                         (8 - offset -
                                                              remaining);
                                                 end_offset =
                                                     remaining + offset;
                                                 break ;
                                             } else {
                                                 acc +=
                                                     val <<
                                                         remaining -
                                                             (8 - offset);
                                                 remaining -= 8 - offset;
                                                 offset = 0;
                                             }
                                         }
                                         ::IResult::Done((&input[cnt..],
                                                          end_offset), acc)
                                     }
                                 };
                             res
                         }), &(IResult::Incomplete(Needed::Size(22)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     181u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn tag_bits() {
            let input =
                <[_]>::into_vec(::std::boxed::Box::new([170, 240, 51]));
            let sl = &input[..];
            {
                match (&({
                             match {
                                       use std::ops::Div;
                                       let (input, bit_offset) = (sl, 0);
                                       let res:
                                               ::IResult<(&[u8], usize), u8> =
                                           if 3 == 0 {
                                               ::IResult::Done((input,
                                                                bit_offset),
                                                               0)
                                           } else {
                                               let cnt =
                                                   ((3 as usize) +
                                                        bit_offset).div(8);
                                               if input.len() * 8 <
                                                      (3 as usize) +
                                                          bit_offset {
                                                   ::IResult::Incomplete(::Needed::Size(3
                                                                                            as
                                                                                            usize))
                                               } else {
                                                   let mut acc: u8 = 0;
                                                   let mut offset: usize =
                                                       bit_offset;
                                                   let mut remaining: usize =
                                                       3;
                                                   let mut end_offset: usize =
                                                       0;
                                                   for it in 0..cnt + 1 {
                                                       if remaining == 0 {
                                                           break ;
                                                       }
                                                       let val: u8 =
                                                           if offset == 0 {
                                                               input[it] as u8
                                                           } else {
                                                               (((input[it] <<
                                                                      offset)
                                                                     as u8) >>
                                                                    offset) as
                                                                   u8
                                                           };
                                                       if remaining <
                                                              8 - offset {
                                                           acc +=
                                                               val >>
                                                                   (8 - offset
                                                                        -
                                                                        remaining);
                                                           end_offset =
                                                               remaining +
                                                                   offset;
                                                           break ;
                                                       } else {
                                                           acc +=
                                                               val <<
                                                                   remaining -
                                                                       (8 -
                                                                            offset);
                                                           remaining -=
                                                               8 - offset;
                                                           offset = 0;
                                                       }
                                                   }
                                                   ::IResult::Done((&input[cnt..],
                                                                    end_offset),
                                                                   acc)
                                               }
                                           };
                                       res
                                   } {
                                 ::IResult::Incomplete(i) =>
                                 ::IResult::Incomplete(i),
                                 ::IResult::Done(i, o) => {
                                     if let 5 = o {
                                         let res:
                                                 ::IResult<(&[u8], usize),
                                                           u8> =
                                             ::IResult::Done(i, o);
                                         res
                                     } else {
                                         ::IResult::Error(::Err::Position(::ErrorKind::TagBits,
                                                                          (sl,
                                                                           0)))
                                     }
                                 }
                                 _ => {
                                     ::IResult::Error(::Err::Position(::ErrorKind::TagBits,
                                                                      (sl,
                                                                       0)))
                                 }
                             }
                         }), &(IResult::Done((&sl[0..], 3), 5))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     189u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             match {
                                       use std::ops::Div;
                                       let (input, bit_offset) = (sl, 0);
                                       let res:
                                               ::IResult<(&[u8], usize), u8> =
                                           if 4 == 0 {
                                               ::IResult::Done((input,
                                                                bit_offset),
                                                               0)
                                           } else {
                                               let cnt =
                                                   ((4 as usize) +
                                                        bit_offset).div(8);
                                               if input.len() * 8 <
                                                      (4 as usize) +
                                                          bit_offset {
                                                   ::IResult::Incomplete(::Needed::Size(4
                                                                                            as
                                                                                            usize))
                                               } else {
                                                   let mut acc: u8 = 0;
                                                   let mut offset: usize =
                                                       bit_offset;
                                                   let mut remaining: usize =
                                                       4;
                                                   let mut end_offset: usize =
                                                       0;
                                                   for it in 0..cnt + 1 {
                                                       if remaining == 0 {
                                                           break ;
                                                       }
                                                       let val: u8 =
                                                           if offset == 0 {
                                                               input[it] as u8
                                                           } else {
                                                               (((input[it] <<
                                                                      offset)
                                                                     as u8) >>
                                                                    offset) as
                                                                   u8
                                                           };
                                                       if remaining <
                                                              8 - offset {
                                                           acc +=
                                                               val >>
                                                                   (8 - offset
                                                                        -
                                                                        remaining);
                                                           end_offset =
                                                               remaining +
                                                                   offset;
                                                           break ;
                                                       } else {
                                                           acc +=
                                                               val <<
                                                                   remaining -
                                                                       (8 -
                                                                            offset);
                                                           remaining -=
                                                               8 - offset;
                                                           offset = 0;
                                                       }
                                                   }
                                                   ::IResult::Done((&input[cnt..],
                                                                    end_offset),
                                                                   acc)
                                               }
                                           };
                                       res
                                   } {
                                 ::IResult::Incomplete(i) =>
                                 ::IResult::Incomplete(i),
                                 ::IResult::Done(i, o) => {
                                     if let 10 = o {
                                         let res:
                                                 ::IResult<(&[u8], usize),
                                                           u8> =
                                             ::IResult::Done(i, o);
                                         res
                                     } else {
                                         ::IResult::Error(::Err::Position(::ErrorKind::TagBits,
                                                                          (sl,
                                                                           0)))
                                     }
                                 }
                                 _ => {
                                     ::IResult::Error(::Err::Position(::ErrorKind::TagBits,
                                                                      (sl,
                                                                       0)))
                                 }
                             }
                         }), &(IResult::Done((&sl[0..], 4), 10))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     190u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        fn ch(i: (&[u8], usize)) -> ::IResult<(&[u8], usize), (u8, u8), u32> {
            {
                {
                    use InputLength;
                    let res =
                        {
                            match {
                                      use std::ops::Div;
                                      let (input, bit_offset) = i;
                                      let res: ::IResult<(&[u8], usize), u8> =
                                          if 3 == 0 {
                                              ::IResult::Done((input,
                                                               bit_offset), 0)
                                          } else {
                                              let cnt =
                                                  ((3 as usize) +
                                                       bit_offset).div(8);
                                              if input.len() * 8 <
                                                     (3 as usize) + bit_offset
                                                 {
                                                  ::IResult::Incomplete(::Needed::Size(3
                                                                                           as
                                                                                           usize))
                                              } else {
                                                  let mut acc: u8 = 0;
                                                  let mut offset: usize =
                                                      bit_offset;
                                                  let mut remaining: usize =
                                                      3;
                                                  let mut end_offset: usize =
                                                      0;
                                                  for it in 0..cnt + 1 {
                                                      if remaining == 0 {
                                                          break ;
                                                      }
                                                      let val: u8 =
                                                          if offset == 0 {
                                                              input[it] as u8
                                                          } else {
                                                              (((input[it] <<
                                                                     offset)
                                                                    as u8) >>
                                                                   offset) as
                                                                  u8
                                                          };
                                                      if remaining <
                                                             8 - offset {
                                                          acc +=
                                                              val >>
                                                                  (8 - offset
                                                                       -
                                                                       remaining);
                                                          end_offset =
                                                              remaining +
                                                                  offset;
                                                          break ;
                                                      } else {
                                                          acc +=
                                                              val <<
                                                                  remaining -
                                                                      (8 -
                                                                           offset);
                                                          remaining -=
                                                              8 - offset;
                                                          offset = 0;
                                                      }
                                                  }
                                                  ::IResult::Done((&input[cnt..],
                                                                   end_offset),
                                                                  acc)
                                              }
                                          };
                                      res
                                  } {
                                ::IResult::Incomplete(i) =>
                                ::IResult::Incomplete(i),
                                ::IResult::Done(i, o) => {
                                    if let 5 = o {
                                        let res:
                                                ::IResult<(&[u8], usize),
                                                          u8> =
                                            ::IResult::Done(i, o);
                                        res
                                    } else {
                                        ::IResult::Error(::Err::Position(::ErrorKind::TagBits,
                                                                         i))
                                    }
                                }
                                _ => {
                                    ::IResult::Error(::Err::Position(::ErrorKind::TagBits,
                                                                     i))
                                }
                            }
                        };
                    match res {
                        ::IResult::Error(e) => ::IResult::Error(e),
                        ::IResult::Incomplete(::Needed::Unknown) =>
                        ::IResult::Incomplete(::Needed::Unknown),
                        ::IResult::Incomplete(::Needed::Size(i)) =>
                        ::IResult::Incomplete(::Needed::Size(0usize + i)),
                        ::IResult::Done(i, _) => {
                            {
                                use InputLength;
                                let res =
                                    {
                                        use std::ops::Div;
                                        let (input, bit_offset) = i;
                                        let res:
                                                ::IResult<(&[u8], usize),
                                                          u8> =
                                            if 4 == 0 {
                                                ::IResult::Done((input,
                                                                 bit_offset),
                                                                0)
                                            } else {
                                                let cnt =
                                                    ((4 as usize) +
                                                         bit_offset).div(8);
                                                if input.len() * 8 <
                                                       (4 as usize) +
                                                           bit_offset {
                                                    ::IResult::Incomplete(::Needed::Size(4
                                                                                             as
                                                                                             usize))
                                                } else {
                                                    let mut acc: u8 = 0;
                                                    let mut offset: usize =
                                                        bit_offset;
                                                    let mut remaining: usize =
                                                        4;
                                                    let mut end_offset:
                                                            usize = 0;
                                                    for it in 0..cnt + 1 {
                                                        if remaining == 0 {
                                                            break ;
                                                        }
                                                        let val: u8 =
                                                            if offset == 0 {
                                                                input[it] as
                                                                    u8
                                                            } else {
                                                                (((input[it]
                                                                       <<
                                                                       offset)
                                                                      as u8)
                                                                     >>
                                                                     offset)
                                                                    as u8
                                                            };
                                                        if remaining <
                                                               8 - offset {
                                                            acc +=
                                                                val >>
                                                                    (8 -
                                                                         offset
                                                                         -
                                                                         remaining);
                                                            end_offset =
                                                                remaining +
                                                                    offset;
                                                            break ;
                                                        } else {
                                                            acc +=
                                                                val <<
                                                                    remaining
                                                                        -
                                                                        (8 -
                                                                             offset);
                                                            remaining -=
                                                                8 - offset;
                                                            offset = 0;
                                                        }
                                                    }
                                                    ::IResult::Done((&input[cnt..],
                                                                     end_offset),
                                                                    acc)
                                                }
                                            };
                                        res
                                    };
                                match res {
                                    ::IResult::Error(e) =>
                                    ::IResult::Error(e),
                                    ::IResult::Incomplete(::Needed::Unknown)
                                    =>
                                    ::IResult::Incomplete(::Needed::Unknown),
                                    ::IResult::Incomplete(::Needed::Size(i))
                                    =>
                                    ::IResult::Incomplete(::Needed::Size(0usize
                                                                             +
                                                                             ((i).input_len()
                                                                                  -
                                                                                  i.input_len())
                                                                             +
                                                                             i)),
                                    ::IResult::Done(i, o) => {
                                        let x = o;
                                        {
                                            let res =
                                                {
                                                    use std::ops::Div;
                                                    let (input, bit_offset) =
                                                        i;
                                                    let res:
                                                            ::IResult<(&[u8],
                                                                       usize),
                                                                      u8> =
                                                        if 5 == 0 {
                                                            ::IResult::Done((input,
                                                                             bit_offset),
                                                                            0)
                                                        } else {
                                                            let cnt =
                                                                ((5 as usize)
                                                                     +
                                                                     bit_offset).div(8);
                                                            if input.len() * 8
                                                                   <
                                                                   (5 as
                                                                        usize)
                                                                       +
                                                                       bit_offset
                                                               {
                                                                ::IResult::Incomplete(::Needed::Size(5
                                                                                                         as
                                                                                                         usize))
                                                            } else {
                                                                let mut acc:
                                                                        u8 =
                                                                    0;
                                                                let mut offset:
                                                                        usize =
                                                                    bit_offset;
                                                                let mut remaining:
                                                                        usize =
                                                                    5;
                                                                let mut end_offset:
                                                                        usize =
                                                                    0;
                                                                for it in
                                                                    0..cnt + 1
                                                                    {
                                                                    if remaining
                                                                           ==
                                                                           0 {
                                                                        break
                                                                            ;
                                                                    }
                                                                    let val:
                                                                            u8 =
                                                                        if offset
                                                                               ==
                                                                               0
                                                                           {
                                                                            input[it]
                                                                                as
                                                                                u8
                                                                        } else {
                                                                            (((input[it]
                                                                                   <<
                                                                                   offset)
                                                                                  as
                                                                                  u8)
                                                                                 >>
                                                                                 offset)
                                                                                as
                                                                                u8
                                                                        };
                                                                    if remaining
                                                                           <
                                                                           8 -
                                                                               offset
                                                                       {
                                                                        acc +=
                                                                            val
                                                                                >>
                                                                                (8
                                                                                     -
                                                                                     offset
                                                                                     -
                                                                                     remaining);
                                                                        end_offset
                                                                            =
                                                                            remaining
                                                                                +
                                                                                offset;
                                                                        break
                                                                            ;
                                                                    } else {
                                                                        acc +=
                                                                            val
                                                                                <<
                                                                                remaining
                                                                                    -
                                                                                    (8
                                                                                         -
                                                                                         offset);
                                                                        remaining
                                                                            -=
                                                                            8
                                                                                -
                                                                                offset;
                                                                        offset
                                                                            =
                                                                            0;
                                                                    }
                                                                }
                                                                ::IResult::Done((&input[cnt..],
                                                                                 end_offset),
                                                                                acc)
                                                            }
                                                        };
                                                    res
                                                };
                                            match res {
                                                ::IResult::Error(e) =>
                                                ::IResult::Error(e),
                                                ::IResult::Incomplete(::Needed::Unknown)
                                                =>
                                                ::IResult::Incomplete(::Needed::Unknown),
                                                ::IResult::Incomplete(::Needed::Size(i))
                                                =>
                                                ::IResult::Incomplete(::Needed::Size(0usize
                                                                                         +
                                                                                         ((i).input_len()
                                                                                              -
                                                                                              i.input_len())
                                                                                         +
                                                                                         ((i).input_len()
                                                                                              -
                                                                                              i.input_len())
                                                                                         +
                                                                                         i)),
                                                ::IResult::Done(i, o) => {
                                                    let y = o;
                                                    ::IResult::Done(i,
                                                                    (|| {
                                                                        (x, y)
                                                                    })())
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[test]
        pub fn chain_bits() {
            let input =
                <[_]>::into_vec(::std::boxed::Box::new([170, 240, 51]));
            let sl = &input[..];
            {
                match (&(ch((&input[..], 0))),
                       &(IResult::Done((&sl[1..], 4), (5, 15)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     206u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(ch((&input[..], 4))),
                       &(IResult::Done((&sl[2..], 0), (7, 16)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     207u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(ch((&input[..1], 0))),
                       &(IResult::Incomplete(Needed::Size(12)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     208u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        fn ch_bytes<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], (u8, u8), u32> {
            {
                let input = (i, 0usize);
                match ch(input) {
                    ::IResult::Error(e) => {
                        let err =
                            match e {
                                ::Err::Code(k) | ::Err::Node(k, _) =>
                                ::Err::Code(k),
                                ::Err::Position(k, (i, b)) |
                                ::Err::NodePosition(k, (i, b), _) => {
                                    ::Err::Position(k, &i[b / 8..])
                                }
                            };
                        ::IResult::Error(err)
                    }
                    ::IResult::Incomplete(::Needed::Unknown) =>
                    ::IResult::Incomplete(::Needed::Unknown),
                    ::IResult::Incomplete(::Needed::Size(i)) => {
                        ::IResult::Incomplete(::Needed::Size(i / 8 + 1))
                    }
                    ::IResult::Done((i, bit_index), o) => {
                        let byte_index =
                            bit_index / 8 +
                                if bit_index % 8 == 0 { 0 } else { 1 };
                        ::IResult::Done(&i[byte_index..], o)
                    }
                }
            }
        }
        #[test]
        pub fn bits_to_bytes() {
            let input =
                <[_]>::into_vec(::std::boxed::Box::new([170, 240, 51]));
            {
                match (&(ch_bytes(&input[..])),
                       &(IResult::Done(&input[2..], (5, 15)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     215u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(ch_bytes(&input[..1])),
                       &(IResult::Incomplete(Needed::Size(2)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     216u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(ch_bytes(&input[1..])),
                       &(IResult::Error(Err::Position(ErrorKind::TagBits,
                                                      &input[1..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/bits.rs",
                                                                     217u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::take_bits;
            pub use super::tag_bits;
            pub use super::chain_bits;
            pub use super::bits_to_bytes;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[macro_use]
mod nom {
    //! Useful parser combinators
    //!
    //! A number of useful parser combinators have already been implemented.
    //! Some of them use macros, other are implemented through functions.
    //! Hopefully, the syntax will converge to onely one way in the future,
    //! but the macros system makes no promises.
    //!
    #[prelude_import]
    use std::prelude::v1::*;
    use std::boxed::Box;
    use std::fmt::Debug;
    use internal::*;
    use internal::IResult::*;
    use internal::Err::*;
    use util::{ErrorKind, IterIndices, AsChar, InputLength};
    use std::mem::transmute;
    #[inline]
    pub fn tag_cl<'a, 'b>(rec: &'a [u8])
     -> Box<Fn(&'b [u8]) -> IResult<&'b [u8], &'b [u8]>+ 'a> {
        Box::new(move |i: &'b [u8]| -> IResult<&'b [u8], &'b [u8]> {
                 if i.len() >= rec.len() && &i[0..rec.len()] == rec {
                     Done(&i[rec.len()..], &i[0..rec.len()])
                 } else { Error(Position(ErrorKind::TagClosure, i)) } })
    }
    #[cfg(not(feature = "core"))]
    #[inline]
    pub fn print<T: Debug>(input: T) -> IResult<T, ()> {
        ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                            static __STATIC_FMTSTR:
                                                                   &'static [&'static str]
                                                                   =
                                                                &["", "\n"];
                                                            __STATIC_FMTSTR
                                                        },
                                                        &match (&input,) {
                                                             (__arg0,) =>
                                                             [::std::fmt::ArgumentV1::new(__arg0,
                                                                                          ::std::fmt::Debug::fmt)],
                                                         }));
        Done(input, ())
    }
    #[inline]
    pub fn begin(input: &[u8]) -> IResult<(), &[u8]> { Done((), input) }
    pub fn not_line_ending(input: &[u8]) -> IResult<&[u8], &[u8]> {
        for (idx, item) in input.iter().enumerate() {
            for &i in b"\r\n".iter() {
                if *item == i { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(b"", input)
    }
    fn tag_ln(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
        {
            #[inline(always)]
            fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
            let expected = "\n";
            let bytes = as_bytes(&expected);
            {
                use std::cmp::min;
                let len = i.len();
                let blen = bytes.len();
                let m = min(len, blen);
                let reduced = &i[..m];
                let b = &bytes[..m];
                let res: ::IResult<_, _> =
                    if reduced != b {
                        ::IResult::Error(::Err::Position(::ErrorKind::Tag, i))
                    } else if m < blen {
                        ::IResult::Incomplete(::Needed::Size(blen))
                    } else { ::IResult::Done(&i[blen..], reduced) };
                res
            }
        }
    }
    /// Recognizes a line feed
    #[inline]
    pub fn line_ending(input: &[u8]) -> IResult<&[u8], &[u8]> {
        tag_ln(input)
    }
    #[inline]
    pub fn is_alphabetic(chr: u8) -> bool {
        (chr >= 65 && chr <= 90) || (chr >= 97 && chr <= 122)
    }
    #[inline]
    pub fn is_digit(chr: u8) -> bool { chr >= 48 && chr <= 57 }
    #[inline]
    pub fn is_hex_digit(chr: u8) -> bool {
        (chr >= 48 && chr <= 57) || (chr >= 65 && chr <= 70) ||
            (chr >= 97 && chr <= 102)
    }
    #[inline]
    pub fn is_alphanumeric(chr: u8) -> bool {
        is_alphabetic(chr) || is_digit(chr)
    }
    #[inline]
    pub fn is_space(chr: u8) -> bool {
        chr == (' ' as u8) || chr == ('\t' as u8)
    }
    use std::ops::{Index, Range, RangeFrom};
    /// Recognizes lowercase and uppercase alphabetic characters: a-zA-Z
    pub fn alpha<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T> where
     T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output = T>,
     &'a T: IterIndices + InputLength {
        let input_length = input.input_len();
        if input_length == 0 {
            return Error(Position(ErrorKind::Alpha, input))
        }
        for (idx, item) in input.iter_indices() {
            if !item.is_alpha() {
                if idx == 0 {
                    return Error(Position(ErrorKind::Alpha, input))
                } else { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(&input[input_length..], input)
    }
    /// Recognizes numerical characters: 0-9
    pub fn digit<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T> where
     T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output = T>,
     &'a T: IterIndices + InputLength {
        let input_length = input.input_len();
        if input_length == 0 {
            return Error(Position(ErrorKind::Digit, input))
        }
        for (idx, item) in input.iter_indices() {
            if !item.is_0_to_9() {
                if idx == 0 {
                    return Error(Position(ErrorKind::Digit, input))
                } else { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(&input[input_length..], input)
    }
    /// Recognizes hexadecimal numerical characters: 0-9, A-F, a-f
    pub fn hex_digit<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T>
     where T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output
     = T>, &'a T: IterIndices + InputLength {
        let input_length = input.input_len();
        if input_length == 0 {
            return Error(Position(ErrorKind::Digit, input))
        }
        for (idx, item) in input.iter_indices() {
            if !item.is_hex_digit() {
                if idx == 0 {
                    return Error(Position(ErrorKind::HexDigit, input))
                } else { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(&input[input_length..], input)
    }
    /// Recognizes numerical and alphabetic characters: 0-9a-zA-Z
    pub fn alphanumeric<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T>
     where T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output
     = T>, &'a T: IterIndices + InputLength {
        let input_length = input.input_len();
        if input_length == 0 {
            return Error(Position(ErrorKind::AlphaNumeric, input));
        }
        for (idx, item) in input.iter_indices() {
            if !item.is_alphanum() {
                if idx == 0 {
                    return Error(Position(ErrorKind::AlphaNumeric, input))
                } else { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(&input[input_length..], input)
    }
    /// Recognizes spaces and tabs
    pub fn space<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T> where
     T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output = T>,
     &'a T: IterIndices + InputLength {
        let input_length = input.input_len();
        if input_length == 0 {
            return Error(Position(ErrorKind::Space, input));
        }
        for (idx, item) in input.iter_indices() {
            let chr = item.as_char();
            if !(chr == ' ' || chr == '\t') {
                if idx == 0 {
                    return Error(Position(ErrorKind::Space, input))
                } else { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(&input[input_length..], input)
    }
    /// Recognizes spaces, tabs, carriage returns and line feeds
    pub fn multispace<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T>
     where T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output
     = T>, &'a T: IterIndices + InputLength {
        let input_length = input.input_len();
        if input_length == 0 {
            return Error(Position(ErrorKind::MultiSpace, input));
        }
        for (idx, item) in input.iter_indices() {
            let chr = item.as_char();
            if !(chr == ' ' || chr == '\t' || chr == '\r' || chr == '\n') {
                if idx == 0 {
                    return Error(Position(ErrorKind::MultiSpace, input))
                } else { return Done(&input[idx..], &input[0..idx]) }
            }
        }
        Done(&input[input_length..], input)
    }
    pub fn sized_buffer(input: &[u8]) -> IResult<&[u8], &[u8]> {
        if input.is_empty() { return Incomplete(Needed::Unknown) }
        let len = input[0] as usize;
        if input.len() >= len + 1 {
            Done(&input[len + 1..], &input[1..len + 1])
        } else { Incomplete(Needed::Size(1 + len)) }
    }
    pub fn length_value(input: &[u8]) -> IResult<&[u8], &[u8]> {
        let input_len = input.len();
        if input_len == 0 {
            return Error(Position(ErrorKind::LengthValueFn, input))
        }
        let len = input[0] as usize;
        if input_len - 1 >= len {
            IResult::Done(&input[len + 1..], &input[1..len + 1])
        } else { IResult::Incomplete(Needed::Size(1 + len)) }
    }
    /// Recognizes an unsigned 1 byte integer (equivalent to take!(1)
    #[inline]
    pub fn be_u8(i: &[u8]) -> IResult<&[u8], u8> {
        if i.len() < 1 {
            Incomplete(Needed::Size(1))
        } else { Done(&i[1..], i[0]) }
    }
    /// Recognizes big endian unsigned 2 bytes integer
    #[inline]
    pub fn be_u16(i: &[u8]) -> IResult<&[u8], u16> {
        if i.len() < 2 {
            Incomplete(Needed::Size(2))
        } else {
            let res = ((i[0] as u16) << 8) + (i[1] as u16);
            Done(&i[2..], res)
        }
    }
    /// Recognizes big endian unsigned 4 bytes integer
    #[inline]
    pub fn be_u32(i: &[u8]) -> IResult<&[u8], u32> {
        if i.len() < 4 {
            Incomplete(Needed::Size(4))
        } else {
            let res =
                ((i[0] as u32) << 24) + ((i[1] as u32) << 16) +
                    ((i[2] as u32) << 8) + (i[3] as u32);
            Done(&i[4..], res)
        }
    }
    /// Recognizes big endian unsigned 8 bytes integer
    #[inline]
    pub fn be_u64(i: &[u8]) -> IResult<&[u8], u64> {
        if i.len() < 8 {
            Incomplete(Needed::Size(8))
        } else {
            let res =
                ((i[0] as u64) << 56) + ((i[1] as u64) << 48) +
                    ((i[2] as u64) << 40) + ((i[3] as u64) << 32) +
                    ((i[4] as u64) << 24) + ((i[5] as u64) << 16) +
                    ((i[6] as u64) << 8) + (i[7] as u64);
            Done(&i[8..], res)
        }
    }
    /// Recognizes a signed 1 byte integer (equivalent to take!(1)
    #[inline]
    pub fn be_i8(i: &[u8]) -> IResult<&[u8], i8> {
        {
            match be_u8(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i8 })(o)),
            }
        }
    }
    /// Recognizes big endian signed 2 bytes integer
    #[inline]
    pub fn be_i16(i: &[u8]) -> IResult<&[u8], i16> {
        {
            match be_u16(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i16 })(o)),
            }
        }
    }
    /// Recognizes big endian signed 4 bytes integer
    #[inline]
    pub fn be_i32(i: &[u8]) -> IResult<&[u8], i32> {
        {
            match be_u32(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i32 })(o)),
            }
        }
    }
    /// Recognizes big endian signed 8 bytes integer
    #[inline]
    pub fn be_i64(i: &[u8]) -> IResult<&[u8], i64> {
        {
            match be_u64(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i64 })(o)),
            }
        }
    }
    /// Recognizes an unsigned 1 byte integer (equivalent to take!(1)
    #[inline]
    pub fn le_u8(i: &[u8]) -> IResult<&[u8], u8> {
        if i.len() < 1 {
            Incomplete(Needed::Size(1))
        } else { Done(&i[1..], i[0]) }
    }
    /// Recognizes little endian unsigned 2 bytes integer
    #[inline]
    pub fn le_u16(i: &[u8]) -> IResult<&[u8], u16> {
        if i.len() < 2 {
            Incomplete(Needed::Size(2))
        } else {
            let res = ((i[1] as u16) << 8) + (i[0] as u16);
            Done(&i[2..], res)
        }
    }
    /// Recognizes little endian unsigned 4 bytes integer
    #[inline]
    pub fn le_u32(i: &[u8]) -> IResult<&[u8], u32> {
        if i.len() < 4 {
            Incomplete(Needed::Size(4))
        } else {
            let res =
                ((i[3] as u32) << 24) + ((i[2] as u32) << 16) +
                    ((i[1] as u32) << 8) + (i[0] as u32);
            Done(&i[4..], res)
        }
    }
    /// Recognizes little endian unsigned 8 bytes integer
    #[inline]
    pub fn le_u64(i: &[u8]) -> IResult<&[u8], u64> {
        if i.len() < 8 {
            Incomplete(Needed::Size(8))
        } else {
            let res =
                ((i[7] as u64) << 56) + ((i[6] as u64) << 48) +
                    ((i[5] as u64) << 40) + ((i[4] as u64) << 32) +
                    ((i[3] as u64) << 24) + ((i[2] as u64) << 16) +
                    ((i[1] as u64) << 8) + (i[0] as u64);
            Done(&i[8..], res)
        }
    }
    /// Recognizes a signed 1 byte integer (equivalent to take!(1)
    #[inline]
    pub fn le_i8(i: &[u8]) -> IResult<&[u8], i8> {
        {
            match le_u8(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i8 })(o)),
            }
        }
    }
    /// Recognizes little endian signed 2 bytes integer
    #[inline]
    pub fn le_i16(i: &[u8]) -> IResult<&[u8], i16> {
        {
            match le_u16(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i16 })(o)),
            }
        }
    }
    /// Recognizes little endian signed 4 bytes integer
    #[inline]
    pub fn le_i32(i: &[u8]) -> IResult<&[u8], i32> {
        {
            match le_u32(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i32 })(o)),
            }
        }
    }
    /// Recognizes little endian signed 8 bytes integer
    #[inline]
    pub fn le_i64(i: &[u8]) -> IResult<&[u8], i64> {
        {
            match le_u64(i) {
                ::IResult::Error(e) => ::IResult::Error(e),
                ::IResult::Incomplete(::Needed::Unknown) =>
                ::IResult::Incomplete(::Needed::Unknown),
                ::IResult::Incomplete(::Needed::Size(i)) =>
                ::IResult::Incomplete(::Needed::Size(i)),
                ::IResult::Done(i, o) =>
                ::IResult::Done(i, (|x| { x as i64 })(o)),
            }
        }
    }
    /// Recognizes big endian 4 bytes floating point number
    #[inline]
    pub fn be_f32(input: &[u8]) -> IResult<&[u8], f32> {
        match be_u32(input) {
            Error(e) => Error(e),
            Incomplete(e) => Incomplete(e),
            Done(i, o) => { unsafe { Done(i, transmute::<u32, f32>(o)) } }
        }
    }
    /// Recognizes big endian 8 bytes floating point number
    #[inline]
    pub fn be_f64(input: &[u8]) -> IResult<&[u8], f64> {
        match be_u64(input) {
            Error(e) => Error(e),
            Incomplete(e) => Incomplete(e),
            Done(i, o) => { unsafe { Done(i, transmute::<u64, f64>(o)) } }
        }
    }
    /// Recognizes a hex-encoded integer
    #[inline]
    pub fn hex_u32(input: &[u8]) -> IResult<&[u8], u32> {
        match {
                  #[inline(always)]
                  fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                  let expected = &b"0123456789abcdef"[..];
                  let bytes = as_bytes(&expected);
                  {
                      let res: ::IResult<_, _> =
                          match input.iter().position(|c| {
                                                      for &i in bytes.iter() {
                                                          if *c == i {
                                                              return false
                                                          }
                                                      } true }) {
                              Some(0) =>
                              ::IResult::Error(::Err::Position(::ErrorKind::IsA,
                                                               input)),
                              Some(n) => {
                                  let res: ::IResult<_, _> =
                                      ::IResult::Done(&input[n..],
                                                      &input[..n]);
                                  res
                              }
                              None => { ::IResult::Done(&b""[..], input) }
                          };
                      res
                  }
              } {
            Error(e) => Error(e),
            Incomplete(e) => Incomplete(e),
            Done(i, o) => {
                let mut res = 0;
                for &e in o {
                    let digit = e as char;
                    let value = digit.to_digit(16).unwrap_or(0);
                    res = value + (res << 4);
                }
                Done(i, res)
            }
        }
    }
    /// Recognizes empty input buffers
    ///
    /// useful to verify that the previous parsers used all of the input
    #[inline]
    pub fn eof<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T> where
     T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output = T>,
     &'a T: InputLength {
        if input.input_len() == 0 {
            Done(input, input)
        } else { Error(Position(ErrorKind::Eof, input)) }
    }
    /// Recognizes non empty buffers
    #[inline]
    pub fn non_empty<'a, T: ?Sized>(input: &'a T) -> IResult<&'a T, &'a T>
     where T: Index<Range<usize>, Output = T> + Index<RangeFrom<usize>, Output
     = T>, &'a T: InputLength {
        if input.input_len() == 0 {
            Error(Position(ErrorKind::NonEmpty, input))
        } else { Done(&input[0..0], input) }
    }
    /// Return the remaining input.
    #[inline]
    pub fn rest(i: &[u8]) -> IResult<&[u8], &[u8]> { IResult::Done(b"", i) }
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use super::*;
        use internal::{Needed, IResult};
        use internal::IResult::*;
        use internal::Err::*;
        use util::ErrorKind;
        #[test]
        pub fn tag_closure() {
            let x = tag_cl(&b"abcd"[..]);
            let r = x(&b"abcdabcdefgh"[..]);
            {
                match (&(r), &(Done(&b"abcdefgh"[..], &b"abcd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     508u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let r2 = x(&b"abcefgh"[..]);
            {
                match (&(r2),
                       &(Error(Position(ErrorKind::TagClosure,
                                        &b"abcefgh"[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     511u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn character() {
            let empty: &[u8] = b"";
            let a: &[u8] = b"abcd";
            let b: &[u8] = b"1234";
            let c: &[u8] = b"a123";
            let d: &[u8] = "az\u{e9}12".as_bytes();
            let e: &[u8] = b" ";
            {
                match (&(alpha(a)), &(Done(empty, a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     522u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alpha(b)), &(Error(Position(ErrorKind::Alpha, b)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     523u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alpha(c)), &(Done(&c[1..], &b"a"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     524u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alpha(d)),
                       &(Done("\u{e9}12".as_bytes(), &b"az"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     525u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(a)), &(Error(Position(ErrorKind::Digit, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     526u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(b)), &(Done(empty, b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     527u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(c)), &(Error(Position(ErrorKind::Digit, c)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     528u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(d)), &(Error(Position(ErrorKind::Digit, d)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     529u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(a)), &(Done(empty, a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     530u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(b)), &(Done(empty, b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     531u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(c)), &(Done(empty, c))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     532u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(d)),
                       &(Done("z\u{e9}12".as_bytes(), &b"a"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     533u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(e)),
                       &(Error(Position(ErrorKind::HexDigit, e)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     534u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alphanumeric(a)), &(Done(empty, a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     535u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             match alphanumeric(b) {
                                 ::IResult::Incomplete(x) =>
                                 ::IResult::Incomplete(x),
                                 ::IResult::Done(i, o) =>
                                 ::IResult::Done(i, o),
                                 ::IResult::Error(e) => {
                                     let err =
                                         match e {
                                             ::Err::Code(ErrorKind::Custom(_))
                                             |
                                             ::Err::Node(ErrorKind::Custom(_),
                                                         _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Code(e)
                                             }
                                             ::Err::Position(ErrorKind::Custom(_),
                                                             p) |
                                             ::Err::NodePosition(ErrorKind::Custom(_),
                                                                 p, _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Position(e, p)
                                             }
                                             ::Err::Code(_) |
                                             ::Err::Node(_, _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Code(e)
                                             }
                                             ::Err::Position(_, p) |
                                             ::Err::NodePosition(_, p, _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Position(e, p)
                                             }
                                         };
                                     ::IResult::Error(err)
                                 }
                             }
                         }), &(Done(empty, b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     536u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alphanumeric(c)), &(Done(empty, c))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     537u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alphanumeric(d)),
                       &(Done("\u{e9}12".as_bytes(), &b"az"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     538u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(space(e)), &(Done(&b""[..], &b" "[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     539u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn character_s() {
            let empty = "";
            let a = "abcd";
            let b = "1234";
            let c = "a123";
            let d = "az\u{e9}12";
            let e = " ";
            {
                match (&(alpha(a)), &(Done(empty, a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     550u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alpha(b)), &(Error(Position(ErrorKind::Alpha, b)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     551u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alpha(c)), &(Done(&c[1..], &"a"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     552u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alpha(d)), &(Done("12", &"az\u{e9}"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     553u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(a)), &(Error(Position(ErrorKind::Digit, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     554u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(b)), &(Done(empty, b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     555u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(c)), &(Error(Position(ErrorKind::Digit, c)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     556u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(digit(d)), &(Error(Position(ErrorKind::Digit, d)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     557u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(a)), &(Done(empty, a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     558u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(b)), &(Done(empty, b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     559u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(c)), &(Done(empty, c))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     560u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(d)), &(Done("z\u{e9}12", &"a"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     561u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_digit(e)),
                       &(Error(Position(ErrorKind::HexDigit, e)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     562u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alphanumeric(a)), &(Done(empty, a))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     563u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&({
                             match alphanumeric(b) {
                                 ::IResult::Incomplete(x) =>
                                 ::IResult::Incomplete(x),
                                 ::IResult::Done(i, o) =>
                                 ::IResult::Done(i, o),
                                 ::IResult::Error(e) => {
                                     let err =
                                         match e {
                                             ::Err::Code(ErrorKind::Custom(_))
                                             |
                                             ::Err::Node(ErrorKind::Custom(_),
                                                         _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Code(e)
                                             }
                                             ::Err::Position(ErrorKind::Custom(_),
                                                             p) |
                                             ::Err::NodePosition(ErrorKind::Custom(_),
                                                                 p, _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Position(e, p)
                                             }
                                             ::Err::Code(_) |
                                             ::Err::Node(_, _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Code(e)
                                             }
                                             ::Err::Position(_, p) |
                                             ::Err::NodePosition(_, p, _) => {
                                                 let e: ErrorKind<()> =
                                                     ErrorKind::Fix;
                                                 ::Err::Position(e, p)
                                             }
                                         };
                                     ::IResult::Error(err)
                                 }
                             }
                         }), &(Done(empty, b))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     564u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alphanumeric(c)), &(Done(empty, c))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     565u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(alphanumeric(d)), &(Done("", &"az\u{e9}12"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     566u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(space(e)), &(Done(&""[..], &" "[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     567u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        use util::HexDisplay;
        #[test]
        pub fn offset() {
            let a = &b"abcd"[..];
            let b = &b"1234"[..];
            let c = &b"a123"[..];
            let d = &b" \t"[..];
            let e = &b" \t\r\n"[..];
            let f = &b"123abcDEF"[..];
            match alpha(a) {
                Done(i, _) => {
                    {
                        match (&(a.offset(i) + i.len()), &(a.len())) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/nom.rs",
                                                                             581u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("wrong return type in offset test for alpha",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/nom.rs",
                                                         582u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
            match digit(b) {
                Done(i, _) => {
                    {
                        match (&(b.offset(i) + i.len()), &(b.len())) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/nom.rs",
                                                                             585u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("wrong return type in offset test for digit",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/nom.rs",
                                                         586u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
            match alphanumeric(c) {
                Done(i, _) => {
                    {
                        match (&(c.offset(i) + i.len()), &(c.len())) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/nom.rs",
                                                                             589u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("wrong return type in offset test for alphanumeric",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/nom.rs",
                                                         590u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
            match space(d) {
                Done(i, _) => {
                    {
                        match (&(d.offset(i) + i.len()), &(d.len())) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/nom.rs",
                                                                             593u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("wrong return type in offset test for space",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/nom.rs",
                                                         594u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
            match multispace(e) {
                Done(i, _) => {
                    {
                        match (&(e.offset(i) + i.len()), &(e.len())) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/nom.rs",
                                                                             597u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("wrong return type in offset test for multispace",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/nom.rs",
                                                         598u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
            match hex_digit(f) {
                Done(i, _) => {
                    {
                        match (&(f.offset(i) + i.len()), &(f.len())) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                      static __STATIC_FMTSTR:
                                                                                                             &'static [&'static str]
                                                                                                             =
                                                                                                          &["assertion failed: `(left == right)` (left: `",
                                                                                                            "`, right: `",
                                                                                                            "`)"];
                                                                                                      __STATIC_FMTSTR
                                                                                                  },
                                                                                                  &match (&left_val,
                                                                                                          &right_val)
                                                                                                       {
                                                                                                       (__arg0,
                                                                                                        __arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                                    ::std::fmt::Debug::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                                   }),
                                                                    {
                                                                        static _FILE_LINE:
                                                                               (&'static str,
                                                                                u32)
                                                                               =
                                                                            ("src/nom.rs",
                                                                             601u32);
                                                                        &_FILE_LINE
                                                                    })
                                    }
                                }
                            }
                        }
                    };
                }
                _ => {
                    {
                        ::std::rt::begin_unwind("wrong return type in offset test for hex_digit",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/nom.rs",
                                                         602u32);
                                                    &_FILE_LINE
                                                })
                    }
                }
            }
        }
        #[test]
        pub fn is_not() {
            let a: &[u8] = b"ab12cd\nefgh";
            {
                match (&(not_line_ending(a)),
                       &(Done(&b"\nefgh"[..], &b"ab12cd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     609u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b: &[u8] = b"ab12cd\nefgh\nijkl";
            {
                match (&(not_line_ending(b)),
                       &(Done(&b"\nefgh\nijkl"[..], &b"ab12cd"[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     612u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let c: &[u8] = b"ab12cd";
            {
                match (&(not_line_ending(c)), &(Done(&b""[..], c))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     615u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn buffer_with_size() {
            let i: Vec<u8> = <[_]>::into_vec(::std::boxed::Box::new([7, 8]));
            let o: Vec<u8> =
                <[_]>::into_vec(::std::boxed::Box::new([4, 5, 6]));
            let arr: [u8; 6usize] = [3, 4, 5, 6, 7, 8];
            let res = sized_buffer(&arr[..]);
            {
                match (&(res), &(Done(&i[..], &o[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     625u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            }
        }
        #[test]
        pub fn length_value_test() {
            let i1 = <[_]>::into_vec(::std::boxed::Box::new([7, 8]));
            let o1 = <[_]>::into_vec(::std::boxed::Box::new([4, 5, 6]));
            let arr1: [u8; 6usize] = [3, 4, 5, 6, 7, 8];
            let res1 = length_value(&arr1);
            {
                match (&(Done(&i1[..], &o1[..])), &(res1)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     643u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let i2: Vec<u8> =
                <[_]>::into_vec(::std::boxed::Box::new([4, 5, 6, 7, 8]));
            let o2: &[u8] = b"";
            let arr2: [u8; 6usize] = [0, 4, 5, 6, 7, 8];
            let res2 = length_value(&arr2);
            {
                match (&(Done(&i2[..], o2)), &(res2)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     649u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let arr3: [u8; 7usize] = [8, 4, 5, 6, 7, 8, 9];
            let res3 = length_value(&arr3);
            {
                match (&(Incomplete(Needed::Size(9))), &(res3)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     654u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn i8_tests() {
            {
                match (&(be_i8(&[0])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     659u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i8(&[127])), &(Done(&b""[..], 127))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     660u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i8(&[255])), &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     661u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i8(&[128])), &(Done(&b""[..], -128))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     662u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn i16_tests() {
            {
                match (&(be_i16(&[0, 0])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     667u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i16(&[127, 255])), &(Done(&b""[..], 32767i16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     668u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i16(&[255, 255])), &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     669u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i16(&[128, 0])), &(Done(&b""[..], -32768i16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     670u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn i32_tests() {
            {
                match (&(be_i32(&[0, 0, 0, 0])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     675u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i32(&[127, 255, 255, 255])),
                       &(Done(&b""[..], 2147483647i32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     676u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i32(&[255, 255, 255, 255])),
                       &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     677u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i32(&[128, 0, 0, 0])),
                       &(Done(&b""[..], -2147483648i32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     678u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn i64_tests() {
            {
                match (&(be_i64(&[0, 0, 0, 0, 0, 0, 0, 0])),
                       &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     683u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i64(&[127, 255, 255, 255, 255, 255, 255, 255])),
                       &(Done(&b""[..], 9223372036854775807i64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     684u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i64(&[255, 255, 255, 255, 255, 255, 255, 255])),
                       &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     685u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(be_i64(&[128, 0, 0, 0, 0, 0, 0, 0])),
                       &(Done(&b""[..], -9223372036854775808i64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     686u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn le_i8_tests() {
            {
                match (&(le_i8(&[0])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     691u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i8(&[127])), &(Done(&b""[..], 127))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     692u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i8(&[255])), &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     693u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i8(&[128])), &(Done(&b""[..], -128))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     694u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn le_i16_tests() {
            {
                match (&(le_i16(&[0, 0])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     699u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i16(&[255, 127])), &(Done(&b""[..], 32767i16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     700u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i16(&[255, 255])), &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     701u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i16(&[0, 128])), &(Done(&b""[..], -32768i16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     702u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn le_i32_tests() {
            {
                match (&(le_i32(&[0, 0, 0, 0])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     707u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i32(&[255, 255, 255, 127])),
                       &(Done(&b""[..], 2147483647i32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     708u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i32(&[255, 255, 255, 255])),
                       &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     709u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i32(&[0, 0, 0, 128])),
                       &(Done(&b""[..], -2147483648i32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     710u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn le_i64_tests() {
            {
                match (&(le_i64(&[0, 0, 0, 0, 0, 0, 0, 0])),
                       &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     715u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i64(&[255, 255, 255, 255, 255, 255, 255, 127])),
                       &(Done(&b""[..], 9223372036854775807i64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     716u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i64(&[255, 255, 255, 255, 255, 255, 255, 255])),
                       &(Done(&b""[..], -1))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     717u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_i64(&[0, 0, 0, 0, 0, 0, 0, 128])),
                       &(Done(&b""[..], -9223372036854775808i64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     718u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn hex_u32_tests() {
            {
                match (&(hex_u32(&b""[..])), &(Done(&b""[..], 0))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     723u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_u32(&b"ff"[..])), &(Done(&b""[..], 255))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     724u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_u32(&b"1be2"[..])), &(Done(&b""[..], 7138))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     725u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(hex_u32(&b"0x1be2"[..])), &(Done(&b"x1be2"[..], 0)))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     726u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn end_of_input() {
            let not_over = &b"Hello, world!"[..];
            let is_over = &b""[..];
            let res_not_over = eof(not_over);
            {
                match (&(res_not_over),
                       &(Error(Position(ErrorKind::Eof, not_over)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     735u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let res_over = eof(is_over);
            {
                match (&(res_over), &(Done(is_over, is_over))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     738u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn configurable_endianness() {
            fn be_tst16<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], u16, u32> {
                { if true { ::be_u16(i) } else { ::le_u16(i) } }
            }
            fn le_tst16<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], u16, u32> {
                { if false { ::be_u16(i) } else { ::le_u16(i) } }
            }
            {
                match (&(be_tst16(&[128, 0])), &(Done(&b""[..], 32768u16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     745u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_tst16(&[128, 0])), &(Done(&b""[..], 128u16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     746u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn be_tst32<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], u32, u32> {
                { if true { ::be_u32(i) } else { ::le_u32(i) } }
            }
            fn le_tst32<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], u32, u32> {
                { if false { ::be_u32(i) } else { ::le_u32(i) } }
            }
            {
                match (&(be_tst32(&[18, 0, 96, 0])),
                       &(Done(&b""[..], 302014464u32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     750u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_tst32(&[18, 0, 96, 0])),
                       &(Done(&b""[..], 6291474u32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     751u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn be_tst64<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], u64, u32> {
                { if true { ::be_u64(i) } else { ::le_u64(i) } }
            }
            fn le_tst64<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], u64, u32> {
                { if false { ::be_u64(i) } else { ::le_u64(i) } }
            }
            {
                match (&(be_tst64(&[18, 0, 96, 0, 18, 0, 128, 0])),
                       &(Done(&b""[..], 1297142246100992000u64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     755u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_tst64(&[18, 0, 96, 0, 18, 0, 128, 0])),
                       &(Done(&b""[..], 36028874334666770u64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     756u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn be_tsti16<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], i16, u32> {
                { if true { ::be_i16(i) } else { ::le_i16(i) } }
            }
            fn le_tsti16<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], i16, u32> {
                { if false { ::be_i16(i) } else { ::le_i16(i) } }
            }
            {
                match (&(be_tsti16(&[0, 128])), &(Done(&b""[..], 128i16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     760u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_tsti16(&[0, 128])), &(Done(&b""[..], -32768i16)))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     761u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn be_tsti32<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], i32, u32> {
                { if true { ::be_i32(i) } else { ::le_i32(i) } }
            }
            fn le_tsti32<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], i32, u32> {
                { if false { ::be_i32(i) } else { ::le_i32(i) } }
            }
            {
                match (&(be_tsti32(&[0, 18, 96, 0])),
                       &(Done(&b""[..], 1204224i32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     765u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_tsti32(&[0, 18, 96, 0])),
                       &(Done(&b""[..], 6296064i32))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     766u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            fn be_tsti64<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], i64, u32> {
                { if true { ::be_i64(i) } else { ::le_i64(i) } }
            }
            fn le_tsti64<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], i64, u32> {
                { if false { ::be_i64(i) } else { ::le_i64(i) } }
            }
            {
                match (&(be_tsti64(&[0, 255, 96, 0, 18, 0, 128, 0])),
                       &(Done(&b""[..], 71881672479506432i64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     770u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(le_tsti64(&[0, 255, 96, 0, 18, 0, 128, 0])),
                       &(Done(&b""[..], 36028874334732032i64))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     771u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn manual_configurable_endianness_test() {
            let x = 1;
            let int_parse: Box<Fn(&[u8]) -> IResult<&[u8], u16>> =
                if x == 2 { Box::new(be_u16) } else { Box::new(le_u16) };
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&int_parse(&b"3"[..]),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            {
                match (&(int_parse(&[128, 0])), &(Done(&b""[..], 128u16))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     784u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[allow(dead_code)]
        fn custom_error(input: &[u8]) -> IResult<&[u8], &[u8], ()> {
            {
                match alphanumeric(input) {
                    ::IResult::Incomplete(x) => ::IResult::Incomplete(x),
                    ::IResult::Done(i, o) => ::IResult::Done(i, o),
                    ::IResult::Error(e) => {
                        let err =
                            match e {
                                ::Err::Code(ErrorKind::Custom(_)) |
                                ::Err::Node(ErrorKind::Custom(_), _) => {
                                    let e: ErrorKind<()> = ErrorKind::Fix;
                                    ::Err::Code(e)
                                }
                                ::Err::Position(ErrorKind::Custom(_), p) |
                                ::Err::NodePosition(ErrorKind::Custom(_), p,
                                                    _) => {
                                    let e: ErrorKind<()> = ErrorKind::Fix;
                                    ::Err::Position(e, p)
                                }
                                ::Err::Code(_) | ::Err::Node(_, _) => {
                                    let e: ErrorKind<()> = ErrorKind::Fix;
                                    ::Err::Code(e)
                                }
                                ::Err::Position(_, p) |
                                ::Err::NodePosition(_, p, _) => {
                                    let e: ErrorKind<()> = ErrorKind::Fix;
                                    ::Err::Position(e, p)
                                }
                            };
                        ::IResult::Error(err)
                    }
                }
            }
        }
        #[test]
        pub fn hex_digit_test() {
            let empty = &b""[..];
            let i = &b"0123456789abcdefABCDEF"[..];
            {
                match (&(hex_digit(i)), &(Done(empty, i))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     797u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let i = &b"g"[..];
            {
                match (&(hex_digit(i)),
                       &(Error(Position(ErrorKind::HexDigit, i)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     800u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let i = &b"G"[..];
            {
                match (&(hex_digit(i)),
                       &(Error(Position(ErrorKind::HexDigit, i)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/nom.rs",
                                                                     803u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            if !is_hex_digit(b'0') {
                {
                    ::std::rt::begin_unwind("assertion failed: is_hex_digit(b\'0\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 805u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !is_hex_digit(b'9') {
                {
                    ::std::rt::begin_unwind("assertion failed: is_hex_digit(b\'9\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 806u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !is_hex_digit(b'a') {
                {
                    ::std::rt::begin_unwind("assertion failed: is_hex_digit(b\'a\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 807u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !is_hex_digit(b'f') {
                {
                    ::std::rt::begin_unwind("assertion failed: is_hex_digit(b\'f\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 808u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !is_hex_digit(b'A') {
                {
                    ::std::rt::begin_unwind("assertion failed: is_hex_digit(b\'A\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 809u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !is_hex_digit(b'F') {
                {
                    ::std::rt::begin_unwind("assertion failed: is_hex_digit(b\'F\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 810u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !!is_hex_digit(b'g') {
                {
                    ::std::rt::begin_unwind("assertion failed: !is_hex_digit(b\'g\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 811u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !!is_hex_digit(b'G') {
                {
                    ::std::rt::begin_unwind("assertion failed: !is_hex_digit(b\'G\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 812u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !!is_hex_digit(b'/') {
                {
                    ::std::rt::begin_unwind("assertion failed: !is_hex_digit(b\'/\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 813u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !!is_hex_digit(b':') {
                {
                    ::std::rt::begin_unwind("assertion failed: !is_hex_digit(b\':\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 814u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !!is_hex_digit(b'@') {
                {
                    ::std::rt::begin_unwind("assertion failed: !is_hex_digit(b\'@\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 815u32);
                                                &_FILE_LINE
                                            })
                }
            };
            if !!is_hex_digit(b'`') {
                {
                    ::std::rt::begin_unwind("assertion failed: !is_hex_digit(b\'`\')",
                                            {
                                                static _FILE_LINE:
                                                       (&'static str, u32) =
                                                    ("src/nom.rs", 816u32);
                                                &_FILE_LINE
                                            })
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::tag_closure;
            pub use super::character;
            pub use super::character_s;
            pub use super::offset;
            pub use super::is_not;
            pub use super::buffer_with_size;
            pub use super::length_value_test;
            pub use super::i8_tests;
            pub use super::i16_tests;
            pub use super::i32_tests;
            pub use super::i64_tests;
            pub use super::le_i8_tests;
            pub use super::le_i16_tests;
            pub use super::le_i32_tests;
            pub use super::le_i64_tests;
            pub use super::hex_u32_tests;
            pub use super::end_of_input;
            pub use super::configurable_endianness;
            pub use super::manual_configurable_endianness_test;
            pub use super::hex_digit_test;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[macro_use]
mod character {
    #[prelude_import]
    use std::prelude::v1::*;
    /// Character level parsers
    use internal::{IResult, Needed, Err};
    use util::ErrorKind;
    pub fn newline(i: &[u8]) -> ::IResult<&[u8], char, u32> {
        {
            if i.is_empty() {
                let res: ::IResult<&[u8], char> =
                    ::IResult::Incomplete(::Needed::Size(1));
                res
            } else {
                if i[0] == ('\n' as u8) {
                    ::IResult::Done(&i[1..], i[0] as char)
                } else {
                    ::IResult::Error(::Err::Position(::ErrorKind::Char, i))
                }
            }
        }
    }
    pub fn crlf(input: &[u8]) -> IResult<&[u8], char> {
        if input.len() < 2 {
            IResult::Incomplete(Needed::Size(2))
        } else {
            if &input[0..2] == &b"\r\n"[..] {
                IResult::Done(&input[2..], '\n')
            } else { IResult::Error(Err::Position(ErrorKind::CrLf, input)) }
        }
    }
    pub fn eol(i: &[u8]) -> ::IResult<&[u8], char, u32> {
        {
            {
                let res = crlf(i);
                match res {
                    ::IResult::Done(_, _) => res,
                    ::IResult::Incomplete(_) => res,
                    _ => {
                        match newline(i) {
                            ::IResult::Done(i, o) => ::IResult::Done(i, o),
                            ::IResult::Incomplete(x) =>
                            ::IResult::Incomplete(x),
                            ::IResult::Error(_) => {
                                ::IResult::Error(::Err::Position(::ErrorKind::Alt,
                                                                 i))
                            }
                        }
                    }
                }
            }
        }
    }
    pub fn tab(i: &[u8]) -> ::IResult<&[u8], char, u32> {
        {
            if i.is_empty() {
                let res: ::IResult<&[u8], char> =
                    ::IResult::Incomplete(::Needed::Size(1));
                res
            } else {
                if i[0] == ('\t' as u8) {
                    ::IResult::Done(&i[1..], i[0] as char)
                } else {
                    ::IResult::Error(::Err::Position(::ErrorKind::Char, i))
                }
            }
        }
    }
    pub fn anychar(input: &[u8]) -> IResult<&[u8], char> {
        if input.is_empty() {
            IResult::Incomplete(Needed::Size(1))
        } else { IResult::Done(&input[1..], input[0] as char) }
    }
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use internal::IResult::*;
        use internal::Err::*;
        use util::ErrorKind;
        #[test]
        pub fn one_of() {
            fn f<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], char, u32> {
                {
                    if i.is_empty() {
                        ::IResult::Incomplete::<_, _>(::Needed::Size(1))
                    } else {
                        #[inline(always)]
                        fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                            b.as_bytes()
                        }
                        let expected = "ab";
                        let bytes = as_bytes(&expected);
                        {
                            if i.is_empty() {
                                ::IResult::Incomplete::<_,
                                                        _>(::Needed::Size(1))
                            } else {
                                let mut found = false;
                                for &i in bytes {
                                    if i == i[0] { found = true; break ; }
                                }
                                if found {
                                    ::IResult::Done(&i[1..], i[0] as char)
                                } else {
                                    ::IResult::Error(::Err::Position(::ErrorKind::OneOf,
                                                                     i))
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcd"[..];
            {
                match (&(f(a)), &(Done(&b"bcd"[..], 'a'))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/character.rs",
                                                                     155u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b = &b"cde"[..];
            {
                match (&(f(b)), &(Error(Position(ErrorKind::OneOf, b)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/character.rs",
                                                                     158u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn none_of() {
            fn f<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], char, u32> {
                {
                    if i.is_empty() {
                        ::IResult::Incomplete::<_, _>(::Needed::Size(1))
                    } else {
                        #[inline(always)]
                        fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] {
                            b.as_bytes()
                        }
                        let expected = "ab";
                        let bytes = as_bytes(&expected);
                        {
                            if i.is_empty() {
                                ::IResult::Incomplete::<_,
                                                        _>(::Needed::Size(1))
                            } else {
                                let mut found = false;
                                for &i in bytes {
                                    if i == i[0] { found = true; break ; }
                                }
                                if !found {
                                    ::IResult::Done(&i[1..], i[0] as char)
                                } else {
                                    ::IResult::Error(::Err::Position(::ErrorKind::NoneOf,
                                                                     i))
                                }
                            }
                        }
                    }
                }
            }
            let a = &b"abcd"[..];
            {
                match (&(f(a)), &(Error(Position(ErrorKind::NoneOf, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/character.rs",
                                                                     166u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b = &b"cde"[..];
            {
                match (&(f(b)), &(Done(&b"de"[..], 'c'))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/character.rs",
                                                                     169u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn char() {
            fn f<'a>(i: &'a [u8]) -> ::IResult<&'a [u8], char, u32> {
                {
                    if i.is_empty() {
                        let res: ::IResult<&[u8], char> =
                            ::IResult::Incomplete(::Needed::Size(1));
                        res
                    } else {
                        if i[0] == ('c' as u8) {
                            ::IResult::Done(&i[1..], i[0] as char)
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::Char,
                                                             i))
                        }
                    }
                }
            }
            let a = &b"abcd"[..];
            {
                match (&(f(a)), &(Error(Position(ErrorKind::Char, a)))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/character.rs",
                                                                     177u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let b = &b"cde"[..];
            {
                match (&(f(b)), &(Done(&b"de"[..], 'c'))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/character.rs",
                                                                     180u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::one_of;
            pub use super::none_of;
            pub use super::char;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[macro_use]
#[cfg(not(feature = "core"))]
#[cfg(feature = "stream")]
mod stream {
    #[prelude_import]
    use std::prelude::v1::*;
    /// Context:
    /// * Rust does not have tail call optimization, so we cannot recurse wildly
    /// * data lifetimes makes sure that the result of a function applied to a producer cannot live longer than the producer's data (unless there is cloning)
    /// * previous implementation of Producer and Consumer spent its time copying buffers
    /// * the old Consumer was handling everything and buffering data. The new design has the producer handle data, but the consumer makes seeking decision
    use std::io::{self, Read, Write, Seek, SeekFrom};
    use std::fs::File;
    use std::path::Path;
    use std::ptr;
    use std::iter::repeat;
    use internal::Needed;
    pub enum Input<I> { Element(I), Empty, Eof(Option<I>), }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <I: ::std::clone::Clone> ::std::clone::Clone for Input<I> {
        #[inline]
        fn clone(&self) -> Input<I> {
            match (&*self,) {
                (&Input::Element(ref __self_0),) =>
                Input::Element(::std::clone::Clone::clone(&(*__self_0))),
                (&Input::Empty,) => Input::Empty,
                (&Input::Eof(ref __self_0),) =>
                Input::Eof(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <I: ::std::fmt::Debug> ::std::fmt::Debug for Input<I> {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Input::Element(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Element");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Input::Empty,) => {
                    let mut builder = __arg_0.debug_tuple("Empty");
                    builder.finish()
                }
                (&Input::Eof(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Eof");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    /// Stores a consumer's current computation state
    pub enum ConsumerState<O, E = (), M = ()> {

        /// A value of type O has been produced
        Done(M, O),

        /// An error of type E has been encountered
        Error(E),

        /// Continue applying, and pass a message of type M to the data source
        Continue(M),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <O: ::std::clone::Clone, E: ::std::clone::Clone,
          M: ::std::clone::Clone> ::std::clone::Clone for
     ConsumerState<O, E, M> {
        #[inline]
        fn clone(&self) -> ConsumerState<O, E, M> {
            match (&*self,) {
                (&ConsumerState::Done(ref __self_0, ref __self_1),) =>
                ConsumerState::Done(::std::clone::Clone::clone(&(*__self_0)),
                                    ::std::clone::Clone::clone(&(*__self_1))),
                (&ConsumerState::Error(ref __self_0),) =>
                ConsumerState::Error(::std::clone::Clone::clone(&(*__self_0))),
                (&ConsumerState::Continue(ref __self_0),) =>
                ConsumerState::Continue(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <O: ::std::fmt::Debug, E: ::std::fmt::Debug, M: ::std::fmt::Debug>
     ::std::fmt::Debug for ConsumerState<O, E, M> {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&ConsumerState::Done(ref __self_0, ref __self_1),) => {
                    let mut builder = __arg_0.debug_tuple("Done");
                    let _ = builder.field(&&(*__self_0));
                    let _ = builder.field(&&(*__self_1));
                    builder.finish()
                }
                (&ConsumerState::Error(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Error");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&ConsumerState::Continue(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Continue");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    impl <O: Clone, E: Copy, M: Copy> ConsumerState<O, E, M> {
        pub fn map<P, F>(&self, f: F) -> ConsumerState<P, E, M> where
         F: FnOnce(O) -> P {
            match *self {
                ConsumerState::Error(e) => ConsumerState::Error(e),
                ConsumerState::Continue(m) => ConsumerState::Continue(m),
                ConsumerState::Done(m, ref o) =>
                ConsumerState::Done(m, f(o.clone())),
            }
        }
        pub fn flat_map<P, F>(&self, f: F) -> ConsumerState<P, E, M> where
         F: FnOnce(M, O) -> ConsumerState<P, E, M> {
            match *self {
                ConsumerState::Error(e) => ConsumerState::Error(e),
                ConsumerState::Continue(m) => ConsumerState::Continue(m),
                ConsumerState::Done(m, ref o) => f(m, o.clone()),
            }
        }
    }
    /// The Consumer trait wraps a computation and its state
    ///
    /// it depends on the input type I, the produced value's type O, the error type E, and the message type M
    pub trait Consumer<I, O, E, M> {
        /// implement handle for the current computation, returning the new state of the consumer
        fn handle(&mut self, input: Input<I>)
        -> &ConsumerState<O, E, M>;
        /// returns the current state
        fn state(&self)
        -> &ConsumerState<O, E, M>;
    }
    /// The producer wraps a data source, like file or network, and applies a consumer on it
    ///
    /// it handles buffer copying and reallocation, to provide streaming patterns.
    /// it depends on the input type I, and the message type M.
    /// the consumer can change the way data is produced (for example, to seek in the source) by sending a message of type M.
    pub trait Producer<'b, I, M: 'b> {
        /// Applies a consumer once on the produced data, and return the consumer's state
        ///
        /// a new producer has to implement this method.
        ///
        /// WARNING: if the `ConsumerState` generated by your consumer has a reference
        /// to the input, it will generate borrow checking errors such as
        /// `error: cannot borrow `producer` as mutable more than once at a time [E0499]`.
        ///
        /// It is caused by the producer's ability to refill the input at will, so it can modify
        /// the input slice the `ConsumerState` is referring to.
        ///
        /// To avoid that kind of issue, try to do all the computations on input slices inside the
        /// `Consumer` chain
        fn apply<'a, O,
                 E>(&'b mut self, consumer: &'a mut Consumer<I, O, E, M>)
        -> &'a ConsumerState<O, E, M>;
        /// Applies a consumer once on the produced data, and returns the generated value if there is one
        fn run<'a:'b, O,
               E: 'b>(&'b mut self, consumer: &'a mut Consumer<I, O, E, M>)
         -> Option<&O> {
            if let &ConsumerState::Done(_, ref o) = self.apply(consumer) {
                Some(o)
            } else { None }
        }
    }
    /// ProducerRepeat takes a single value, and generates it at each step
    pub struct ProducerRepeat<I: Copy> {
        value: I,
    }
    impl <'b, I: Copy, M: 'b> Producer<'b, I, M> for ProducerRepeat<I> {
        fn apply<'a, O,
                 E>(&'b mut self, consumer: &'a mut Consumer<I, O, E, M>)
         -> &'a ConsumerState<O, E, M> {
            if {
                   if let &ConsumerState::Continue(_) = consumer.state() {
                       true
                   } else { false }
               } {
                consumer.handle(Input::Element(self.value))
            } else { consumer.state() }
        }
    }
    /// A MemProducer generates values from an in memory byte buffer
    ///
    /// it generates data by chunks, and keeps track of how much was consumed.
    /// It can receive messages of type `Move` to handle consumption and seeking
    pub struct MemProducer<'x> {
        buffer: &'x [u8],
        chunk_size: usize,
        length: usize,
        index: usize,
    }
    impl <'x> MemProducer<'x> {
        pub fn new(buffer: &'x [u8], chunk_size: usize) -> MemProducer {
            MemProducer{buffer: buffer,
                        chunk_size: chunk_size,
                        length: buffer.len(),
                        index: 0,}
        }
    }
    pub enum Move {

        /// indcates how much data was consumed
        Consume(usize),

        /// indicates where in the input the consumer must seek
        Seek(SeekFrom),

        /// indicates more data is needed
        Await(Needed),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Move {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&Move::Consume(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
                (&Move::Seek(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
                (&Move::Await(ref __self_0),) => {
                    (*__self_0).assert_receiver_is_total_eq();
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Move {
        #[inline]
        fn eq(&self, __arg_0: &Move) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&Move::Consume(ref __self_0),
                         &Move::Consume(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        (&Move::Seek(ref __self_0),
                         &Move::Seek(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        (&Move::Await(ref __self_0),
                         &Move::Await(ref __arg_1_0)) =>
                        true && (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &Move) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&Move::Consume(ref __self_0),
                         &Move::Consume(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        (&Move::Seek(ref __self_0),
                         &Move::Seek(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        (&Move::Await(ref __self_0),
                         &Move::Await(ref __arg_1_0)) =>
                        false || (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Move { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Move {
        #[inline]
        fn clone(&self) -> Move {
            match (&*self,) {
                (&Move::Consume(ref __self_0),) =>
                Move::Consume(::std::clone::Clone::clone(&(*__self_0))),
                (&Move::Seek(ref __self_0),) =>
                Move::Seek(::std::clone::Clone::clone(&(*__self_0))),
                (&Move::Await(ref __self_0),) =>
                Move::Await(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Move {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&Move::Consume(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Consume");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Move::Seek(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Seek");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
                (&Move::Await(ref __self_0),) => {
                    let mut builder = __arg_0.debug_tuple("Await");
                    let _ = builder.field(&&(*__self_0));
                    builder.finish()
                }
            }
        }
    }
    impl <'x, 'b> Producer<'b, &'x [u8], Move> for MemProducer<'x> {
        fn apply<'a, O,
                 E>(&'b mut self,
                    consumer: &'a mut Consumer<&'x [u8], O, E, Move>)
         -> &'a ConsumerState<O, E, Move> {
            if {
                   if let &ConsumerState::Continue(ref m) = consumer.state() {
                       match *m {
                           Move::Consume(s) => {
                               if self.length - self.index >= s {
                                   self.index += s
                               } else {
                                   {
                                       ::std::rt::begin_unwind("cannot consume past the end of the buffer",
                                                               {
                                                                   static _FILE_LINE:
                                                                          (&'static str,
                                                                           u32)
                                                                          =
                                                                       ("src/stream.rs",
                                                                        156u32);
                                                                   &_FILE_LINE
                                                               })
                                   };
                               }
                           }
                           Move::Await(a) => {
                               {
                                   ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                                 static __STATIC_FMTSTR:
                                                                                                        &'static [&'static str]
                                                                                                        =
                                                                                                     &["not handled for now: await("];
                                                                                                 __STATIC_FMTSTR
                                                                                             },
                                                                                             &match (&a,)
                                                                                                  {
                                                                                                  (__arg0,)
                                                                                                  =>
                                                                                                  [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                               ::std::fmt::Debug::fmt)],
                                                                                              }),
                                                               {
                                                                   static _FILE_LINE:
                                                                          (&'static str,
                                                                           u32)
                                                                          =
                                                                       ("src/stream.rs",
                                                                        160u32);
                                                                   &_FILE_LINE
                                                               })
                               };
                           }
                           Move::Seek(SeekFrom::Start(position)) => {
                               if (position as usize) > self.length {
                                   self.index = self.length
                               } else { self.index = position as usize }
                           }
                           Move::Seek(SeekFrom::Current(offset)) => {
                               let next =
                                   if offset >= 0 {
                                       (self.index as
                                            u64).checked_add(offset as u64)
                                   } else {
                                       (self.index as
                                            u64).checked_sub(-offset as u64)
                                   };
                               match next {
                                   None => None,
                                   Some(u) => {
                                       if (u as usize) > self.length {
                                           self.index = self.length
                                       } else { self.index = u as usize }
                                       Some(self.index as u64)
                                   }
                               };
                           }
                           Move::Seek(SeekFrom::End(i)) => {
                               let next =
                                   if i < 0 {
                                       (self.length as
                                            u64).checked_sub(-i as u64)
                                   } else { Some(self.length as u64) };
                               match next {
                                   None => None,
                                   Some(u) => {
                                       self.index = u as usize;
                                       Some(u)
                                   }
                               };
                           }
                       }
                       true
                   } else { false }
               } {
                use std::cmp;
                let end = cmp::min(self.index + self.chunk_size, self.length);
                consumer.handle(Input::Element(&self.buffer[self.index..end]))
            } else { consumer.state() }
        }
    }
    pub enum FileProducerState { Normal, Error, Eof, }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for FileProducerState {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            match (&*self,) {
                (&FileProducerState::Normal,) => { }
                (&FileProducerState::Error,) => { }
                (&FileProducerState::Eof,) => { }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FileProducerState {
        #[inline]
        fn eq(&self, __arg_0: &FileProducerState) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&FileProducerState::Normal,
                         &FileProducerState::Normal) => true,
                        (&FileProducerState::Error, &FileProducerState::Error)
                        => true,
                        (&FileProducerState::Eof, &FileProducerState::Eof) =>
                        true,
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { false }
            }
        }
        #[inline]
        fn ne(&self, __arg_0: &FileProducerState) -> bool {
            {
                let __self_vi =
                    unsafe { ::std::intrinsics::discriminant_value(&*self) }
                        as i32;
                let __arg_1_vi =
                    unsafe {
                        ::std::intrinsics::discriminant_value(&*__arg_0)
                    } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*__arg_0) {
                        (&FileProducerState::Normal,
                         &FileProducerState::Normal) => false,
                        (&FileProducerState::Error, &FileProducerState::Error)
                        => false,
                        (&FileProducerState::Eof, &FileProducerState::Eof) =>
                        false,
                        _ => unsafe { ::std::intrinsics::unreachable() }
                    }
                } else { true }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FileProducerState {
        #[inline]
        fn clone(&self) -> FileProducerState {
            match (&*self,) {
                (&FileProducerState::Normal,) => FileProducerState::Normal,
                (&FileProducerState::Error,) => FileProducerState::Error,
                (&FileProducerState::Eof,) => FileProducerState::Eof,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FileProducerState { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FileProducerState {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match (&*self,) {
                (&FileProducerState::Normal,) => {
                    let mut builder = __arg_0.debug_tuple("Normal");
                    builder.finish()
                }
                (&FileProducerState::Error,) => {
                    let mut builder = __arg_0.debug_tuple("Error");
                    builder.finish()
                }
                (&FileProducerState::Eof,) => {
                    let mut builder = __arg_0.debug_tuple("Eof");
                    builder.finish()
                }
            }
        }
    }
    pub struct FileProducer {
        size: usize,
        file: File,
        position: usize,
        v: Vec<u8>,
        start: usize,
        end: usize,
        state: FileProducerState,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FileProducer {
        fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
         -> ::std::fmt::Result {
            match *self {
                FileProducer {
                size: ref __self_0_0,
                file: ref __self_0_1,
                position: ref __self_0_2,
                v: ref __self_0_3,
                start: ref __self_0_4,
                end: ref __self_0_5,
                state: ref __self_0_6 } => {
                    let mut builder = __arg_0.debug_struct("FileProducer");
                    let _ = builder.field("size", &&(*__self_0_0));
                    let _ = builder.field("file", &&(*__self_0_1));
                    let _ = builder.field("position", &&(*__self_0_2));
                    let _ = builder.field("v", &&(*__self_0_3));
                    let _ = builder.field("start", &&(*__self_0_4));
                    let _ = builder.field("end", &&(*__self_0_5));
                    let _ = builder.field("state", &&(*__self_0_6));
                    builder.finish()
                }
            }
        }
    }
    impl FileProducer {
        pub fn new(filename: &str, buffer_size: usize)
         -> io::Result<FileProducer> {
            File::open(&Path::new(filename)).and_then(|mut f| {
                                                      f.seek(SeekFrom::Start(0)).map(|_|
                                                                                         {
                                                                                     let mut v =
                                                                                         Vec::with_capacity(buffer_size);
                                                                                     v.extend(repeat(0).take(buffer_size));
                                                                                     FileProducer{size:
                                                                                                      buffer_size,
                                                                                                  file:
                                                                                                      f,
                                                                                                  position:
                                                                                                      0,
                                                                                                  v:
                                                                                                      v,
                                                                                                  start:
                                                                                                      0,
                                                                                                  end:
                                                                                                      0,
                                                                                                  state:
                                                                                                      FileProducerState::Normal,}
                                                                                 })
                                                  })
        }
        pub fn state(&self) -> FileProducerState { self.state }
        pub fn refill(&mut self) -> Option<usize> {
            shift(&mut self.v, self.start, self.end);
            self.end = self.end - self.start;
            self.start = 0;
            match self.file.read(&mut self.v[self.end..]) {
                Err(_) => { self.state = FileProducerState::Error; None }
                Ok(n) => {
                    if n == 0 { self.state = FileProducerState::Eof; }
                    self.end += n;
                    Some(0)
                }
            }
        }
        /// Resize the internal buffer, copy the data to the new one and returned how much data was copied
        ///
        /// If the new buffer is smaller, the prefix will be copied, and the rest of the data will be dropped
        pub fn resize(&mut self, s: usize) -> usize {
            let mut v = ::std::vec::from_elem(0, s);
            let length = self.end - self.start;
            let size = if length <= s { length } else { s };
            (&mut v[..]).write(&self.v[self.start..self.start +
                                                       size]).unwrap();
            self.v = v;
            self.start = 0;
            self.end = size;
            size
        }
    }
    pub fn shift(s: &mut [u8], start: usize, end: usize) {
        if start > 0 {
            unsafe {
                let length = end - start;
                ptr::copy((&s[start..end]).as_ptr(),
                          (&mut s[..length]).as_mut_ptr(), length);
            }
        }
    }
    impl <'x> Producer<'x, &'x [u8], Move> for FileProducer {
        fn apply<'a, O,
                 E>(&'x mut self,
                    consumer: &'a mut Consumer<&'x [u8], O, E, Move>)
         -> &'a ConsumerState<O, E, Move> {
            if {
                   if let &ConsumerState::Continue(ref m) = consumer.state() {
                       match *m {
                           Move::Consume(s) => {
                               if self.end - self.start >= s {
                                   self.start = self.start + s;
                                   self.position = self.position + s;
                               } else {
                                   {
                                       ::std::rt::begin_unwind("cannot consume past the end of the buffer",
                                                               {
                                                                   static _FILE_LINE:
                                                                          (&'static str,
                                                                           u32)
                                                                          =
                                                                       ("src/stream.rs",
                                                                        322u32);
                                                                   &_FILE_LINE
                                                               })
                                   };
                               }
                               if self.start == self.end { self.refill(); }
                           }
                           Move::Await(_) => { self.refill(); }
                           Move::Seek(position) => {
                               let pos =
                                   match position {
                                       SeekFrom::Current(c) =>
                                       SeekFrom::Current(c -
                                                             ((self.end -
                                                                   self.start)
                                                                  as i64)),
                                       default => default,
                                   };
                               match self.file.seek(pos) {
                                   Ok(pos) => {
                                       self.position = pos as usize;
                                       self.start = 0;
                                       self.end = 0;
                                       self.refill();
                                   }
                                   Err(_) => {
                                       self.state = FileProducerState::Error;
                                   }
                               }
                           }
                       }
                       true
                   } else { false }
               } {
                match self.state {
                    FileProducerState::Normal =>
                    consumer.handle(Input::Element(&self.v[self.start..self.end])),
                    FileProducerState::Eof => {
                        let slice = &self.v[self.start..self.end];
                        if slice.is_empty() {
                            consumer.handle(Input::Eof(None))
                        } else { consumer.handle(Input::Eof(Some(slice))) }
                    }
                    FileProducerState::Error => consumer.state(),
                }
            } else { consumer.state() }
        }
    }
    use std::marker::PhantomData;
    /// MapConsumer takes a function S -> T and applies it on a consumer producing values of type S
    pub struct MapConsumer<'a, C: 'a, R, S, T, E, M, F> {
        state: ConsumerState<T, E, M>,
        consumer: &'a mut C,
        f: F,
        consumer_input_type: PhantomData<R>,
        f_input_type: PhantomData<S>,
        f_output_type: PhantomData<T>,
    }
    impl <'a, R, S: Clone, T, E: Clone, M: Clone, F: Fn(S) -> T,
          C: Consumer<R, S, E, M>> MapConsumer<'a, C, R, S, T, E, M, F> {
        pub fn new(c: &'a mut C, f: F)
         -> MapConsumer<'a, C, R, S, T, E, M, F> {
            let initial =
                match *c.state() {
                    ConsumerState::Done(ref m, ref o) =>
                    ConsumerState::Done(m.clone(), f(o.clone())),
                    ConsumerState::Error(ref e) =>
                    ConsumerState::Error(e.clone()),
                    ConsumerState::Continue(ref m) =>
                    ConsumerState::Continue(m.clone()),
                };
            MapConsumer{state: initial,
                        consumer: c,
                        f: f,
                        consumer_input_type: PhantomData,
                        f_input_type: PhantomData,
                        f_output_type: PhantomData,}
        }
    }
    impl <'a, R, S: Clone, T, E: Clone, M: Clone, F: Fn(S) -> T,
          C: Consumer<R, S, E, M>> Consumer<R, T, E, M> for
     MapConsumer<'a, C, R, S, T, E, M, F> {
        fn handle(&mut self, input: Input<R>) -> &ConsumerState<T, E, M> {
            let res: &ConsumerState<S, E, M> = self.consumer.handle(input);
            self.state =
                match res {
                    &ConsumerState::Done(ref m, ref o) =>
                    ConsumerState::Done(m.clone(), (self.f)(o.clone())),
                    &ConsumerState::Error(ref e) =>
                    ConsumerState::Error(e.clone()),
                    &ConsumerState::Continue(ref m) =>
                    ConsumerState::Continue(m.clone()),
                };
            &self.state
        }
        fn state(&self) -> &ConsumerState<T, E, M> { &self.state }
    }
    /// ChainConsumer takes a consumer C1 R -> S, and a consumer C2 S -> T, and makes a consumer R -> T by applying C2 on C1's result
    pub struct ChainConsumer<'a, 'b, C1: 'a, C2: 'b, R, S, T, E, M> {
        state: ConsumerState<T, E, M>,
        consumer1: &'a mut C1,
        consumer2: &'b mut C2,
        input_type: PhantomData<R>,
        temp_type: PhantomData<S>,
    }
    impl <'a, 'b, R, S: Clone, T: Clone, E: Clone, M: Clone,
          C1: Consumer<R, S, E, M>, C2: Consumer<S, T, E, M>>
     ChainConsumer<'a, 'b, C1, C2, R, S, T, E, M> {
        pub fn new(c1: &'a mut C1, c2: &'b mut C2)
         -> ChainConsumer<'a, 'b, C1, C2, R, S, T, E, M> {
            let initial =
                match *c1.state() {
                    ConsumerState::Error(ref e) =>
                    ConsumerState::Error(e.clone()),
                    ConsumerState::Continue(ref m) =>
                    ConsumerState::Continue(m.clone()),
                    ConsumerState::Done(ref m, ref o) =>
                    match *c2.handle(Input::Element(o.clone())) {
                        ConsumerState::Error(ref e) =>
                        ConsumerState::Error(e.clone()),
                        ConsumerState::Continue(ref m2) =>
                        ConsumerState::Continue(m2.clone()),
                        ConsumerState::Done(_, ref o2) =>
                        ConsumerState::Done(m.clone(), o2.clone()),
                    },
                };
            ChainConsumer{state: initial,
                          consumer1: c1,
                          consumer2: c2,
                          input_type: PhantomData,
                          temp_type: PhantomData,}
        }
    }
    impl <'a, 'b, R, S: Clone, T: Clone, E: Clone, M: Clone,
          C1: Consumer<R, S, E, M>, C2: Consumer<S, T, E, M>>
     Consumer<R, T, E, M> for ChainConsumer<'a, 'b, C1, C2, R, S, T, E, M> {
        fn handle(&mut self, input: Input<R>) -> &ConsumerState<T, E, M> {
            let res: &ConsumerState<S, E, M> = self.consumer1.handle(input);
            self.state =
                match *res {
                    ConsumerState::Error(ref e) =>
                    ConsumerState::Error(e.clone()),
                    ConsumerState::Continue(ref m) =>
                    ConsumerState::Continue(m.clone()),
                    ConsumerState::Done(ref m, ref o) =>
                    match *self.consumer2.handle(Input::Element(o.clone())) {
                        ConsumerState::Error(ref e) =>
                        ConsumerState::Error(e.clone()),
                        ConsumerState::Continue(ref m) =>
                        ConsumerState::Continue(m.clone()),
                        ConsumerState::Done(_, ref o2) =>
                        ConsumerState::Done(m.clone(), o2.clone()),
                    },
                };
            &self.state
        }
        fn state(&self) -> &ConsumerState<T, E, M> { &self.state }
    }
    #[cfg(test)]
    mod tests {
        #[prelude_import]
        use std::prelude::v1::*;
        use super::*;
        use internal::IResult;
        use util::HexDisplay;
        use std::str::from_utf8;
        use std::io::SeekFrom;
        struct AbcdConsumer<'a> {
            state: ConsumerState<&'a [u8], (), Move>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::std::fmt::Debug for AbcdConsumer<'a> {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    AbcdConsumer { state: ref __self_0_0 } => {
                        let mut builder =
                            __arg_0.debug_struct("AbcdConsumer");
                        let _ = builder.field("state", &&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        fn abcd(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
            {
                #[inline(always)]
                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                let expected = "abcd";
                let bytes = as_bytes(&expected);
                {
                    use std::cmp::min;
                    let len = i.len();
                    let blen = bytes.len();
                    let m = min(len, blen);
                    let reduced = &i[..m];
                    let b = &bytes[..m];
                    let res: ::IResult<_, _> =
                        if reduced != b {
                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                             i))
                        } else if m < blen {
                            ::IResult::Incomplete(::Needed::Size(blen))
                        } else { ::IResult::Done(&i[blen..], reduced) };
                    res
                }
            }
        }
        impl <'a> Consumer<&'a [u8], &'a [u8], (), Move> for AbcdConsumer<'a>
         {
            fn handle(&mut self, input: Input<&'a [u8]>)
             -> &ConsumerState<&'a [u8], (), Move> {
                match input {
                    Input::Empty | Input::Eof(None) => &self.state,
                    Input::Element(sl) => {
                        match abcd(sl) {
                            IResult::Error(_) => {
                                self.state = ConsumerState::Error(())
                            }
                            IResult::Incomplete(_) => {
                                self.state =
                                    ConsumerState::Continue(Move::Consume(0))
                            }
                            IResult::Done(i, o) => {
                                self.state =
                                    ConsumerState::Done(Move::Consume(sl.offset(i)),
                                                        o)
                            }
                        };
                        &self.state
                    }
                    Input::Eof(Some(sl)) => {
                        match abcd(sl) {
                            IResult::Error(_) => {
                                self.state = ConsumerState::Error(())
                            }
                            IResult::Incomplete(_) => {
                                self.state = ConsumerState::Error(())
                            }
                            IResult::Done(i, o) => {
                                self.state =
                                    ConsumerState::Done(Move::Consume(sl.offset(i)),
                                                        o)
                            }
                        };
                        &self.state
                    }
                }
            }
            fn state(&self) -> &ConsumerState<&'a [u8], (), Move> {
                &self.state
            }
        }
        #[test]
        pub fn mem() {
            let mut m = MemProducer::new(&b"abcdabcdabcdabcdabcd"[..], 8);
            let mut a =
                AbcdConsumer{state:
                                 ConsumerState::Continue(Move::Consume(0)),};
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
        }
        fn efgh(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
            {
                #[inline(always)]
                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                let expected = "efgh";
                let bytes = as_bytes(&expected);
                {
                    use std::cmp::min;
                    let len = i.len();
                    let blen = bytes.len();
                    let m = min(len, blen);
                    let reduced = &i[..m];
                    let b = &bytes[..m];
                    let res: ::IResult<_, _> =
                        if reduced != b {
                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                             i))
                        } else if m < blen {
                            ::IResult::Incomplete(::Needed::Size(blen))
                        } else { ::IResult::Done(&i[blen..], reduced) };
                    res
                }
            }
        }
        fn ijkl(i: &[u8]) -> ::IResult<&[u8], &[u8], u32> {
            {
                #[inline(always)]
                fn as_bytes<T: ::AsBytes>(b: &T) -> &[u8] { b.as_bytes() }
                let expected = "ijkl";
                let bytes = as_bytes(&expected);
                {
                    use std::cmp::min;
                    let len = i.len();
                    let blen = bytes.len();
                    let m = min(len, blen);
                    let reduced = &i[..m];
                    let b = &bytes[..m];
                    let res: ::IResult<_, _> =
                        if reduced != b {
                            ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                             i))
                        } else if m < blen {
                            ::IResult::Incomplete(::Needed::Size(blen))
                        } else { ::IResult::Done(&i[blen..], reduced) };
                    res
                }
            }
        }
        enum State { Initial, A, B, End, Error, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for State {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&State::Initial,) => {
                        let mut builder = __arg_0.debug_tuple("Initial");
                        builder.finish()
                    }
                    (&State::A,) => {
                        let mut builder = __arg_0.debug_tuple("A");
                        builder.finish()
                    }
                    (&State::B,) => {
                        let mut builder = __arg_0.debug_tuple("B");
                        builder.finish()
                    }
                    (&State::End,) => {
                        let mut builder = __arg_0.debug_tuple("End");
                        builder.finish()
                    }
                    (&State::Error,) => {
                        let mut builder = __arg_0.debug_tuple("Error");
                        builder.finish()
                    }
                }
            }
        }
        struct StateConsumer<'a> {
            state: ConsumerState<&'a [u8], (), Move>,
            parsing_state: State,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::std::fmt::Debug for StateConsumer<'a> {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    StateConsumer {
                    state: ref __self_0_0, parsing_state: ref __self_0_1 } =>
                    {
                        let mut builder =
                            __arg_0.debug_struct("StateConsumer");
                        let _ = builder.field("state", &&(*__self_0_0));
                        let _ =
                            builder.field("parsing_state", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl <'a> Consumer<&'a [u8], &'a [u8], (), Move> for StateConsumer<'a>
         {
            fn handle(&mut self, input: Input<&'a [u8]>)
             -> &ConsumerState<&'a [u8], (), Move> {
                match input {
                    Input::Empty | Input::Eof(None) => &self.state,
                    Input::Element(sl) => {
                        match self.parsing_state {
                            State::Initial =>
                            match abcd(sl) {
                                IResult::Error(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Incomplete(_) => {
                                    self.state =
                                        ConsumerState::Continue(Move::Consume(0))
                                }
                                IResult::Done(i, _) => {
                                    self.parsing_state = State::A;
                                    self.state =
                                        ConsumerState::Continue(Move::Consume(sl.offset(i)))
                                }
                            },
                            State::A =>
                            match efgh(sl) {
                                IResult::Error(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Incomplete(_) => {
                                    self.state =
                                        ConsumerState::Continue(Move::Consume(0))
                                }
                                IResult::Done(i, _) => {
                                    self.parsing_state = State::B;
                                    self.state =
                                        ConsumerState::Continue(Move::Consume(sl.offset(i)))
                                }
                            },
                            State::B =>
                            match ijkl(sl) {
                                IResult::Error(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Incomplete(_) => {
                                    self.state =
                                        ConsumerState::Continue(Move::Consume(0))
                                }
                                IResult::Done(i, o) => {
                                    self.parsing_state = State::End;
                                    self.state =
                                        ConsumerState::Done(Move::Consume(sl.offset(i)),
                                                            o)
                                }
                            },
                            _ => {
                                self.parsing_state = State::Error;
                                self.state = ConsumerState::Error(())
                            }
                        }
                        &self.state
                    }
                    Input::Eof(Some(sl)) => {
                        match self.parsing_state {
                            State::Initial =>
                            match abcd(sl) {
                                IResult::Error(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Incomplete(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Done(_, _) => {
                                    self.parsing_state = State::A;
                                    self.state = ConsumerState::Error(())
                                }
                            },
                            State::A =>
                            match efgh(sl) {
                                IResult::Error(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Incomplete(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Done(_, _) => {
                                    self.parsing_state = State::B;
                                    self.state = ConsumerState::Error(())
                                }
                            },
                            State::B =>
                            match ijkl(sl) {
                                IResult::Error(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Incomplete(_) => {
                                    self.parsing_state = State::Error;
                                    self.state = ConsumerState::Error(())
                                }
                                IResult::Done(i, o) => {
                                    self.parsing_state = State::End;
                                    self.state =
                                        ConsumerState::Done(Move::Consume(sl.offset(i)),
                                                            o)
                                }
                            },
                            _ => {
                                self.parsing_state = State::Error;
                                self.state = ConsumerState::Error(())
                            }
                        }
                        &self.state
                    }
                }
            }
            fn state(&self) -> &ConsumerState<&'a [u8], (), Move> {
                &self.state
            }
        }
        impl <'a> StateConsumer<'a> {
            fn parsing(&self) -> &State { &self.parsing_state }
        }
        #[test]
        pub fn mem2() {
            let mut m = MemProducer::new(&b"abcdefghijklabcdabcd"[..], 8);
            let mut a =
                StateConsumer{state:
                                  ConsumerState::Continue(Move::Consume(0)),
                              parsing_state: State::Initial,};
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["state ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&a.parsing(),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["state ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&a.parsing(),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["state ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&a.parsing(),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["state ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&a.parsing(),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
        }
        #[test]
        pub fn map() {
            let mut m = MemProducer::new(&b"abcdefghijklabcdabcd"[..], 8);
            let mut s =
                StateConsumer{state:
                                  ConsumerState::Continue(Move::Consume(0)),
                              parsing_state: State::Initial,};
            let mut a = MapConsumer::new(&mut s, from_utf8);
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
        }
        struct StrConsumer<'a> {
            state: ConsumerState<&'a str, (), Move>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl <'a> ::std::fmt::Debug for StrConsumer<'a> {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    StrConsumer { state: ref __self_0_0 } => {
                        let mut builder = __arg_0.debug_struct("StrConsumer");
                        let _ = builder.field("state", &&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        impl <'a> Consumer<&'a [u8], &'a str, (), Move> for StrConsumer<'a> {
            fn handle(&mut self, input: Input<&'a [u8]>)
             -> &ConsumerState<&'a str, (), Move> {
                match input {
                    Input::Empty | Input::Eof(None) => &self.state,
                    Input::Element(sl) | Input::Eof(Some(sl)) => {
                        self.state =
                            ConsumerState::Done(Move::Consume(sl.len()),
                                                from_utf8(sl).unwrap());
                        &self.state
                    }
                }
            }
            fn state(&self) -> &ConsumerState<&'a str, (), Move> {
                &self.state
            }
        }
        #[test]
        pub fn chain() {
            let mut m = MemProducer::new(&b"abcdefghijklabcdabcd"[..], 8);
            let mut s1 =
                StateConsumer{state:
                                  ConsumerState::Continue(Move::Consume(0)),
                              parsing_state: State::Initial,};
            let mut s2 =
                StrConsumer{state:
                                ConsumerState::Continue(Move::Consume(0)),};
            let mut a = ChainConsumer::new(&mut s1, &mut s2);
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["apply ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&m.apply(&mut a),)
                                                                 {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
        }
        #[test]
        pub fn shift_test() {
            let mut v =
                <[_]>::into_vec(::std::boxed::Box::new([0, 1, 2, 3, 4, 5]));
            shift(&mut v, 1, 3);
            {
                match (&(&v[..2]), &(&[1, 2][..])) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/stream.rs",
                                                                     854u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            let mut v2 =
                <[_]>::into_vec(::std::boxed::Box::new([0, 1, 2, 3, 4, 5]));
            shift(&mut v2, 2, 6);
            {
                match (&(&v2[..4]), &(&[2, 3, 4, 5][..])) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/stream.rs",
                                                                     857u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        fn lf(i: &u8) -> bool { *i == ('\n' as u8) }
        fn to_utf8_string(input: &[u8]) -> String {
            String::from(from_utf8(input).unwrap())
        }
        struct LineConsumer {
            state: ::ConsumerState<String, (), ::Move>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for LineConsumer {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    LineConsumer { state: ref __self_0_0 } => {
                        let mut builder =
                            __arg_0.debug_struct("LineConsumer");
                        let _ = builder.field("state", &&(*__self_0_0));
                        builder.finish()
                    }
                }
            }
        }
        impl LineConsumer {
            fn new() -> LineConsumer {
                LineConsumer{state:
                                 ::ConsumerState::Continue(::Move::Consume(0)),}
            }
        }
        impl <'a> ::Consumer<&'a [u8], String, (), ::Move> for LineConsumer {
            fn handle(&mut self, input: ::Input<&'a [u8]>)
             -> &::ConsumerState<String, (), ::Move> {
                use HexDisplay;
                match input {
                    ::Input::Empty | ::Input::Eof(None) => &self.state,
                    ::Input::Element(sl) | ::Input::Eof(Some(sl)) => {
                        self.state =
                            match {
                                      match {
                                                match {
                                                          match sl.iter().position(|c|
                                                                                       lf(c))
                                                              {
                                                              Some(n) =>
                                                              ::IResult::Done(&sl[n..],
                                                                              &sl[..n]),
                                                              None =>
                                                              ::IResult::Done(&b""[..],
                                                                              sl),
                                                          }
                                                      } {
                                                    ::IResult::Error(a) =>
                                                    ::IResult::Error(a),
                                                    ::IResult::Incomplete(i)
                                                    =>
                                                    ::IResult::Incomplete(i),
                                                    ::IResult::Done(i1, o1) =>
                                                    {
                                                        match {
                                                                  #[inline(always)]
                                                                  fn as_bytes<T: ::AsBytes>(b:
                                                                                                &T)
                                                                   -> &[u8] {
                                                                      b.as_bytes()
                                                                  }
                                                                  let expected =
                                                                      "\n";
                                                                  let bytes =
                                                                      as_bytes(&expected);
                                                                  {
                                                                      use std::cmp::min;
                                                                      let len =
                                                                          i1.len();
                                                                      let blen =
                                                                          bytes.len();
                                                                      let m =
                                                                          min(len,
                                                                              blen);
                                                                      let reduced =
                                                                          &i1[..m];
                                                                      let b =
                                                                          &bytes[..m];
                                                                      let res:
                                                                              ::IResult<_,
                                                                                        _> =
                                                                          if reduced
                                                                                 !=
                                                                                 b
                                                                             {
                                                                              ::IResult::Error(::Err::Position(::ErrorKind::Tag,
                                                                                                               i1))
                                                                          } else if m
                                                                                        <
                                                                                        blen
                                                                           {
                                                                              ::IResult::Incomplete(::Needed::Size(blen))
                                                                          } else {
                                                                              ::IResult::Done(&i1[blen..],
                                                                                              reduced)
                                                                          };
                                                                      res
                                                                  }
                                                              } {
                                                            ::IResult::Error(a)
                                                            =>
                                                            ::IResult::Error(a),
                                                            ::IResult::Incomplete(i)
                                                            =>
                                                            ::IResult::Incomplete(i),
                                                            ::IResult::Done(i2,
                                                                            _)
                                                            => {
                                                                ::IResult::Done(i2,
                                                                                o1)
                                                            }
                                                        }
                                                    }
                                                }
                                            } {
                                          ::IResult::Error(e) =>
                                          ::IResult::Error(e),
                                          ::IResult::Incomplete(::Needed::Unknown)
                                          =>
                                          ::IResult::Incomplete(::Needed::Unknown),
                                          ::IResult::Incomplete(::Needed::Size(i))
                                          =>
                                          ::IResult::Incomplete(::Needed::Size(i)),
                                          ::IResult::Done(i, o) =>
                                          ::IResult::Done(i,
                                                          to_utf8_string(o)),
                                      }
                                  } {
                                ::IResult::Incomplete(n) => {
                                    ::ConsumerState::Continue(::Move::Await(n))
                                }
                                ::IResult::Error(_) => {
                                    ::ConsumerState::Error(())
                                }
                                ::IResult::Done(i, o) => {
                                    ::ConsumerState::Done(::Move::Consume(sl.offset(i)),
                                                          o)
                                }
                            };
                        &self.state
                    }
                }
            }
            fn state(&self) -> &::ConsumerState<String, (), ::Move> {
                &self.state
            }
        }
        fn get_line(producer: &mut FileProducer, mv: Move)
         -> Option<(Move, String)> {
            let mut a = LineConsumer{state: ConsumerState::Continue(mv),};
            while let &ConsumerState::Continue(_) = producer.apply(&mut a) {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["continue\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match () {
                                                                     () => [],
                                                                 }));
            }
            if let &ConsumerState::Done(ref m, ref s) = a.state() {
                Some((m.clone(), s.clone()))
            } else { None }
        }
        #[test]
        pub fn file() {
            let mut f = FileProducer::new("LICENSE", 200).unwrap();
            f.refill();
            let mut mv = Move::Consume(0);
            for i in 1..10 {
                if let Some((m, s)) = get_line(&mut f, mv.clone()) {
                    ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                        static __STATIC_FMTSTR:
                                                                               &'static [&'static str]
                                                                               =
                                                                            &["got line[",
                                                                              "]: ",
                                                                              "\n"];
                                                                        __STATIC_FMTSTR
                                                                    },
                                                                    &match (&i,
                                                                            &s)
                                                                         {
                                                                         (__arg0,
                                                                          __arg1)
                                                                         =>
                                                                         [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                      ::std::fmt::Display::fmt),
                                                                          ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                      ::std::fmt::Display::fmt)],
                                                                     }));
                    mv = m;
                } else {
                    if !false {
                        {
                            ::std::rt::begin_unwind("LineConsumer should not have failed",
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/stream.rs",
                                                             933u32);
                                                        &_FILE_LINE
                                                    })
                        }
                    };
                }
            }
        }
        enum SeekState { Begin, SeekedToEnd, ShouldEof, IsEof, }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for SeekState {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                match (&*self,) {
                    (&SeekState::Begin,) => { }
                    (&SeekState::SeekedToEnd,) => { }
                    (&SeekState::ShouldEof,) => { }
                    (&SeekState::IsEof,) => { }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for SeekState {
            #[inline]
            fn eq(&self, __arg_0: &SeekState) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as i32;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as i32;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) {
                            (&SeekState::Begin, &SeekState::Begin) => true,
                            (&SeekState::SeekedToEnd, &SeekState::SeekedToEnd)
                            => true,
                            (&SeekState::ShouldEof, &SeekState::ShouldEof) =>
                            true,
                            (&SeekState::IsEof, &SeekState::IsEof) => true,
                            _ => unsafe { ::std::intrinsics::unreachable() }
                        }
                    } else { false }
                }
            }
            #[inline]
            fn ne(&self, __arg_0: &SeekState) -> bool {
                {
                    let __self_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*self)
                        } as i32;
                    let __arg_1_vi =
                        unsafe {
                            ::std::intrinsics::discriminant_value(&*__arg_0)
                        } as i32;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*__arg_0) {
                            (&SeekState::Begin, &SeekState::Begin) => false,
                            (&SeekState::SeekedToEnd, &SeekState::SeekedToEnd)
                            => false,
                            (&SeekState::ShouldEof, &SeekState::ShouldEof) =>
                            false,
                            (&SeekState::IsEof, &SeekState::IsEof) => false,
                            _ => unsafe { ::std::intrinsics::unreachable() }
                        }
                    } else { true }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for SeekState { }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for SeekState {
            #[inline]
            fn clone(&self) -> SeekState {
                match (&*self,) {
                    (&SeekState::Begin,) => SeekState::Begin,
                    (&SeekState::SeekedToEnd,) => SeekState::SeekedToEnd,
                    (&SeekState::ShouldEof,) => SeekState::ShouldEof,
                    (&SeekState::IsEof,) => SeekState::IsEof,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for SeekState {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&SeekState::Begin,) => {
                        let mut builder = __arg_0.debug_tuple("Begin");
                        builder.finish()
                    }
                    (&SeekState::SeekedToEnd,) => {
                        let mut builder = __arg_0.debug_tuple("SeekedToEnd");
                        builder.finish()
                    }
                    (&SeekState::ShouldEof,) => {
                        let mut builder = __arg_0.debug_tuple("ShouldEof");
                        builder.finish()
                    }
                    (&SeekState::IsEof,) => {
                        let mut builder = __arg_0.debug_tuple("IsEof");
                        builder.finish()
                    }
                }
            }
        }
        struct SeekingConsumer {
            state: ConsumerState<(), u8, Move>,
            position: SeekState,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for SeekingConsumer {
            fn fmt(&self, __arg_0: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    SeekingConsumer {
                    state: ref __self_0_0, position: ref __self_0_1 } => {
                        let mut builder =
                            __arg_0.debug_struct("SeekingConsumer");
                        let _ = builder.field("state", &&(*__self_0_0));
                        let _ = builder.field("position", &&(*__self_0_1));
                        builder.finish()
                    }
                }
            }
        }
        impl SeekingConsumer {
            fn position(&self) -> SeekState { self.position }
        }
        impl <'a> Consumer<&'a [u8], (), u8, Move> for SeekingConsumer {
            fn handle(&mut self, input: Input<&'a [u8]>)
             -> &ConsumerState<(), u8, Move> {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["input: ",
                                                                          "\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match (&input,)
                                                                     {
                                                                     (__arg0,)
                                                                     =>
                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                  ::std::fmt::Debug::fmt)],
                                                                 }));
                match self.position {
                    SeekState::Begin => {
                        self.state =
                            ConsumerState::Continue(Move::Seek(SeekFrom::End(-4)));
                        self.position = SeekState::SeekedToEnd;
                    }
                    SeekState::SeekedToEnd =>
                    match input {
                        Input::Element(sl) => {
                            if sl.len() == 4 {
                                self.state =
                                    ConsumerState::Continue(Move::Consume(4));
                                self.position = SeekState::ShouldEof;
                            } else { self.state = ConsumerState::Error(0); }
                        }
                        Input::Eof(Some(sl)) => {
                            if sl.len() == 4 {
                                self.state =
                                    ConsumerState::Done(Move::Consume(4), ());
                                self.position = SeekState::IsEof;
                            } else { self.state = ConsumerState::Error(1); }
                        }
                        _ => self.state = ConsumerState::Error(2),
                    },
                    SeekState::ShouldEof =>
                    match input {
                        Input::Eof(Some(sl)) => {
                            if sl.len() == 0 {
                                self.state =
                                    ConsumerState::Done(Move::Consume(0), ());
                                self.position = SeekState::IsEof;
                            } else { self.state = ConsumerState::Error(3); }
                        }
                        Input::Eof(None) => {
                            self.state =
                                ConsumerState::Done(Move::Consume(0), ());
                            self.position = SeekState::IsEof;
                        }
                        _ => self.state = ConsumerState::Error(4),
                    },
                    _ => self.state = ConsumerState::Error(5),
                };
                &self.state
            }
            fn state(&self) -> &ConsumerState<(), u8, Move> { &self.state }
        }
        #[test]
        pub fn seeking_consumer() {
            let mut f =
                FileProducer::new("assets/testfile.txt", 200).unwrap();
            f.refill();
            let mut a =
                SeekingConsumer{state:
                                    ConsumerState::Continue(Move::Consume(0)),
                                position: SeekState::Begin,};
            for _ in 1..4 {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["file apply ",
                                                                          "\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match (&f.apply(&mut a),)
                                                                     {
                                                                     (__arg0,)
                                                                     =>
                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                  ::std::fmt::Debug::fmt)],
                                                                 }));
            }
            ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                static __STATIC_FMTSTR:
                                                                       &'static [&'static str]
                                                                       =
                                                                    &["consumer is now: ",
                                                                      "\n"];
                                                                __STATIC_FMTSTR
                                                            },
                                                            &match (&a,) {
                                                                 (__arg0,) =>
                                                                 [::std::fmt::ArgumentV1::new(__arg0,
                                                                                              ::std::fmt::Debug::fmt)],
                                                             }));
            if let &ConsumerState::Done(Move::Consume(0), ()) = a.state() {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["end\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match () {
                                                                     () => [],
                                                                 }));
            } else {
                ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                                    static __STATIC_FMTSTR:
                                                                           &'static [&'static str]
                                                                           =
                                                                        &["invalid state is ",
                                                                          "\n"];
                                                                    __STATIC_FMTSTR
                                                                },
                                                                &match (&a.state(),)
                                                                     {
                                                                     (__arg0,)
                                                                     =>
                                                                     [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                  ::std::fmt::Debug::fmt)],
                                                                 }));
                if !false {
                    {
                        ::std::rt::begin_unwind("consumer is not at EOF",
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/stream.rs",
                                                         1025u32);
                                                    &_FILE_LINE
                                                })
                    }
                };
            }
            {
                match (&(a.position()), &(SeekState::IsEof)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/stream.rs",
                                                                     1027u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::mem;
            pub use super::mem2;
            pub use super::map;
            pub use super::chain;
            pub use super::shift_test;
            pub use super::file;
            pub use super::seeking_consumer;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::tests::__test_reexports as tests;
    }
}
#[cfg(not(feature = "core"))]
mod str {
    //! Parsers and helper functions operating on strings, especially useful when writing parsers for
    //! text-based formats.
    #[prelude_import]
    use std::prelude::v1::*;
    #[cfg(test)]
    mod test {
        #[prelude_import]
        use std::prelude::v1::*;
        use IResult;
        #[test]
        pub fn tag_str_succeed() {
            const INPUT: &'static str = "Hello World!";
            const TAG: &'static str = "Hello";
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    let res: ::IResult<_, _> =
                        if TAG.len() > input.len() {
                            ::IResult::Incomplete(::Needed::Size(TAG.len()))
                        } else if (input).starts_with(TAG) {
                            ::IResult::Done(&input[TAG.len()..],
                                            &input[0..TAG.len()])
                        } else {
                            ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                             input))
                        };
                    res
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == " World!") {
                        {
                            ::std::rt::begin_unwind("Parser `tag_s` consumed leftover input.",
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             363u32);
                                                        &_FILE_LINE
                                                    })
                        }
                    };
                    if !(output == TAG) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `tag_s` doesn\'t return the tag it matched on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&TAG,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 364u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `tag_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         368u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn tag_str_incomplete() {
            const INPUT: &'static str = "Hello";
            const TAG: &'static str = "Hello World!";
            match {
                      let res: ::IResult<_, _> =
                          if TAG.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(TAG.len()))
                          } else if (INPUT).starts_with(TAG) {
                              ::IResult::Done(&INPUT[TAG.len()..],
                                              &INPUT[0..TAG.len()])
                          } else {
                              ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                               INPUT))
                          };
                      res
                  } {
                IResult::Incomplete(_) => (),
                other => {
                    {
                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                      static __STATIC_FMTSTR:
                                                                                             &'static [&'static str]
                                                                                             =
                                                                                          &["Parser `tag_s` didn\'t require more input when it should have. Got `",
                                                                                            "`."];
                                                                                      __STATIC_FMTSTR
                                                                                  },
                                                                                  &match (&other,)
                                                                                       {
                                                                                       (__arg0,)
                                                                                       =>
                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                   }),
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             381u32);
                                                        &_FILE_LINE
                                                    })
                    };
                }
            };
        }
        #[test]
        pub fn tag_str_error() {
            const INPUT: &'static str = "Hello World!";
            const TAG: &'static str = "Random";
            match {
                      let res: ::IResult<_, _> =
                          if TAG.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(TAG.len()))
                          } else if (INPUT).starts_with(TAG) {
                              ::IResult::Done(&INPUT[TAG.len()..],
                                              &INPUT[0..TAG.len()])
                          } else {
                              ::IResult::Error(::Err::Position(::ErrorKind::TagStr,
                                                               INPUT))
                          };
                      res
                  } {
                IResult::Error(_) => (),
                other => {
                    {
                        ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                      static __STATIC_FMTSTR:
                                                                                             &'static [&'static str]
                                                                                             =
                                                                                          &["Parser `tag_s` didn\'t fail when it should have. Got `",
                                                                                            "`.`"];
                                                                                      __STATIC_FMTSTR
                                                                                  },
                                                                                  &match (&other,)
                                                                                       {
                                                                                       (__arg0,)
                                                                                       =>
                                                                                       [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                    ::std::fmt::Debug::fmt)],
                                                                                   }),
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             395u32);
                                                        &_FILE_LINE
                                                    })
                    };
                }
            };
        }
        #[test]
        pub fn take_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            match {
                      let cnt = 9 as usize;
                      let res: ::IResult<_, _> =
                          if INPUT.chars().count() < cnt {
                              ::IResult::Incomplete(::Needed::Size(cnt))
                          } else {
                              let mut offset = INPUT.len();
                              let mut count = 0;
                              for (o, _) in INPUT.char_indices() {
                                  if count == cnt { offset = o; break ; }
                                  count += 1;
                              }
                              ::IResult::Done(&INPUT[offset..],
                                              &INPUT[..offset])
                          };
                      res
                  } {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_s` consumed leftover input. Leftover `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 408u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_s` doens\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 409u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         413u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_until_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const FIND: &'static str = "\u{c2}\u{df}\u{c7}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}";
            const LEFTOVER: &'static str =
                "\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            match {
                      #[inline(always)]
                      fn shift_window_and_cmp(window: &mut Vec<char>, c: char,
                                              substr_vec: &Vec<char>)
                       -> bool {
                          window.push(c);
                          if window.len() > substr_vec.len() {
                              window.remove(0);
                          }
                          window == substr_vec
                      }
                      let res: ::IResult<&str, &str> =
                          if FIND.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(FIND.len()))
                          } else {
                              let substr_vec: Vec<char> =
                                  FIND.chars().collect();
                              let mut window: Vec<char> =
                                  <[_]>::into_vec(::std::boxed::Box::new([]));
                              let mut offset = INPUT.len();
                              let mut parsed = false;
                              for (o, c) in INPUT.char_indices() {
                                  if shift_window_and_cmp(&mut window, c,
                                                          &substr_vec) {
                                      parsed = true;
                                      offset =
                                          o - window[1].len_utf8() -
                                              window[2].len_utf8()
                                  }
                              }
                              if parsed {
                                  ::IResult::Done(&INPUT[offset..],
                                                  &INPUT[..offset])
                              } else {
                                  ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilStr,
                                                                   INPUT))
                              }
                          };
                      res
                  } {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_until_s`consumed leftover input. Leftover `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 427u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_until_s`doens\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 429u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_until_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         433u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_s_incomplete() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}";
            match {
                      let cnt = 13 as usize;
                      let res: ::IResult<_, _> =
                          if INPUT.chars().count() < cnt {
                              ::IResult::Incomplete(::Needed::Size(cnt))
                          } else {
                              let mut offset = INPUT.len();
                              let mut count = 0;
                              for (o, _) in INPUT.char_indices() {
                                  if count == cnt { offset = o; break ; }
                                  count += 1;
                              }
                              ::IResult::Done(&INPUT[offset..],
                                              &INPUT[..offset])
                          };
                      res
                  } {
                IResult::Incomplete(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_s` didn\'t require more input when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         444u32);
                                                    &_FILE_LINE
                                                })
                }
            }
        }
        use internal::IResult::{Done, Error};
        use internal::Err::Position;
        use util::ErrorKind;
        pub fn is_alphabetic(c: char) -> bool {
            ((c as u8) >= 65 && (c as u8) <= 90) ||
                ((c as u8) >= 97 && (c as u8) <= 122)
        }
        #[test]
        pub fn take_while_s() {
            fn f(i: &str) -> ::IResult<&str, &str, u32> {
                {
                    let mut offset = i.len();
                    for (o, c) in i.char_indices() {
                        if !is_alphabetic(c) { offset = o; break ; }
                    }
                    if offset < i.len() {
                        ::IResult::Done(&i[offset..], &i[..offset])
                    } else { ::IResult::Done("", i) }
                }
            }
            let a = "";
            let b = "abcd";
            let c = "abcd123";
            let d = "123";
            {
                match (&(f(&a[..])), &(Done(&a[..], &a[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     464u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&b[..])), &(Done(&a[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     465u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&c[..])), &(Done(&d[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     466u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&d[..])), &(Done(&d[..], &a[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     467u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_while1_s() {
            fn f(i: &str) -> ::IResult<&str, &str, u32> {
                {
                    let mut offset = i.len();
                    for (o, c) in i.char_indices() {
                        if !is_alphabetic(c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::TakeWhile1Str,
                                                         i))
                    } else if offset < i.len() {
                        ::IResult::Done(&i[offset..], &i[..offset])
                    } else { ::IResult::Done("", i) }
                }
            }
            let a = "";
            let b = "abcd";
            let c = "abcd123";
            let d = "123";
            {
                match (&(f(&a[..])),
                       &(Error(Position(ErrorKind::TakeWhile1Str, &""[..]))))
                    {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     478u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&b[..])), &(Done(&a[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     479u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&c[..])), &(Done(&"123"[..], &b[..]))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     480u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
            {
                match (&(f(&d[..])),
                       &(Error(Position(ErrorKind::TakeWhile1Str, &d[..])))) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                              static __STATIC_FMTSTR:
                                                                                                     &'static [&'static str]
                                                                                                     =
                                                                                                  &["assertion failed: `(left == right)` (left: `",
                                                                                                    "`, right: `",
                                                                                                    "`)"];
                                                                                              __STATIC_FMTSTR
                                                                                          },
                                                                                          &match (&left_val,
                                                                                                  &right_val)
                                                                                               {
                                                                                               (__arg0,
                                                                                                __arg1)
                                                                                               =>
                                                                                               [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                           }),
                                                            {
                                                                static _FILE_LINE:
                                                                       (&'static str,
                                                                        u32) =
                                                                    ("src/str.rs",
                                                                     481u32);
                                                                &_FILE_LINE
                                                            })
                            }
                        }
                    }
                }
            };
        }
        #[test]
        pub fn take_till_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn till_s(c: char) -> bool { c == '\u{e1}' }
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if till_s(c) { offset = o; break ; }
                    }
                    if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind("Parser `take_till_s` consumed leftover input.",
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             497u32);
                                                        &_FILE_LINE
                                                    })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_till_s` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 498u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_till_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         502u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_while_s_succeed_none() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const CONSUMED: &'static str = "";
            const LEFTOVER: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn while_s(c: char) -> bool { c == '9' }
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if !while_s(c) { offset = o; break ; }
                    }
                    if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind("Parser `take_while_s` consumed leftover input.",
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             520u32);
                                                        &_FILE_LINE
                                                    })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_while_s` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 521u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_while_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         525u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn is_not_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const AVOID: &'static str =
                "\u{a3}\u{fa}\u{e7}\u{199}\u{a5}\u{e1}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    use std::collections::HashSet;
                    let set: HashSet<char> = AVOID.chars().collect();
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if set.contains(&c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::IsAStr,
                                                         input))
                    } else if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `is_not_s` consumed leftover input. Leftover `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 541u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `is_not_s` doens\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 542u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `is_not_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         546u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_until_and_consume_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const FIND: &'static str = "\u{c2}\u{df}\u{c7}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            match {
                      #[inline(always)]
                      fn shift_window_and_cmp(window:
                                                  &mut ::std::vec::Vec<char>,
                                              c: char,
                                              substr_vec:
                                                  &::std::vec::Vec<char>)
                       -> bool {
                          window.push(c);
                          if window.len() > substr_vec.len() {
                              window.remove(0);
                          }
                          window == substr_vec
                      }
                      let res: ::IResult<_, _> =
                          if FIND.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(FIND.len()))
                          } else {
                              let substr_vec: ::std::vec::Vec<char> =
                                  FIND.chars().collect();
                              let mut window: ::std::vec::Vec<char> =
                                  <[_]>::into_vec(::std::boxed::Box::new([]));
                              let mut offset = INPUT.len();
                              let mut parsed = false;
                              for (o, c) in INPUT.char_indices() {
                                  if parsed { offset = o; break ; }
                                  if shift_window_and_cmp(&mut window, c,
                                                          &substr_vec) {
                                      parsed = true;
                                  }
                              }
                              if parsed {
                                  if offset < INPUT.len() {
                                      ::IResult::Done(&INPUT[offset..],
                                                      &INPUT[..offset])
                                  } else { ::IResult::Done("", INPUT) }
                              } else {
                                  ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilAndConsumeStr,
                                                                   INPUT))
                              }
                          };
                      res
                  } {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_until_and_consume_s`consumed leftover input. Leftover `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 560u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_until_and_consume_s`doens\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 562u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_until_and_consume_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         566u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_while_s_succeed_some() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn while_s(c: char) -> bool {
                c == '\u{3b2}' || c == '\u{e8}' || c == '\u{192}' ||
                    c == '\u{f4}' || c == '\u{159}' || c == '\u{e8}' ||
                    c == '\u{c2}' || c == '\u{df}' || c == '\u{c7}'
            }
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if !while_s(c) { offset = o; break ; }
                    }
                    if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind("Parser `take_while_s` consumed leftover input.",
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             585u32);
                                                        &_FILE_LINE
                                                    })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_while_s` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 586u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_while_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         590u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn is_not_s_fail() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const AVOID: &'static str = "\u{3b2}\u{fa}\u{e7}\u{199}\u{a5}";
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    use std::collections::HashSet;
                    let set: HashSet<char> = AVOID.chars().collect();
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if set.contains(&c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::IsAStr,
                                                         input))
                    } else if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Error(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `is_not_s` didn\'t fail when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         604u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_while1_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn while1_s(c: char) -> bool {
                c == '\u{3b2}' || c == '\u{e8}' || c == '\u{192}' ||
                    c == '\u{f4}' || c == '\u{159}' || c == '\u{e8}' ||
                    c == '\u{c2}' || c == '\u{df}' || c == '\u{c7}'
            }
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if !while1_s(c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::TakeWhile1Str,
                                                         input))
                    } else if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind("Parser `take_while1_s` consumed leftover input.",
                                                    {
                                                        static _FILE_LINE:
                                                               (&'static str,
                                                                u32) =
                                                            ("src/str.rs",
                                                             622u32);
                                                        &_FILE_LINE
                                                    })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `take_while1_s` doesn\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 623u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_while1_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         627u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_until_and_consume_s_incomplete() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}";
            const FIND: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            match {
                      #[inline(always)]
                      fn shift_window_and_cmp(window:
                                                  &mut ::std::vec::Vec<char>,
                                              c: char,
                                              substr_vec:
                                                  &::std::vec::Vec<char>)
                       -> bool {
                          window.push(c);
                          if window.len() > substr_vec.len() {
                              window.remove(0);
                          }
                          window == substr_vec
                      }
                      let res: ::IResult<_, _> =
                          if FIND.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(FIND.len()))
                          } else {
                              let substr_vec: ::std::vec::Vec<char> =
                                  FIND.chars().collect();
                              let mut window: ::std::vec::Vec<char> =
                                  <[_]>::into_vec(::std::boxed::Box::new([]));
                              let mut offset = INPUT.len();
                              let mut parsed = false;
                              for (o, c) in INPUT.char_indices() {
                                  if parsed { offset = o; break ; }
                                  if shift_window_and_cmp(&mut window, c,
                                                          &substr_vec) {
                                      parsed = true;
                                  }
                              }
                              if parsed {
                                  if offset < INPUT.len() {
                                      ::IResult::Done(&INPUT[offset..],
                                                      &INPUT[..offset])
                                  } else { ::IResult::Done("", INPUT) }
                              } else {
                                  ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilAndConsumeStr,
                                                                   INPUT))
                              }
                          };
                      res
                  } {
                IResult::Incomplete(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_until_and_consume_s` didn\'t require more input when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         639u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_until_s_incomplete() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}";
            const FIND: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            match {
                      #[inline(always)]
                      fn shift_window_and_cmp(window: &mut Vec<char>, c: char,
                                              substr_vec: &Vec<char>)
                       -> bool {
                          window.push(c);
                          if window.len() > substr_vec.len() {
                              window.remove(0);
                          }
                          window == substr_vec
                      }
                      let res: ::IResult<&str, &str> =
                          if FIND.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(FIND.len()))
                          } else {
                              let substr_vec: Vec<char> =
                                  FIND.chars().collect();
                              let mut window: Vec<char> =
                                  <[_]>::into_vec(::std::boxed::Box::new([]));
                              let mut offset = INPUT.len();
                              let mut parsed = false;
                              for (o, c) in INPUT.char_indices() {
                                  if shift_window_and_cmp(&mut window, c,
                                                          &substr_vec) {
                                      parsed = true;
                                      offset =
                                          o - window[1].len_utf8() -
                                              window[2].len_utf8()
                                  }
                              }
                              if parsed {
                                  ::IResult::Done(&INPUT[offset..],
                                                  &INPUT[..offset])
                              } else {
                                  ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilStr,
                                                                   INPUT))
                              }
                          };
                      res
                  } {
                IResult::Incomplete(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_until_s` didn\'t require more input when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         651u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn is_a_s_succeed() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const MATCH: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const CONSUMED: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}";
            const LEFTOVER: &'static str =
                "\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    use std::collections::HashSet;
                    let set: HashSet<char> = MATCH.chars().collect();
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if !set.contains(&c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::IsAStr,
                                                         input))
                    } else if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Done(extra, output) => {
                    if !(extra == LEFTOVER) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `is_a_s` consumed leftover input. Leftover `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&extra,)
                                                                                           {
                                                                                           (__arg0,)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 667u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                    if !(output == CONSUMED) {
                        {
                            ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                          static __STATIC_FMTSTR:
                                                                                                 &'static [&'static str]
                                                                                                 =
                                                                                              &["Parser `is_a_s` doens\'t return the string it consumed on success. Expected `",
                                                                                                "`, got `",
                                                                                                "`."];
                                                                                          __STATIC_FMTSTR
                                                                                      },
                                                                                      &match (&CONSUMED,
                                                                                              &output)
                                                                                           {
                                                                                           (__arg0,
                                                                                            __arg1)
                                                                                           =>
                                                                                           [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                        ::std::fmt::Display::fmt),
                                                                                            ::std::fmt::ArgumentV1::new(__arg1,
                                                                                                                        ::std::fmt::Display::fmt)],
                                                                                       }),
                                                        {
                                                            static _FILE_LINE:
                                                                   (&'static str,
                                                                    u32) =
                                                                ("src/str.rs",
                                                                 668u32);
                                                            &_FILE_LINE
                                                        })
                        }
                    };
                }
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `is_a_s` didn\'t succeed when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         672u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_while1_s_fail() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            fn while1_s(c: char) -> bool { c == '9' }
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if !while1_s(c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::TakeWhile1Str,
                                                         input))
                    } else if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Error(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_while1_s` didn\'t fail when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         688u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn is_a_s_fail() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const MATCH: &'static str =
                "\u{db}\u{f1}\u{2113}\u{fa}\u{e7}\u{199}\u{a5}";
            fn test(input: &str) -> IResult<&str, &str> {
                {
                    use std::collections::HashSet;
                    let set: HashSet<char> = MATCH.chars().collect();
                    let mut offset = input.len();
                    for (o, c) in input.char_indices() {
                        if !set.contains(&c) { offset = o; break ; }
                    }
                    if offset == 0 {
                        ::IResult::Error(::Err::Position(::ErrorKind::IsAStr,
                                                         input))
                    } else if offset < input.len() {
                        ::IResult::Done(&input[offset..], &input[..offset])
                    } else { ::IResult::Done("", input) }
                }
            }
            match test(INPUT) {
                IResult::Error(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `is_a_s` didn\'t fail when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         702u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_until_and_consume_s_error() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const FIND: &'static str = "R\u{e1}\u{f1}\u{3b4}\u{f4}\u{20a5}";
            match {
                      #[inline(always)]
                      fn shift_window_and_cmp(window:
                                                  &mut ::std::vec::Vec<char>,
                                              c: char,
                                              substr_vec:
                                                  &::std::vec::Vec<char>)
                       -> bool {
                          window.push(c);
                          if window.len() > substr_vec.len() {
                              window.remove(0);
                          }
                          window == substr_vec
                      }
                      let res: ::IResult<_, _> =
                          if FIND.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(FIND.len()))
                          } else {
                              let substr_vec: ::std::vec::Vec<char> =
                                  FIND.chars().collect();
                              let mut window: ::std::vec::Vec<char> =
                                  <[_]>::into_vec(::std::boxed::Box::new([]));
                              let mut offset = INPUT.len();
                              let mut parsed = false;
                              for (o, c) in INPUT.char_indices() {
                                  if parsed { offset = o; break ; }
                                  if shift_window_and_cmp(&mut window, c,
                                                          &substr_vec) {
                                      parsed = true;
                                  }
                              }
                              if parsed {
                                  if offset < INPUT.len() {
                                      ::IResult::Done(&INPUT[offset..],
                                                      &INPUT[..offset])
                                  } else { ::IResult::Done("", INPUT) }
                              } else {
                                  ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilAndConsumeStr,
                                                                   INPUT))
                              }
                          };
                      res
                  } {
                IResult::Error(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_until_and_consume_s` didn\'t fail when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         713u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        #[test]
        pub fn take_until_s_error() {
            const INPUT: &'static str =
                "\u{3b2}\u{e8}\u{192}\u{f4}\u{159}\u{e8}\u{c2}\u{df}\u{c7}\u{e1}\u{192}\u{1ad}\u{e8}\u{159}";
            const FIND: &'static str = "R\u{e1}\u{f1}\u{3b4}\u{f4}\u{20a5}";
            match {
                      #[inline(always)]
                      fn shift_window_and_cmp(window: &mut Vec<char>, c: char,
                                              substr_vec: &Vec<char>)
                       -> bool {
                          window.push(c);
                          if window.len() > substr_vec.len() {
                              window.remove(0);
                          }
                          window == substr_vec
                      }
                      let res: ::IResult<&str, &str> =
                          if FIND.len() > INPUT.len() {
                              ::IResult::Incomplete(::Needed::Size(FIND.len()))
                          } else {
                              let substr_vec: Vec<char> =
                                  FIND.chars().collect();
                              let mut window: Vec<char> =
                                  <[_]>::into_vec(::std::boxed::Box::new([]));
                              let mut offset = INPUT.len();
                              let mut parsed = false;
                              for (o, c) in INPUT.char_indices() {
                                  if shift_window_and_cmp(&mut window, c,
                                                          &substr_vec) {
                                      parsed = true;
                                      offset =
                                          o - window[1].len_utf8() -
                                              window[2].len_utf8()
                                  }
                              }
                              if parsed {
                                  ::IResult::Done(&INPUT[offset..],
                                                  &INPUT[..offset])
                              } else {
                                  ::IResult::Error(::Err::Position(::ErrorKind::TakeUntilStr,
                                                                   INPUT))
                              }
                          };
                      res
                  } {
                IResult::Error(_) => (),
                other => {
                    ::std::rt::begin_unwind_fmt(::std::fmt::Arguments::new_v1({
                                                                                  static __STATIC_FMTSTR:
                                                                                         &'static [&'static str]
                                                                                         =
                                                                                      &["Parser `take_until_and_consume_s` didn\'t fail when it should have. Got `",
                                                                                        "`."];
                                                                                  __STATIC_FMTSTR
                                                                              },
                                                                              &match (&other,)
                                                                                   {
                                                                                   (__arg0,)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(__arg0,
                                                                                                                ::std::fmt::Debug::fmt)],
                                                                               }),
                                                {
                                                    static _FILE_LINE:
                                                           (&'static str, u32)
                                                           =
                                                        ("src/str.rs",
                                                         725u32);
                                                    &_FILE_LINE
                                                })
                }
            };
        }
        pub mod __test_reexports {
            #[prelude_import]
            use std::prelude::v1::*;
            pub use super::tag_str_succeed;
            pub use super::tag_str_incomplete;
            pub use super::tag_str_error;
            pub use super::take_s_succeed;
            pub use super::take_until_s_succeed;
            pub use super::take_s_incomplete;
            pub use super::take_while_s;
            pub use super::take_while1_s;
            pub use super::take_till_s_succeed;
            pub use super::take_while_s_succeed_none;
            pub use super::is_not_s_succeed;
            pub use super::take_until_and_consume_s_succeed;
            pub use super::take_while_s_succeed_some;
            pub use super::is_not_s_fail;
            pub use super::take_while1_s_succeed;
            pub use super::take_until_and_consume_s_incomplete;
            pub use super::take_until_s_incomplete;
            pub use super::is_a_s_succeed;
            pub use super::take_while1_s_fail;
            pub use super::is_a_s_fail;
            pub use super::take_until_and_consume_s_error;
            pub use super::take_until_s_error;
        }
    }
    pub mod __test_reexports {
        #[prelude_import]
        use std::prelude::v1::*;
        pub use super::test::__test_reexports as test;
    }
}
pub mod __test_reexports {
    #[prelude_import]
    use std::prelude::v1::*;
    pub use super::macros::__test_reexports as macros;
    pub use super::methods::__test_reexports as methods;
    pub use super::bytes::__test_reexports as bytes;
    pub use super::bits::__test_reexports as bits;
    pub use super::nom::__test_reexports as nom;
    pub use super::character::__test_reexports as character;
    pub use super::stream::__test_reexports as stream;
    pub use super::str::__test_reexports as str;
}
pub mod __test {
    #[prelude_import]
    use std::prelude::v1::*;
    extern crate test;
    #[main]
    pub fn main() -> () { test::test_main_static(TESTS); }
    const TESTS: &'static [self::test::TestDescAndFn] =
        &[self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::pub_named_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::pub_named_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::apply_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::apply_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::chain2"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::chain2),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::nested_chain"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::nested_chain),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::chain_mut"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::chain_mut),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::chain_opt"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::chain_opt),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::err"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::err),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::add_err"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::add_err),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::complete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::complete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::alt"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::alt),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::alt_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::alt_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::alt_complete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::alt_complete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::switch"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::switch),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::opt"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::opt),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::opt_res"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::opt_res),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::cond"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::cond),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::cond_wrapping"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::cond_wrapping),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::peek"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::peek),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::pair"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::pair),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::separated_pair"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::separated_pair),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::preceded"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::preceded),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::terminated"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::terminated),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::delimited"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::delimited),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::separated_list"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::separated_list),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::separated_nonempty_list"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::separated_nonempty_list),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::many0"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::many0),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::many1"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::many1),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::infinite_many"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::infinite_many),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::many_m_n"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::many_m_n),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::count"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::count),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::count_zero"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::count_zero),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::count_fixed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::count_fixed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::count_fixed_no_type"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::count_fixed_no_type),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::length_value_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::length_value_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::chain_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::chain_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("macros::tests::tuple_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::macros::tests::tuple_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_abc"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_abc),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_bcd"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_bcd),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_hij"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_hij),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_ijk"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_ijk),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_rc"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_rc),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_apply_rf"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_apply_rf),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_peek"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_peek),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("methods::tests::test_method_call_chain"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::methods::tests::test_method_call_chain),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::is_a"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::is_a),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::is_not"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::is_not),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::escaping"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::escaping),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::escape_transform"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::escape_transform),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::issue_84"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::issue_84),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::take_str_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::take_str_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::take_until_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::take_until_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::take_until_either_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::take_until_either_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::take_until_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::take_until_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::recognize"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::recognize),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::take_while"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::take_while),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bytes::tests::take_while1"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bytes::tests::take_while1),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bits::tests::take_bits"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bits::tests::take_bits),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bits::tests::tag_bits"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bits::tests::tag_bits),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bits::tests::chain_bits"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bits::tests::chain_bits),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("bits::tests::bits_to_bytes"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::bits::tests::bits_to_bytes),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::tag_closure"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::tag_closure),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::character"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::character),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::character_s"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::character_s),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::offset"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::offset),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::is_not"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::is_not),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::buffer_with_size"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::buffer_with_size),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::length_value_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::length_value_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::i8_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::i8_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::i16_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::i16_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::i32_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::i32_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::i64_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::i64_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::le_i8_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::le_i8_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::le_i16_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::le_i16_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::le_i32_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::le_i32_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::le_i64_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::le_i64_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::hex_u32_tests"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::hex_u32_tests),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::end_of_input"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::end_of_input),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::configurable_endianness"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::configurable_endianness),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::manual_configurable_endianness_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::manual_configurable_endianness_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("nom::tests::hex_digit_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::nom::tests::hex_digit_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("character::tests::one_of"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::character::tests::one_of),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("character::tests::none_of"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::character::tests::none_of),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("character::tests::char"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::character::tests::char),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::mem"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::mem),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::mem2"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::mem2),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::map"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::map),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::chain"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::chain),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::shift_test"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::shift_test),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::file"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::file),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("stream::tests::seeking_consumer"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::stream::tests::seeking_consumer),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::tag_str_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::tag_str_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::tag_str_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::tag_str_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::tag_str_error"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::tag_str_error),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_until_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_until_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_s_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_s_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_while_s"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_while_s),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_while1_s"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_while1_s),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_till_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_till_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_while_s_succeed_none"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_while_s_succeed_none),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::is_not_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::is_not_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_until_and_consume_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_until_and_consume_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_while_s_succeed_some"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_while_s_succeed_some),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::is_not_s_fail"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::is_not_s_fail),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_while1_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_while1_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_until_and_consume_s_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_until_and_consume_s_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_until_s_incomplete"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_until_s_incomplete),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::is_a_s_succeed"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::is_a_s_succeed),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_while1_s_fail"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_while1_s_fail),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::is_a_s_fail"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::is_a_s_fail),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_until_and_consume_s_error"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_until_and_consume_s_error),},
          self::test::TestDescAndFn{desc:
                                        self::test::TestDesc{name:
                                                                 self::test::StaticTestName("str::test::take_until_s_error"),
                                                             ignore: false,
                                                             should_panic:
                                                                 self::test::ShouldPanic::No,},
                                    testfn:
                                        self::test::StaticTestFn(::__test_reexports::str::test::take_until_s_error),}];
}
